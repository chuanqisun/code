<!DOCTYPE html>
<html>
  <head>
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #111;
        padding: 10px;
      }
      #grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 8px;
      }
      canvas {
        width: 100%;
        aspect-ratio: 1;
        display: block;
      }
      label {
        color: #888;
        font: 10px monospace;
        padding: 2px 4px;
        display: block;
      }
      .cell {
        display: flex;
        flex-direction: column;
      }
    </style>
  </head>
  <body>
    <div id="grid"></div>

    <script>
      const W = 400,
        H = 400,
        N = 100;
      const cx = W / 2,
        cy = H / 2;

      const demos = [
        [
          "harmonic ring",
          ({ ctx, t }) => {
            clear(ctx);
            for (let i = 0; i < N; i++) {
              const angle = (i + 1) * 0.003 * t;
              pt(ctx, cx + 100 * Math.cos(angle), cy + 100 * Math.sin(angle));
            }
          },
        ],

        [
          "spiral unwind",
          ({ ctx, t }) => {
            clear(ctx);
            for (let i = 0; i < N; i++) {
              const n = i + 1,
                angle = n * 0.004 * t;
              const r = n * 1.1 * Math.abs(Math.sin(0.0005 * n * t));
              pt(ctx, cx + r * Math.cos(angle), cy + r * Math.sin(angle));
            }
          },
        ],

        [
          "rdtd breathing",
          ({ ctx, t }) => {
            clear(ctx);
            for (let i = 0; i < N; i++) {
              const n = i + 1;
              const angle = n * 0.003 * t;
              const r = 120 + 5 * Math.sin(n * 0.003 * t * 0.1);
              pt(ctx, cx + r * Math.cos(angle), cy + r * Math.sin(angle));
            }
          },
        ],

        [
          "convergence",
          ({ ctx, t }) => {
            clear(ctx);
            for (let i = 0; i < N; i++) {
              const angle = (i + 1) * 0.01 * t;
              pt(ctx, cx + 100 * Math.cos(angle), cy + 100 * Math.sin(angle));
            }
          },
        ],

        [
          "lissajous dots",
          ({ ctx, t }) => {
            clear(ctx);
            for (let i = 0; i < N; i++) {
              const n = i + 1;
              pt(ctx, cx + 110 * Math.cos(n * 0.003 * t), cy + 110 * Math.sin((n + 1) * 0.003 * t));
            }
          },
        ],

        [
          "radial spokes",
          ({ ctx, t }) => {
            clear(ctx);
            const S = 12;
            for (let i = 0; i < N; i++) {
              const a = (i % S) * ((Math.PI * 2) / S);
              const r = 20 + 80 * Math.abs(Math.sin((Math.floor(i / S) + 1) * 0.005 * t));
              pt(ctx, cx + r * Math.cos(a), cy + r * Math.sin(a));
            }
          },
        ],

        [
          "galaxy arms",
          ({ ctx, t }) => {
            clear(ctx, 0.2);
            for (let i = 0; i < N; i++) {
              const n = i + 1,
                angle = n * 0.003 * t + (i % 2 ? Math.PI : 0);
              pt(ctx, cx + (20 + n) * Math.cos(angle), cy + (20 + n) * Math.sin(angle), 1.5);
            }
          },
        ],

        [
          "epitrochoid",
          ({ ctx, t }) => {
            clear(ctx);
            const R = 70,
              r = 30;
            for (let i = 0; i < N; i++) {
              const n = i + 1,
                d = n * 0.8,
                phi = n * 0.003 * t;
              pt(ctx, cx + (R + r) * Math.cos(phi) - d * Math.cos(((R + r) / r) * phi), cy + (R + r) * Math.sin(phi) - d * Math.sin(((R + r) / r) * phi), 1.5);
            }
          },
        ],

        [
          "standing wave ring",
          ({ ctx, t }) => {
            clear(ctx);
            for (let i = 0; i < N; i++) {
              const angle = (i / N) * Math.PI * 2;
              const r = 90 + 30 * Math.sin((i + 1) * 0.01 * t + angle * 6);
              pt(ctx, cx + r * Math.cos(angle), cy + r * Math.sin(angle));
            }
          },
        ],

        [
          "differential grid",
          ({ ctx, t }) => {
            clear(ctx);
            const C = 10;
            for (let i = 0; i < N; i++) {
              const col = i % C,
                row = Math.floor(i / C);
              const x = cx + 110 * Math.cos((col + 1) * 0.004 * t) * (col / C - 0.5) * 2;
              const y = cy + 110 * Math.sin((row + 1) * 0.004 * t) * (row / C - 0.5) * 2;
              pt(ctx, x, y);
            }
          },
        ],

        [
          "arabesque fold",
          ({ ctx, t }) => {
            clear(ctx);
            for (let i = 0; i < N; i++) {
              const n = i + 1,
                angle = n * 0.003 * t;
              const r = 100 * Math.abs(Math.sin(Math.sin(angle) * 3));
              pt(ctx, cx + r * Math.cos(angle), cy + r * Math.sin(angle));
            }
          },
        ],

        [
          "phase flower",
          ({ ctx, t }) => {
            clear(ctx, 0.25);
            for (let i = 0; i < N; i++) {
              const n = i + 1,
                phase = (n / N) * Math.PI * 2;
              const angle = n * 0.002 * t + phase;
              const r = 80 + 50 * Math.sin(n * 0.002 * t * 0.5 + phase * 3);
              pt(ctx, cx + r * Math.cos(angle), cy + r * Math.sin(angle), 1.5);
            }
          },
        ],

        [
          "pendulum web",
          ({ ctx, t }) => {
            clear(ctx, 0.15);
            for (let i = 0; i < N; i++) {
              const n = i + 1;
              const x = cx + 110 * Math.sin(n * 0.007 * t);
              const y = cy + 110 * Math.sin(n * 0.007 * t + n * 0.001 * t + n * 0.3);
              pt(ctx, x, y, 1.5);
            }
          },
        ],

        [
          "hypotrochoid swarm",
          ({ ctx, t }) => {
            clear(ctx);
            const R = 90,
              r = 35;
            for (let i = 0; i < N; i++) {
              const n = i + 1,
                d = n * 0.9,
                phi = n * 0.004 * t;
              pt(ctx, cx + (R - r) * Math.cos(phi) + d * Math.cos(((R - r) / r) * phi), cy + (R - r) * Math.sin(phi) - d * Math.sin(((R - r) / r) * phi), 1.5);
            }
          },
        ],

        [
          "pulse rings",
          ({ ctx, t }) => {
            clear(ctx);
            const PHI = (137.5 * Math.PI) / 180;
            for (let i = 0; i < N; i++) {
              const n = i + 1;
              const ring = (t * 0.005 * n) % 1;
              const r = ring * 130;
              pt(ctx, cx + r * Math.cos(i * PHI), cy + r * Math.sin(i * PHI), 2);
            }
          },
        ],

        [
          "fibonacci spiral",
          ({ ctx, t }) => {
            clear(ctx);
            const PHI = (137.508 * Math.PI) / 180;
            for (let i = 0; i < N; i++) {
              const angle = i * PHI + (i + 1) * 0.001 * t;
              const r = Math.sqrt(i) * 12;
              pt(ctx, cx + r * Math.cos(angle), cy + r * Math.sin(angle));
            }
          },
        ],

        [
          "wave interference",
          ({ ctx, t }) => {
            clear(ctx, 0.18);
            const M = 90;
            // harmonic indices drift slowly so all interference orders are visited
            const k1 = 6 + 2 * Math.sin(0.0003 * t); // ~4–8
            const k2 = 9 + 3 * Math.sin(0.0002 * t); // ~6–12
            for (let i = 0; i < M; i++) {
              const ang = (i / M) * Math.PI * 2;
              // one wave travels clockwise, the other counter-clockwise
              const w1 = Math.sin(k1 * ang - 0.055 * t);
              const w2 = Math.sin(k2 * ang + 0.045 * t);
              const r = 90 + 60 * (w1 + w2) * 0.5;
              pt(ctx, cx + r * Math.cos(ang), cy + r * Math.sin(ang), 2);
            }
          },
        ],

        [
          "orbit trails",
          ({ ctx, t }) => {
            clear(ctx, 0.04);
            for (let i = 0; i < N; i++) {
              const n = i + 1,
                a = n * 0.005 * t;
              pt(ctx, cx + (40 + n * 0.7) * Math.cos(a), cy + (20 + n * 0.5) * Math.sin(a), 1.5);
            }
          },
        ],

        [
          "differential rose",
          ({ ctx, t }) => {
            clear(ctx);
            for (let i = 0; i < N; i++) {
              const n = i + 1,
                k = 1 + (i % 7),
                theta = n * 0.004 * t;
              const r = 110 * Math.abs(Math.cos(k * theta));
              pt(ctx, cx + r * Math.cos(theta), cy + r * Math.sin(theta));
            }
          },
        ],

        [
          "vortex collapse",
          ({ ctx, t }) => {
            clear(ctx, 0.18);
            for (let i = 0; i < N; i++) {
              const n = i + 1;
              const angle = n * 0.006 * t;
              const r = ((Math.sin(n * 0.002 * t) + 1) / 2) * 120;
              pt(ctx, cx + r * Math.cos(angle), cy + r * Math.sin(angle), 1.5);
            }
          },
        ],

        [
          "moiré dots",
          ({ ctx, t }) => {
            clear(ctx);
            const STEP = 22;
            for (let x = STEP / 2; x < W; x += STEP)
              for (let y = STEP / 2; y < H; y += STEP) {
                const a1 = 0.0003 * t,
                  a2 = 0.0007 * t;
                const rx1 = (x - cx) * Math.cos(a1) - (y - cy) * Math.sin(a1);
                const ry1 = (x - cx) * Math.sin(a1) + (y - cy) * Math.cos(a1);
                const rx2 = (x - cx) * Math.cos(a2) - (y - cy) * Math.sin(a2);
                const ry2 = (x - cx) * Math.sin(a2) + (y - cy) * Math.cos(a2);
                if (Math.sin(rx1 * 0.2) * Math.sin(ry1 * 0.2) + Math.sin(rx2 * 0.2) * Math.sin(ry2 * 0.2) > 0.5) pt(ctx, x, y, 2);
              }
          },
        ],

        [
          "harmonic web",
          ({ ctx, t }) => {
            clear(ctx);
            const pts = [];
            for (let i = 0; i < N; i++) {
              const n = i + 1,
                angle = n * 0.003 * t;
              const r = 80 + 30 * Math.sin(n * 0.002 * t);
              pts.push([cx + r * Math.cos(angle), cy + r * Math.sin(angle)]);
            }
            ctx.strokeStyle = "rgba(255,255,255,0.15)";
            ctx.lineWidth = 0.5;
            for (let i = 0; i < pts.length - 1; i += 2) {
              ctx.beginPath();
              ctx.moveTo(...pts[i]);
              ctx.lineTo(...pts[i + 1]);
              ctx.stroke();
            }
            pts.forEach(([x, y]) => pt(ctx, x, y, 1.5));
          },
        ],

        [
          "double pendulum cloud",
          ({ ctx, t }) => {
            clear(ctx, 0.1);
            for (let i = 0; i < N; i++) {
              const n = i + 1;
              const a1 = n * 0.011 * t,
                a2 = n * 0.007 * t;
              const x = cx + 70 * Math.sin(a1) + 40 * Math.sin(a2);
              const y = cy + 70 * Math.cos(a1) + 40 * Math.cos(a2);
              pt(ctx, x, y, 1.5);
            }
          },
        ],

        [
          "resonance lattice",
          ({ ctx, t }) => {
            clear(ctx);
            const C = 10;
            const speed = t * 0.025;
            const amp = 15;
            for (let i = 0; i < N; i++) {
              const col = i % C;
              const row = Math.floor(i / C);
              const bx = (col / (C - 1)) * W * 0.8 + W * 0.1;
              const by = (row / (C - 1)) * H * 0.8 + H * 0.1;
              const dx = amp * Math.sin(row * 0.7 + col * 0.3 - speed);
              const dy = amp * Math.sin(col * 0.7 + row * 0.3 - speed * 1.05);
              pt(ctx, bx + dx, by + dy, 2);
            }
          },
        ],

        [
          "nodal lines",
          ({ ctx, t }) => {
            clear(ctx);
            const STEP = 14;
            for (let x = 0; x < W; x += STEP)
              for (let y = 0; y < H; y += STEP) {
                const fx = 0.04 * (x - cx),
                  fy = 0.04 * (y - cy);
                const v = Math.sin(fx * Math.cos(0.003 * t) - fy * Math.sin(0.003 * t)) * Math.sin(fy * Math.cos(0.003 * t) + fx * Math.sin(0.003 * t));
                if (Math.abs(v) < 0.15) pt(ctx, x, y, 2);
              }
          },
        ],

        [
          "differential clock",
          ({ ctx, t }) => {
            clear(ctx);
            const RINGS = 8;
            for (let ring = 0; ring < RINGS; ring++) {
              const dotsInRing = ring + 3;
              const r = 20 + (ring + 1) * 14;
              const speed = (ring + 1) * 0.004;
              for (let d = 0; d < dotsInRing; d++) {
                const baseAngle = (d / dotsInRing) * Math.PI * 2;
                const angle = baseAngle + speed * t;
                pt(ctx, cx + r * Math.cos(angle), cy + r * Math.sin(angle), 2);
              }
            }
          },
        ],

        [
          "whitney ensemble 1",
          ({ ctx, t }) => {
            clear(ctx, 0.15);
            for (let i = 0; i < N; i++) {
              const n = i + 1;
              const angle = n * 0.003 * t;
              const r = 60 + n * 0.5 * Math.abs(Math.sin(0.001 * t));
              pt(ctx, cx + r * Math.cos(angle), cy + r * Math.sin(angle), 1.5);
            }
          },
        ],

        [
          "whitney ensemble 2",
          ({ ctx, t }) => {
            clear(ctx, 0.12);
            for (let i = 0; i < N; i++) {
              const n = i + 1;
              const theta = n * 0.003 * t;
              const phi = n * 0.003 * t * 0.618; // golden ratio counter-rotation
              const r = 100 * Math.abs(Math.sin(theta - phi));
              pt(ctx, cx + r * Math.cos(theta), cy + r * Math.sin(theta), 1.5);
            }
          },
        ],
      ];

      // helpers
      function clear(ctx, alpha = 1) {
        ctx.fillStyle = alpha < 1 ? `rgba(0,0,0,${alpha})` : "black";
        ctx.fillRect(0, 0, W, H);
      }
      function pt(ctx, x, y, r = 2) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();
      }

      // recording
      const REC_TILE = 480,
        REC_GAP = 4,
        REC_BORDER = 4,
        REC_COLS = 4;
      const REC_ROWS = Math.ceil(28 / REC_COLS); // 7
      const REC_W = REC_COLS * REC_TILE + (REC_COLS - 1) * REC_GAP + REC_BORDER * 2;
      const REC_H = REC_ROWS * REC_TILE + (REC_ROWS - 1) * REC_GAP + REC_BORDER * 2;

      let recCtx = null,
        mediaRecorder = null,
        recChunks = [];
      let recOverlay = null;

      // flash effect
      // Pre-computed schedule: [{tile, blinkStart, solidStart, solidEnd}] (ms from rec start)
      let flashSchedule = [];
      let recStartTime = 0;
      let activeFlashMap = new Map(); // rebuilt each frame on i===0

      function buildFlashSchedule(durationMs) {
        const sched = [];
        let t = 300 + Math.random() * 400; // first batch ~300–700 ms in
        while (t < durationMs - 1500) {
          const count = 1 + Math.floor(Math.random() * 3); // 1–3 tiles per batch
          const used = new Set();
          for (let n = 0; n < count; n++) {
            let tile;
            let attempts = 0;
            do {
              tile = Math.floor(Math.random() * demos.length);
              attempts++;
            } while (used.has(tile) && attempts < 50);
            used.add(tile);
            const blinkDur = 300 + Math.random() * 450; // 0.3–0.75 s rapid strobe
            const solidDur = 1000 + Math.random() * 1000; // 1–2 s held on
            sched.push({ tile, blinkStart: t, solidStart: t + blinkDur, solidEnd: t + blinkDur + solidDur });
          }
          t += 600 + Math.random() * 1000; // next batch 0.6–1.6 s later
        }
        return sched;
      }

      function pickMime() {
        for (const m of ["video/webm;codecs=vp9", "video/webm;codecs=vp8", "video/webm"]) if (MediaRecorder.isTypeSupported(m)) return m;
        return "";
      }

      function startRecording() {
        if (mediaRecorder) return;

        // ask user for duration
        const input = prompt("Recording duration (seconds):", "10");
        if (input === null) return; // cancelled
        const duration = Math.max(1, parseFloat(input) || 10) * 1000;

        // reset all clocks to zero
        states.forEach((s) => (s.t = 0));

        const canvas = document.createElement("canvas");
        canvas.width = REC_W;
        canvas.height = REC_H;
        recCtx = canvas.getContext("2d");

        const stream = canvas.captureStream(60);
        const mime = pickMime();
        mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : {});
        recChunks = [];

        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) recChunks.push(e.data);
        };
        mediaRecorder.onstop = () => {
          const blob = new Blob(recChunks, { type: "video/webm" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "whitney-dots.webm";
          a.click();
          setTimeout(() => URL.revokeObjectURL(url), 5000);
          recCtx = null;
          mediaRecorder = null;
          flashSchedule = [];
          activeFlashMap.clear();
          if (recOverlay) {
            recOverlay.remove();
            recOverlay = null;
          }
        };

        flashSchedule = buildFlashSchedule(duration);
        recStartTime = Date.now();
        mediaRecorder.start(100); // collect chunks every 100 ms

        // overlay indicator
        recOverlay = document.createElement("div");
        Object.assign(recOverlay.style, {
          position: "fixed",
          top: "10px",
          right: "10px",
          background: "rgba(200,0,0,.85)",
          color: "#fff",
          font: "bold 13px monospace",
          padding: "6px 12px",
          borderRadius: "4px",
          zIndex: 9999,
          pointerEvents: "none",
        });
        document.body.appendChild(recOverlay);

        const deadline = Date.now() + duration;
        const tick = () => {
          if (!recOverlay) return;
          const s = Math.max(0, Math.ceil((deadline - Date.now()) / 1000));
          recOverlay.textContent = `● REC  ${s}s`;
          if (s > 0) setTimeout(tick, 250);
        };
        tick();

        setTimeout(() => {
          if (mediaRecorder && mediaRecorder.state !== "inactive") mediaRecorder.stop();
        }, duration);
      }

      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.shiftKey && e.key === "P") {
          e.preventDefault();
          startRecording();
        }
      });

      // build grid
      const grid = document.getElementById("grid");
      const states = demos.map(([name, fn]) => {
        const cell = document.createElement("div");
        cell.className = "cell";
        const lbl = document.createElement("label");
        lbl.textContent = name;
        const canvas = document.createElement("canvas");
        canvas.width = W;
        canvas.height = H;
        cell.append(canvas, lbl);
        grid.append(cell);
        return { ctx: canvas.getContext("2d"), t: 0, fn };
      });

      // loop
      function loop() {
        const now = Date.now();
        states.forEach((s, i) => {
          s.fn(s);
          s.t += 0.5;

          // composite into recording canvas when active
          if (recCtx) {
            if (i === 0) {
              // rebuild active flash map for this frame
              const recT = now - recStartTime;
              activeFlashMap.clear();
              for (const f of flashSchedule) if (recT >= f.blinkStart && recT < f.solidEnd) activeFlashMap.set(f.tile, f);
              recCtx.fillStyle = "#444";
              recCtx.fillRect(0, 0, REC_W, REC_H);
            }
            const col = i % REC_COLS;
            const row = Math.floor(i / REC_COLS);
            const flash = activeFlashMap.get(i);
            const recT = now - recStartTime;
            // blink phase: strobe every 80 ms; solid phase: hold on
            const flashing = flash && (recT < flash.solidStart ? Math.floor((recT - flash.blinkStart) / 80) % 2 === 0 : true);
            if (flashing) recCtx.filter = "invert(100%)";
            recCtx.drawImage(s.ctx.canvas, REC_BORDER + col * (REC_TILE + REC_GAP), REC_BORDER + row * (REC_TILE + REC_GAP), REC_TILE, REC_TILE);
            if (flashing) recCtx.filter = "none";
          }
        });
        requestAnimationFrame(loop);
      }
      loop();
    </script>
  </body>
</html>
