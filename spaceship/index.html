<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Cache-control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <title>Face Landmarker</title>
    <script type="module" crossorigin>
      (function () {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const s of document.querySelectorAll('link[rel="modulepreload"]')) i(s);
        new MutationObserver((s) => {
          for (const r of s) if (r.type === "childList") for (const A of r.addedNodes) A.tagName === "LINK" && A.rel === "modulepreload" && i(A);
        }).observe(document, { childList: !0, subtree: !0 });
        function t(s) {
          const r = {};
          return (
            s.integrity && (r.integrity = s.integrity),
            s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy),
            s.crossOrigin === "use-credentials"
              ? (r.credentials = "include")
              : s.crossOrigin === "anonymous"
              ? (r.credentials = "omit")
              : (r.credentials = "same-origin"),
            r
          );
        }
        function i(s) {
          if (s.ep) return;
          s.ep = !0;
          const r = t(s);
          fetch(s.href, r);
        }
      })();
      var dr = typeof self < "u" ? self : {};
      function ms() {
        throw Error("Invalid UTF8");
      }
      function lh(n, e) {
        return (e = String.fromCharCode.apply(null, e)), n == null ? e : n + e;
      }
      let FA, Da;
      const bg = typeof TextDecoder < "u";
      let zg;
      const Rg = typeof TextEncoder < "u";
      function Qd(n) {
        if (Rg) n = (zg ||= new TextEncoder()).encode(n);
        else {
          let t = 0;
          const i = new Uint8Array(3 * n.length);
          for (let s = 0; s < n.length; s++) {
            var e = n.charCodeAt(s);
            if (e < 128) i[t++] = e;
            else {
              if (e < 2048) i[t++] = (e >> 6) | 192;
              else {
                if (e >= 55296 && e <= 57343) {
                  if (e <= 56319 && s < n.length) {
                    const r = n.charCodeAt(++s);
                    if (r >= 56320 && r <= 57343) {
                      (e = 1024 * (e - 55296) + r - 56320 + 65536),
                        (i[t++] = (e >> 18) | 240),
                        (i[t++] = ((e >> 12) & 63) | 128),
                        (i[t++] = ((e >> 6) & 63) | 128),
                        (i[t++] = (63 & e) | 128);
                      continue;
                    }
                    s--;
                  }
                  e = 65533;
                }
                (i[t++] = (e >> 12) | 224), (i[t++] = ((e >> 6) & 63) | 128);
              }
              i[t++] = (63 & e) | 128;
            }
          }
          n = t === i.length ? i : i.subarray(0, t);
        }
        return n;
      }
      var Ll, bo;
      e: {
        for (var uh = ["CLOSURE_FLAGS"], Ma = dr, Ca = 0; Ca < uh.length; Ca++)
          if ((Ma = Ma[uh[Ca]]) == null) {
            bo = null;
            break e;
          }
        bo = Ma;
      }
      var gA,
        hh = bo && bo[610401301];
      Ll = hh != null && hh;
      const fh = dr.navigator;
      function Tc(n) {
        return !!Ll && !!gA && gA.brands.some(({ brand: e }) => e && e.indexOf(n) != -1);
      }
      function Fn(n) {
        var e;
        return ((e = dr.navigator) && (e = e.userAgent)) || (e = ""), e.indexOf(n) != -1;
      }
      function Ji() {
        return !!Ll && !!gA && gA.brands.length > 0;
      }
      function Sa() {
        return Ji() ? Tc("Chromium") : ((Fn("Chrome") || Fn("CriOS")) && !(!Ji() && Fn("Edge"))) || Fn("Silk");
      }
      function Ho(n) {
        return Ho[" "](n), n;
      }
      (gA = (fh && fh.userAgentData) || null), (Ho[" "] = function () {});
      var Bg = !Ji() && (Fn("Trident") || Fn("MSIE"));
      !Fn("Android") || Sa(),
        Sa(),
        Fn("Safari") &&
          (Sa() ||
            (!Ji() && Fn("Coast")) ||
            (!Ji() && Fn("Opera")) ||
            (!Ji() && Fn("Edge")) ||
            (Ji() ? Tc("Microsoft Edge") : Fn("Edg/")) ||
            (Ji() && Tc("Opera")));
      var Vd = {},
        AA = null;
      function Og(n) {
        const e = n.length;
        let t = (3 * e) / 4;
        t % 3 ? (t = Math.floor(t)) : "=.".indexOf(n[e - 1]) != -1 && (t = "=.".indexOf(n[e - 2]) != -1 ? t - 2 : t - 1);
        const i = new Uint8Array(t);
        let s = 0;
        return (
          (function (r, A) {
            function o(c) {
              for (; a < r.length; ) {
                const l = r.charAt(a++),
                  u = AA[l];
                if (u != null) return u;
                if (!/^[\s\xa0]*$/.test(l)) throw Error("Unknown base64 encoding at char: " + l);
              }
              return c;
            }
            Wd();
            let a = 0;
            for (;;) {
              const c = o(-1),
                l = o(0),
                u = o(64),
                h = o(64);
              if (h === 64 && c === -1) break;
              A((c << 2) | (l >> 4)), u != 64 && (A(((l << 4) & 240) | (u >> 2)), h != 64 && A(((u << 6) & 192) | h));
            }
          })(n, function (r) {
            i[s++] = r;
          }),
          s !== t ? i.subarray(0, s) : i
        );
      }
      function Wd() {
        if (!AA) {
          AA = {};
          var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),
            e = ["+/=", "+/", "-_=", "-_.", "-_"];
          for (let t = 0; t < 5; t++) {
            const i = n.concat(e[t].split(""));
            Vd[t] = i;
            for (let s = 0; s < i.length; s++) {
              const r = i[s];
              AA[r] === void 0 && (AA[r] = s);
            }
          }
        }
      }
      var Kd = typeof Uint8Array < "u",
        Yd = !Bg && typeof btoa == "function";
      function dh(n) {
        if (!Yd) {
          var e;
          e === void 0 && (e = 0), Wd(), (e = Vd[e]);
          var t = Array(Math.floor(n.length / 3)),
            i = e[64] || "";
          let a = 0,
            c = 0;
          for (; a < n.length - 2; a += 3) {
            var s = n[a],
              r = n[a + 1],
              A = n[a + 2],
              o = e[s >> 2];
            (s = e[((3 & s) << 4) | (r >> 4)]), (r = e[((15 & r) << 2) | (A >> 6)]), (A = e[63 & A]), (t[c++] = o + s + r + A);
          }
          switch (((o = 0), (A = i), n.length - a)) {
            case 2:
              A = e[(15 & (o = n[a + 1])) << 2] || i;
            case 1:
              (n = n[a]), (t[c] = e[n >> 2] + e[((3 & n) << 4) | (o >> 4)] + A + i);
          }
          return t.join("");
        }
        for (e = "", t = 0, i = n.length - 10240; t < i; ) e += String.fromCharCode.apply(null, n.subarray(t, (t += 10240)));
        return (e += String.fromCharCode.apply(null, t ? n.subarray(t) : n)), btoa(e);
      }
      const ph = /[-_.]/g,
        Lg = { "-": "+", _: "/", ".": "=" };
      function Ug(n) {
        return Lg[n] || "";
      }
      function qd(n) {
        if (!Yd) return Og(n);
        ph.test(n) && (n = n.replace(ph, Ug)), (n = atob(n));
        const e = new Uint8Array(n.length);
        for (let t = 0; t < n.length; t++) e[t] = n.charCodeAt(t);
        return e;
      }
      function Bs(n) {
        return Kd && n != null && n instanceof Uint8Array;
      }
      var pr = {};
      function Os() {
        return (Fg ||= new Ri(null, pr));
      }
      function Ul(n) {
        Xd(pr);
        var e = n.g;
        return (e = e == null || Bs(e) ? e : typeof e == "string" ? qd(e) : null) == null ? e : (n.g = e);
      }
      var Ri = class {
        h() {
          return new Uint8Array(Ul(this) || 0);
        }
        constructor(n, e) {
          if ((Xd(e), (this.g = n), n != null && n.length === 0)) throw Error("ByteString should be constructed with non-empty values");
        }
      };
      let Fg, Ng;
      function Xd(n) {
        if (n !== pr) throw Error("illegal external caller");
      }
      function Jd(n, e) {
        n.__closure__error__context__984382 || (n.__closure__error__context__984382 = {}), (n.__closure__error__context__984382.severity = e);
      }
      function Ec(n) {
        return Jd((n = Error(n)), "warning"), n;
      }
      function Fl(n) {
        if (n != null) {
          var e = (Ng ??= {}),
            t = e[n] || 0;
          t >= 5 ||
            ((e[n] = t + 1),
            Jd((n = Error()), "incident"),
            (function (i) {
              dr.setTimeout(() => {
                throw i;
              }, 0);
            })(n));
        }
      }
      var Qo = typeof Symbol == "function" && typeof Symbol() == "symbol";
      function Br(n, e, t = !1) {
        return typeof Symbol == "function" && typeof Symbol() == "symbol" ? (t && Symbol.for && n ? Symbol.for(n) : n != null ? Symbol(n) : Symbol()) : e;
      }
      var kg = Br("jas", void 0, !0),
        mh = Br(void 0, "0di"),
        qr = Br(void 0, "1oa"),
        mr = Br(void 0, Symbol()),
        Gg = Br(void 0, "0actk"),
        Zd = Br(void 0, "8utk");
      const _e = Qo ? kg : "Ea",
        $d = { Ea: { value: 0, configurable: !0, writable: !0, enumerable: !1 } },
        ep = Object.defineProperties;
      function Vo(n, e) {
        Qo || _e in n || ep(n, $d), (n[_e] |= e);
      }
      function Ut(n, e) {
        Qo || _e in n || ep(n, $d), (n[_e] = e);
      }
      function Or(n) {
        return Vo(n, 34), n;
      }
      function jg(n, e) {
        Ut(e, -15615 & (0 | n));
      }
      function Dc(n, e) {
        Ut(e, -15581 & (34 | n));
      }
      function Wo() {
        return typeof BigInt == "function";
      }
      function hn(n) {
        return Array.prototype.slice.call(n);
      }
      var Nl,
        IA = {};
      function Ko(n) {
        return n !== null && typeof n == "object" && !Array.isArray(n) && n.constructor === Object;
      }
      function kl(n, e) {
        if (n != null) {
          if (typeof n == "string") n = n ? new Ri(n, pr) : Os();
          else if (n.constructor !== Ri)
            if (Bs(n)) n = n.length ? new Ri(new Uint8Array(n), pr) : Os();
            else {
              if (!e) throw Error();
              n = void 0;
            }
        }
        return n;
      }
      const gh = [];
      function ls(n) {
        if (2 & n) throw Error();
      }
      Ut(gh, 55), (Nl = Object.freeze(gh));
      class Ph {
        constructor(e, t, i) {
          (this.g = e), (this.h = t), (this.l = i);
        }
        next() {
          const e = this.g.next();
          return e.done || (e.value = this.h.call(this.l, e.value)), e;
        }
        [Symbol.iterator]() {
          return this;
        }
      }
      function Gl(n) {
        return mr ? n[mr] : void 0;
      }
      var Hg = Object.freeze({});
      function Yo(n) {
        return (n.Na = !0), n;
      }
      var Qg = Yo((n) => typeof n == "number"),
        vh = Yo((n) => typeof n == "string"),
        Vg = Yo((n) => typeof n == "boolean"),
        qo = typeof dr.BigInt == "function" && typeof dr.BigInt(0) == "bigint";
      function ts(n) {
        var e = n;
        if (vh(e)) {
          if (!/^\s*(?:-?[1-9]\d*|0)?\s*$/.test(e)) throw Error(String(e));
        } else if (Qg(e) && !Number.isSafeInteger(e)) throw Error(String(e));
        return qo ? BigInt(n) : (n = Vg(n) ? (n ? "1" : "0") : vh(n) ? n.trim() || "0" : String(n));
      }
      var Mc = Yo((n) => (qo ? n >= Kg && n <= qg : n[0] === "-" ? wh(n, Wg) : wh(n, Yg)));
      const Wg = Number.MIN_SAFE_INTEGER.toString(),
        Kg = qo ? BigInt(Number.MIN_SAFE_INTEGER) : void 0,
        Yg = Number.MAX_SAFE_INTEGER.toString(),
        qg = qo ? BigInt(Number.MAX_SAFE_INTEGER) : void 0;
      function wh(n, e) {
        if (n.length > e.length) return !1;
        if (n.length < e.length || n === e) return !0;
        for (let t = 0; t < n.length; t++) {
          const i = n[t],
            s = e[t];
          if (i > s) return !1;
          if (i < s) return !0;
        }
      }
      const Xg = typeof Uint8Array.prototype.slice == "function";
      let tp,
        dt = 0,
        zt = 0;
      function _h(n) {
        const e = n >>> 0;
        (dt = e), (zt = ((n - e) / 4294967296) >>> 0);
      }
      function Ls(n) {
        if (n < 0) {
          _h(-n);
          const [e, t] = Vl(dt, zt);
          (dt = e >>> 0), (zt = t >>> 0);
        } else _h(n);
      }
      function jl(n) {
        const e = (tp ||= new DataView(new ArrayBuffer(8)));
        e.setFloat32(0, +n, !0), (zt = 0), (dt = e.getUint32(0, !0));
      }
      function Hl(n, e) {
        const t = 4294967296 * e + (n >>> 0);
        return Number.isSafeInteger(t) ? t : PA(n, e);
      }
      function Ql(n, e) {
        const t = 2147483648 & e;
        return t && ((e = ~e >>> 0), (n = (1 + ~n) >>> 0) == 0 && (e = (e + 1) >>> 0)), typeof (n = Hl(n, e)) == "number" ? (t ? -n : n) : t ? "-" + n : n;
      }
      function PA(n, e) {
        if (((n >>>= 0), (e >>>= 0) <= 2097151)) var t = "" + (4294967296 * e + n);
        else
          Wo()
            ? (t = "" + ((BigInt(e) << BigInt(32)) | BigInt(n)))
            : ((n = (16777215 & n) + 6777216 * (t = 16777215 & ((n >>> 24) | (e << 8))) + 6710656 * (e = (e >> 16) & 65535)),
              (t += 8147497 * e),
              (e *= 2),
              n >= 1e7 && ((t += (n / 1e7) >>> 0), (n %= 1e7)),
              t >= 1e7 && ((e += (t / 1e7) >>> 0), (t %= 1e7)),
              (t = e + xh(t) + xh(n)));
        return t;
      }
      function xh(n) {
        return (n = String(n)), "0000000".slice(n.length) + n;
      }
      function np() {
        var n = dt,
          e = zt;
        if (2147483648 & e)
          if (Wo()) n = "" + ((BigInt(0 | e) << BigInt(32)) | BigInt(n >>> 0));
          else {
            const [t, i] = Vl(n, e);
            n = "-" + PA(t, i);
          }
        else n = PA(n, e);
        return n;
      }
      function Xo(n) {
        if (n.length < 16) Ls(Number(n));
        else if (Wo()) (n = BigInt(n)), (dt = Number(n & BigInt(4294967295)) >>> 0), (zt = Number((n >> BigInt(32)) & BigInt(4294967295)));
        else {
          const e = +(n[0] === "-");
          zt = dt = 0;
          const t = n.length;
          for (let i = e, s = ((t - e) % 6) + e; s <= t; i = s, s += 6) {
            const r = Number(n.slice(i, s));
            (zt *= 1e6), (dt = 1e6 * dt + r), dt >= 4294967296 && ((zt += Math.trunc(dt / 4294967296)), (zt >>>= 0), (dt >>>= 0));
          }
          if (e) {
            const [i, s] = Vl(dt, zt);
            (dt = i), (zt = s);
          }
        }
      }
      function Vl(n, e) {
        return (e = ~e), n ? (n = 1 + ~n) : (e += 1), [n, e];
      }
      const vA = typeof BigInt == "function" ? BigInt.asIntN : void 0,
        Jg = typeof BigInt == "function" ? BigInt.asUintN : void 0,
        ns = Number.isSafeInteger,
        Jo = Number.isFinite,
        gr = Math.trunc,
        Zg = ts(0);
      function us(n) {
        return n == null || typeof n == "number" ? n : n === "NaN" || n === "Infinity" || n === "-Infinity" ? Number(n) : void 0;
      }
      function ip(n) {
        return n == null || typeof n == "boolean" ? n : typeof n == "number" ? !!n : void 0;
      }
      const $g = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
      function wA(n) {
        switch (typeof n) {
          case "bigint":
            return !0;
          case "number":
            return Jo(n);
          case "string":
            return $g.test(n);
          default:
            return !1;
        }
      }
      function Lr(n) {
        if (n == null) return n;
        if (typeof n == "string" && n) n = +n;
        else if (typeof n != "number") return;
        return Jo(n) ? 0 | n : void 0;
      }
      function sp(n) {
        if (n == null) return n;
        if (typeof n == "string" && n) n = +n;
        else if (typeof n != "number") return;
        return Jo(n) ? n >>> 0 : void 0;
      }
      function yh(n) {
        if (n[0] === "-") return !1;
        const e = n.length;
        return e < 20 || (e === 20 && Number(n.substring(0, 6)) < 184467);
      }
      function rp(n) {
        const e = n.length;
        return n[0] === "-" ? e < 20 || (e === 20 && Number(n.substring(0, 7)) > -922337) : e < 19 || (e === 19 && Number(n.substring(0, 6)) < 922337);
      }
      function Ap(n) {
        return rp(n) ? n : (Xo(n), np());
      }
      function Wl(n) {
        return (n = gr(n)), ns(n) || (Ls(n), (n = Ql(dt, zt))), n;
      }
      function op(n) {
        var e = gr(Number(n));
        return ns(e) ? String(e) : ((e = n.indexOf(".")) !== -1 && (n = n.substring(0, e)), Ap(n));
      }
      function Th(n) {
        var e = gr(Number(n));
        return ns(e) ? ts(e) : ((e = n.indexOf(".")) !== -1 && (n = n.substring(0, e)), Wo() ? ts(vA(64, BigInt(n))) : ts(Ap(n)));
      }
      function Eh(n) {
        if (ns(n)) n = ts(Wl(n));
        else {
          if (((n = gr(n)), ns(n))) n = String(n);
          else {
            const e = String(n);
            rp(e) ? (n = e) : (Ls(n), (n = np()));
          }
          n = ts(n);
        }
        return n;
      }
      function Cc(n) {
        return n == null
          ? n
          : typeof n == "bigint"
          ? (Mc(n) ? (n = Number(n)) : ((n = vA(64, n)), (n = Mc(n) ? Number(n) : String(n))), n)
          : wA(n)
          ? typeof n == "number"
            ? Wl(n)
            : op(n)
          : void 0;
      }
      function eP(n) {
        if (n == null) return n;
        var e = typeof n;
        if (e === "bigint") return String(Jg(64, n));
        if (wA(n)) {
          if (e === "string")
            return (
              (e = gr(Number(n))),
              ns(e) && e >= 0 ? (n = String(e)) : ((e = n.indexOf(".")) !== -1 && (n = n.substring(0, e)), yh(n) || (Xo(n), (n = PA(dt, zt)))),
              n
            );
          if (e === "number")
            return (n = gr(n)) >= 0 && ns(n)
              ? n
              : (function (t) {
                  if (t < 0) {
                    Ls(t);
                    var i = PA(dt, zt);
                    return (t = Number(i)), ns(t) ? t : i;
                  }
                  return yh((i = String(t))) ? i : (Ls(t), Hl(dt, zt));
                })(n);
        }
      }
      function ap(n) {
        if (typeof n != "string") throw Error();
        return n;
      }
      function Ur(n) {
        if (n != null && typeof n != "string") throw Error();
        return n;
      }
      function Pr(n) {
        return n == null || typeof n == "string" ? n : void 0;
      }
      function Kl(n, e, t, i) {
        if (n != null && typeof n == "object" && n.W === IA) return n;
        if (!Array.isArray(n)) return t ? (2 & i ? ((n = e[mh]) || (Or((n = new e()).u), (n = e[mh] = n)), (e = n)) : (e = new e())) : (e = void 0), e;
        let s = (t = 0 | n[_e]);
        return s === 0 && (s |= 32 & i), (s |= 2 & i), s !== t && Ut(n, s), new e(n);
      }
      function tP(n, e, t) {
        if (e)
          e: {
            if (!wA((e = n))) throw Ec("int64");
            switch (typeof e) {
              case "string":
                e = Th(e);
                break e;
              case "bigint":
                e = ts(vA(64, e));
                break e;
              default:
                e = Eh(e);
            }
          }
        else (n = typeof (e = n)), (e = e == null ? e : n === "bigint" ? ts(vA(64, e)) : wA(e) ? (n === "string" ? Th(e) : Eh(e)) : void 0);
        return (n = e) == null ? (t ? Zg : void 0) : n;
      }
      function nP(n) {
        return n;
      }
      const iP = {};
      let sP = (function () {
        try {
          return (
            Ho(
              new (class extends Map {
                constructor() {
                  super();
                }
              })()
            ),
            !1
          );
        } catch {
          return !0;
        }
      })();
      class Ia {
        constructor() {
          this.g = new Map();
        }
        get(e) {
          return this.g.get(e);
        }
        set(e, t) {
          return this.g.set(e, t), (this.size = this.g.size), this;
        }
        delete(e) {
          return (e = this.g.delete(e)), (this.size = this.g.size), e;
        }
        clear() {
          this.g.clear(), (this.size = this.g.size);
        }
        has(e) {
          return this.g.has(e);
        }
        entries() {
          return this.g.entries();
        }
        keys() {
          return this.g.keys();
        }
        values() {
          return this.g.values();
        }
        forEach(e, t) {
          return this.g.forEach(e, t);
        }
        [Symbol.iterator]() {
          return this.entries();
        }
      }
      const rP = sP
        ? (Object.setPrototypeOf(Ia.prototype, Map.prototype),
          Object.defineProperties(Ia.prototype, { size: { value: 0, configurable: !0, enumerable: !0, writable: !0 } }),
          Ia)
        : class extends Map {
            constructor() {
              super();
            }
          };
      function Dh(n) {
        return n;
      }
      function ba(n) {
        if (2 & n.M) throw Error("Cannot mutate an immutable Map");
      }
      var li = class extends rP {
        constructor(n, e, t = Dh, i = Dh) {
          super();
          let s = 0 | n[_e];
          (s |= 64), Ut(n, s), (this.M = s), (this.I = e), (this.S = t), (this.X = this.I ? AP : i);
          for (let r = 0; r < n.length; r++) {
            const A = n[r],
              o = t(A[0], !1, !0);
            let a = A[1];
            e ? a === void 0 && (a = null) : (a = i(A[1], !1, !0, void 0, void 0, s)), super.set(o, a);
          }
        }
        La() {
          var n = uP;
          if (this.size !== 0) return Array.from(super.entries(), (e) => ((e[0] = n(e[0])), (e[1] = n(e[1])), e));
        }
        da(n = oP) {
          const e = [],
            t = super.entries();
          for (var i; !(i = t.next()).done; ) ((i = i.value)[0] = n(i[0])), (i[1] = n(i[1])), e.push(i);
          return e;
        }
        clear() {
          ba(this), super.clear();
        }
        delete(n) {
          return ba(this), super.delete(this.S(n, !0, !1));
        }
        entries() {
          if (this.I) {
            var n = super.keys();
            n = new Ph(n, aP, this);
          } else n = super.entries();
          return n;
        }
        values() {
          if (this.I) {
            var n = super.keys();
            n = new Ph(n, li.prototype.get, this);
          } else n = super.values();
          return n;
        }
        forEach(n, e) {
          this.I
            ? super.forEach((t, i, s) => {
                n.call(e, s.get(i), i, s);
              })
            : super.forEach(n, e);
        }
        set(n, e) {
          return ba(this), (n = this.S(n, !0, !1)) == null ? this : e == null ? (super.delete(n), this) : super.set(n, this.X(e, !0, !0, this.I, !1, this.M));
        }
        Ja(n) {
          const e = this.S(n[0], !1, !0);
          (n = n[1]), (n = this.I ? (n === void 0 ? null : n) : this.X(n, !1, !0, void 0, !1, this.M)), super.set(e, n);
        }
        has(n) {
          return super.has(this.S(n, !1, !1));
        }
        get(n) {
          n = this.S(n, !1, !1);
          const e = super.get(n);
          if (e !== void 0) {
            var t = this.I;
            return t ? ((t = this.X(e, !1, !0, t, this.pa, this.M)) !== e && super.set(n, t), t) : e;
          }
        }
        [Symbol.iterator]() {
          return this.entries();
        }
      };
      function AP(n, e, t, i, s, r) {
        return (n = Kl(n, i, t, r)), s && (n = ea(n)), n;
      }
      function oP(n) {
        return n;
      }
      function aP(n) {
        return [n, this.get(n)];
      }
      let cP, cp, lp, lP;
      function Mh() {
        return (cP ||= new li(Or([]), void 0, void 0, void 0, iP));
      }
      function Sc(n, e, t, i, s) {
        if (n != null) {
          if (Array.isArray(n)) {
            const r = 0 | n[_e];
            return n.length === 0 && 1 & r ? void 0 : s && 2 & r ? n : Zo(n, e, t, i !== void 0, s);
          }
          return e(n, i);
        }
      }
      function Zo(n, e, t, i, s) {
        const r = i || t ? 0 | n[_e] : 0,
          A = i ? !!(32 & r) : void 0;
        let o = 0;
        const a = (i = hn(n)).length;
        for (let m = 0; m < a; m++) {
          var c = i[m];
          if (m === a - 1 && Ko(c)) {
            var l = e,
              u = t,
              h = A,
              d = s;
            let g;
            for (let p in c) {
              const f = Sc(c[p], l, u, h, d);
              f != null && ((g ??= {})[p] = f);
            }
            c = g;
          } else c = Sc(i[m], e, t, A, s);
          (i[m] = c), c != null && (o = m + 1);
        }
        return o < a && (i.length = o), t && ((n = Gl(n)) && (i[mr] = hn(n)), t(r, i)), i;
      }
      function uP(n) {
        return Sc(n, Yl, void 0, void 0, !1);
      }
      function Yl(n) {
        switch (typeof n) {
          case "number":
            return Number.isFinite(n) ? n : "" + n;
          case "bigint":
            return Mc(n) ? Number(n) : "" + n;
          case "boolean":
            return n ? 1 : 0;
          case "object":
            if (Bs(n)) return Bs(n) && Fl(Zd), dh(n);
            if (n.W === IA) return up(n);
            if (n instanceof Ri) {
              const e = n.g;
              return e == null ? "" : typeof e == "string" ? e : (n.g = dh(e));
            }
            return n instanceof li ? n.La() : void 0;
        }
        return n;
      }
      function up(n) {
        var e = n.u;
        n = Zo(e, Yl, void 0, void 0, !1);
        var t = 0 | e[_e];
        if ((e = n.length) && !(512 & t)) {
          var i = n[e - 1],
            s = !1;
          Ko(i) ? (e--, (s = !0)) : (i = void 0);
          var r = e - (t = 512 & t ? 0 : -1),
            A = (cp ?? nP)(r, t, n, i);
          if ((i && (n[e] = void 0), r < A && i)) {
            for (var o in ((r = !0), i)) {
              const a = +o;
              a <= A ? ((n[(s = a + t)] = i[o]), (e = Math.max(s + 1, e)), (s = !1), delete i[o]) : (r = !1);
            }
            r && (i = void 0);
          }
          for (r = e - 1; e > 0; r = e - 1)
            if ((o = n[r]) == null) e--, (s = !0);
            else {
              if (!((r -= t) >= A)) break;
              ((i ??= {})[r] = o), e--, (s = !0);
            }
          s && (n.length = e), i && n.push(i);
        }
        return n;
      }
      function is(n, e, t) {
        return (n = hp(n, e[0], e[1], t ? 1 : 2)), e !== lp && t && Vo(n, 8192), n;
      }
      function hp(n, e, t, i) {
        if (n == null) {
          var s = 96;
          t ? ((n = [t]), (s |= 512)) : (n = []), e && (s = (-16760833 & s) | ((1023 & e) << 14));
        } else {
          if (!Array.isArray(n)) throw Error("narr");
          if ((8192 & (s = 0 | n[_e]) || !(64 & s) || 2 & s || Fl(Gg), 1024 & s)) throw Error("farr");
          if (64 & s) return n;
          if ((i === 1 || i === 2 || (s |= 64), t && ((s |= 512), t !== n[0]))) throw Error("mid");
          e: {
            var r = (t = n).length;
            if (r) {
              var A = r - 1;
              if (Ko((i = t[A]))) {
                if ((A -= e = 512 & (s |= 256) ? 0 : -1) >= 1024) throw Error("pvtlmt");
                for (var o in i) (r = +o) < A && ((t[r + e] = i[o]), delete i[o]);
                s = (-16760833 & s) | ((1023 & A) << 14);
                break e;
              }
            }
            if (e) {
              if ((o = Math.max(e, r - (512 & s ? 0 : -1))) > 1024) throw Error("spvt");
              s = (-16760833 & s) | ((1023 & o) << 14);
            }
          }
        }
        return Ut(n, s), n;
      }
      function Ic(n, e, t = Dc) {
        if (n != null) {
          if (Kd && n instanceof Uint8Array) return e ? n : new Uint8Array(n);
          if (Array.isArray(n)) {
            var i = 0 | n[_e];
            return 2 & i
              ? n
              : ((e &&= i === 0 || (!!(32 & i) && !(64 & i || !(16 & i)))),
                e ? (Ut(n, 34 | i), 4 & i && Object.freeze(n), n) : Zo(n, Ic, 4 & i ? Dc : t, !0, !0));
          }
          return (
            n.W === IA
              ? (n = 2 & (i = 0 | (t = n.u)[_e]) ? n : new n.constructor($o(t, i, !0)))
              : n instanceof li && !(2 & n.M) && ((t = Or(n.da(Ic))), (n = new li(t, n.I, n.S, n.X))),
            n
          );
        }
      }
      function $o(n, e, t) {
        const i = t || 2 & e ? Dc : jg,
          s = !!(32 & e);
        return (
          (n = (function (r, A, o) {
            const a = hn(r);
            var c = a.length;
            const l = 256 & A ? a[c - 1] : void 0;
            for (c += l ? -1 : 0, A = 512 & A ? 1 : 0; A < c; A++) a[A] = o(a[A]);
            if (l) {
              A = a[A] = {};
              for (const u in l) A[u] = o(l[u]);
            }
            return (r = Gl(r)) && (a[mr] = hn(r)), a;
          })(n, e, (r) => Ic(r, s, i))),
          Vo(n, 32 | (t ? 2 : 0)),
          n
        );
      }
      function ea(n) {
        const e = n.u,
          t = 0 | e[_e];
        return 2 & t ? new n.constructor($o(e, t, !1)) : n;
      }
      function vr(n, e) {
        return Gi((n = n.u), 0 | n[_e], e);
      }
      function Gi(n, e, t) {
        if (t === -1) return null;
        const i = t + (512 & e ? 0 : -1),
          s = n.length - 1;
        return i >= s && 256 & e ? n[s][t] : i <= s ? n[i] : void 0;
      }
      function mt(n, e, t) {
        const i = n.u;
        let s = 0 | i[_e];
        return ls(s), St(i, s, e, t), n;
      }
      function St(n, e, t, i) {
        const s = 512 & e ? 0 : -1,
          r = t + s;
        var A = n.length - 1;
        return r >= A && 256 & e
          ? ((n[A][t] = i), e)
          : r <= A
          ? ((n[r] = i), e)
          : (i !== void 0 && (t >= (A = (e >> 14) & 1023 || 536870912) ? i != null && ((n[A + s] = { [t]: i }), Ut(n, (e |= 256))) : (n[r] = i)), e);
      }
      function go(n, e) {
        let t = 0 | (n = n.u)[_e];
        const i = Gi(n, t, e),
          s = us(i);
        return s != null && s !== i && St(n, t, e, s), s;
      }
      function fp(n) {
        let e = 0 | (n = n.u)[_e];
        const t = Gi(n, e, 1),
          i = kl(t, !0);
        return i != null && i !== t && St(n, e, 1, i), i;
      }
      function Ss() {
        return Hg === void 0 ? 2 : 4;
      }
      function Is(n, e, t, i, s) {
        const r = n.u,
          A = 2 & (n = 0 | r[_e]) ? 1 : i;
        s = !!s;
        let o = 0 | (i = ql(r, n, e))[_e];
        if (!(4 & o)) {
          4 & o && ((i = hn(i)), (o = Bi(o, n)), (n = St(r, n, e, i)));
          let a = 0,
            c = 0;
          for (; a < i.length; a++) {
            const l = t(i[a]);
            l != null && (i[c++] = l);
          }
          c < a && (i.length = c), (o = Xl(o, n)), (t = -2049 & (20 | o)), (o = t &= -4097), Ut(i, o), 2 & o && Object.freeze(i);
        }
        return (
          A === 1 || (A === 4 && 32 & o)
            ? Si(o) || ((s = o), (o |= 2), o !== s && Ut(i, o), Object.freeze(i))
            : (A === 2 && Si(o) && ((i = hn(i)), (o = Bi(o, n)), (o = ss(o, n, s)), Ut(i, o), (n = St(r, n, e, i))),
              Si(o) || ((e = o), (o = ss(o, n, s)), o !== e && Ut(i, o))),
          i
        );
      }
      function ql(n, e, t) {
        return (n = Gi(n, e, t)), Array.isArray(n) ? n : Nl;
      }
      function Xl(n, e) {
        return n === 0 && (n = Bi(n, e)), 1 | n;
      }
      function Si(n) {
        return (!!(2 & n) && !!(4 & n)) || !!(1024 & n);
      }
      function dp(n) {
        n = hn(n);
        for (let e = 0; e < n.length; e++) {
          const t = (n[e] = hn(n[e]));
          Array.isArray(t[1]) && (t[1] = Or(t[1]));
        }
        return n;
      }
      function bc(n, e, t, i) {
        let s = 0 | (n = n.u)[_e];
        ls(s), St(n, s, e, (i === "0" ? Number(t) === 0 : t === i) ? void 0 : t);
      }
      function Fr(n, e, t, i) {
        ls(e);
        let s = ql(n, e, t);
        const r = s !== Nl;
        if (64 & e || !(8192 & e) || !r) {
          const A = r ? 0 | s[_e] : 0;
          let o = A;
          (!r || 2 & o || Si(o) || (4 & o && !(32 & o))) && ((s = hn(s)), (o = Bi(o, e)), (e = St(n, e, t, s))),
            (o = -13 & Xl(o, e)),
            (o = ss(i ? -17 & o : 16 | o, e, !0)),
            o !== A && Ut(s, o);
        }
        return s;
      }
      function za(n, e) {
        var t = nm;
        return Zl(Jl((n = n.u)), n, 0 | n[_e], t) === e ? e : -1;
      }
      function Jl(n) {
        if (Qo) return n[qr] ?? (n[qr] = new Map());
        if (qr in n) return n[qr];
        const e = new Map();
        return Object.defineProperty(n, qr, { value: e }), e;
      }
      function pp(n, e, t, i) {
        const s = Jl(n),
          r = Zl(s, n, e, t);
        return r !== i && (r && (e = St(n, e, r)), s.set(t, i)), e;
      }
      function Zl(n, e, t, i) {
        let s = n.get(i);
        if (s != null) return s;
        s = 0;
        for (let r = 0; r < i.length; r++) {
          const A = i[r];
          Gi(e, t, A) != null && (s !== 0 && (t = St(e, t, s)), (s = A));
        }
        return n.set(i, s), s;
      }
      function $l(n, e, t) {
        let i = 0 | n[_e];
        const s = Gi(n, i, t);
        let r;
        if (s != null && s.W === IA) return (e = ea(s)) !== s && St(n, i, t, e), e.u;
        if (Array.isArray(s)) {
          const A = 0 | s[_e];
          r = 2 & A ? is($o(s, A, !1), e, !0) : 64 & A ? s : is(r, e, !0);
        } else r = is(void 0, e, !0);
        return r !== s && St(n, i, t, r), r;
      }
      function mp(n, e, t) {
        let i = 0 | (n = n.u)[_e];
        const s = Gi(n, i, t);
        return (e = Kl(s, e, !1, i)) !== s && e != null && St(n, i, t, e), e;
      }
      function Je(n, e, t) {
        if ((e = mp(n, e, t)) == null) return e;
        let i = 0 | (n = n.u)[_e];
        if (!(2 & i)) {
          const s = ea(e);
          s !== e && St(n, i, t, (e = s));
        }
        return e;
      }
      function gp(n, e, t, i, s, r, A) {
        n = n.u;
        var o = !!(2 & e);
        const a = o ? 1 : s;
        (r = !!r), (A &&= !o);
        var c = 0 | (s = ql(n, e, i))[_e];
        if (!(o = !!(4 & c))) {
          var l = s,
            u = e;
          const h = !!(2 & (c = Xl(c, e)));
          h && (u |= 2);
          let d = !h,
            m = !0,
            g = 0,
            p = 0;
          for (; g < l.length; g++) {
            const f = Kl(l[g], t, !1, u);
            if (f instanceof t) {
              if (!h) {
                const E = !!(2 & (0 | f.u[_e]));
                (d &&= !E), (m &&= E);
              }
              l[p++] = f;
            }
          }
          p < g && (l.length = p), (c |= 4), (c = m ? 16 | c : -17 & c), Ut(l, (c = d ? 8 | c : -9 & c)), h && Object.freeze(l);
        }
        if (A && !(8 & c || (!s.length && (a === 1 || (a === 4 && 32 & c))))) {
          for (Si(c) && ((s = hn(s)), (c = Bi(c, e)), (e = St(n, e, i, s))), t = s, A = c, l = 0; l < t.length; l++) (c = t[l]) !== (u = ea(c)) && (t[l] = u);
          (A |= 8), Ut(t, (A = t.length ? -17 & A : 16 | A)), (c = A);
        }
        return (
          a === 1 || (a === 4 && 32 & c)
            ? Si(c) || ((e = c), (c |= !s.length || (16 & c && (!o || 32 & c)) ? 2 : 1024) !== e && Ut(s, c), Object.freeze(s))
            : (a === 2 && Si(c) && (Ut((s = hn(s)), (c = ss((c = Bi(c, e)), e, r))), (e = St(n, e, i, s))),
              Si(c) || ((i = c), (c = ss(c, e, r)) !== i && Ut(s, c))),
          s
        );
      }
      function Fi(n, e, t) {
        const i = 0 | n.u[_e];
        return gp(n, i, e, t, Ss(), !1, !(2 & i));
      }
      function De(n, e, t, i) {
        return i == null && (i = void 0), mt(n, t, i);
      }
      function lA(n, e, t, i) {
        i == null && (i = void 0);
        e: {
          let s = 0 | (n = n.u)[_e];
          if ((ls(s), i == null)) {
            const r = Jl(n);
            if (Zl(r, n, s, t) !== e) break e;
            r.set(t, 0);
          } else s = pp(n, s, t, e);
          St(n, s, e, i);
        }
      }
      function Bi(n, e) {
        return -1025 & (n = 32 | (2 & e ? 2 | n : -3 & n));
      }
      function ss(n, e, t) {
        return (32 & e && t) || (n &= -33), n;
      }
      function ta(n, e, t) {
        ls(0 | n.u[_e]), Is(n, e, Pr, 2, !0).push(ap(t));
      }
      function zo(n, e, t, i) {
        const s = 0 | n.u[_e];
        ls(s), (n = gp(n, s, t, e, 2, !0)), (i = i ?? new t()), n.push(i), (n[_e] = 2 & (0 | i.u[_e]) ? -9 & n[_e] : -17 & n[_e]);
      }
      function Nn(n, e) {
        return Lr(vr(n, e));
      }
      function Gn(n, e) {
        return Pr(vr(n, e));
      }
      function Bt(n, e) {
        return go(n, e) ?? 0;
      }
      function _A(n, e, t) {
        if (t != null && typeof t != "boolean")
          throw ((n = typeof t), Error(`Expected boolean but got ${n != "object" ? n : t ? (Array.isArray(t) ? "array" : n) : "null"}: ${t}`));
        mt(n, e, t);
      }
      function ui(n, e, t) {
        if (t != null) {
          if (typeof t != "number" || !Jo(t)) throw Ec("int32");
          t |= 0;
        }
        mt(n, e, t);
      }
      function Pe(n, e, t) {
        if (t != null && typeof t != "number") throw Error(`Value of float/double field must be a number, found ${typeof t}: ${t}`);
        mt(n, e, t);
      }
      function Ro(n, e, t) {
        {
          const A = n.u;
          let o = 0 | A[_e];
          if ((ls(o), t == null)) St(A, o, e);
          else {
            var i = (n = 0 | t[_e]),
              s = Si(n),
              r = s || Object.isFrozen(t);
            for (s || (n = 0), r || ((t = hn(t)), (i = 0), (n = ss((n = Bi(n, o)), o, !0)), (r = !1)), n |= 21, s = 0; s < t.length; s++) {
              const a = t[s],
                c = ap(a);
              Object.is(a, c) || (r && ((t = hn(t)), (i = 0), (n = ss((n = Bi(n, o)), o, !0)), (r = !1)), (t[s] = c));
            }
            n !== i && (r && ((t = hn(t)), (n = ss((n = Bi(n, o)), o, !0))), Ut(t, n)), St(A, o, e, t);
          }
        }
      }
      function Pp(n, e) {
        return Error(`Invalid wire type: ${n} (at position ${e})`);
      }
      function eu() {
        return Error("Failed to read varint, encoding is invalid.");
      }
      function vp(n, e) {
        return Error(`Tried to read past the end of the data ${e} > ${n}`);
      }
      function tu(n) {
        if (typeof n == "string") return { buffer: qd(n), O: !1 };
        if (Array.isArray(n)) return { buffer: new Uint8Array(n), O: !1 };
        if (n.constructor === Uint8Array) return { buffer: n, O: !1 };
        if (n.constructor === ArrayBuffer) return { buffer: new Uint8Array(n), O: !1 };
        if (n.constructor === Ri) return { buffer: Ul(n) || new Uint8Array(0), O: !0 };
        if (n instanceof Uint8Array) return { buffer: new Uint8Array(n.buffer, n.byteOffset, n.byteLength), O: !1 };
        throw Error(
          "Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers"
        );
      }
      function nu(n, e) {
        let t,
          i = 0,
          s = 0,
          r = 0;
        const A = n.h;
        let o = n.g;
        do (t = A[o++]), (i |= (127 & t) << r), (r += 7);
        while (r < 32 && 128 & t);
        for (r > 32 && (s |= (127 & t) >> 4), r = 3; r < 32 && 128 & t; r += 7) (t = A[o++]), (s |= (127 & t) << r);
        if ((Rs(n, o), t < 128)) return e(i >>> 0, s >>> 0);
        throw eu();
      }
      function iu(n) {
        let e = 0,
          t = n.g;
        const i = t + 10,
          s = n.h;
        for (; t < i; ) {
          const r = s[t++];
          if (((e |= r), (128 & r) == 0)) return Rs(n, t), !!(127 & e);
        }
        throw eu();
      }
      function os(n) {
        const e = n.h;
        let t = n.g,
          i = e[t++],
          s = 127 & i;
        if (
          128 & i &&
          ((i = e[t++]),
          (s |= (127 & i) << 7),
          128 & i &&
            ((i = e[t++]),
            (s |= (127 & i) << 14),
            128 & i &&
              ((i = e[t++]),
              (s |= (127 & i) << 21),
              128 & i && ((i = e[t++]), (s |= i << 28), 128 & i && 128 & e[t++] && 128 & e[t++] && 128 & e[t++] && 128 & e[t++] && 128 & e[t++]))))
        )
          throw eu();
        return Rs(n, t), s;
      }
      function Ni(n) {
        return os(n) >>> 0;
      }
      function zc(n) {
        var e = n.h;
        const t = n.g,
          i = e[t],
          s = e[t + 1],
          r = e[t + 2];
        return (e = e[t + 3]), Rs(n, n.g + 4), ((i << 0) | (s << 8) | (r << 16) | (e << 24)) >>> 0;
      }
      function Rc(n) {
        var e = zc(n);
        n = 2 * (e >> 31) + 1;
        const t = (e >>> 23) & 255;
        return (e &= 8388607), t == 255 ? (e ? NaN : n * (1 / 0)) : t == 0 ? 1401298464324817e-60 * n * e : n * Math.pow(2, t - 150) * (e + 8388608);
      }
      function hP(n) {
        return os(n);
      }
      function Ra(n, e, { aa: t = !1 } = {}) {
        (n.aa = t), e && ((e = tu(e)), (n.h = e.buffer), (n.m = e.O), (n.j = 0), (n.l = n.h.length), (n.g = n.j));
      }
      function Rs(n, e) {
        if (((n.g = e), e > n.l)) throw vp(n.l, e);
      }
      function wp(n, e) {
        if (e < 0) throw Error(`Tried to read a negative byte length: ${e}`);
        const t = n.g,
          i = t + e;
        if (i > n.l) throw vp(e, n.l - t);
        return (n.g = i), t;
      }
      function _p(n, e) {
        if (e == 0) return Os();
        var t = wp(n, e);
        return (
          n.aa && n.m
            ? (t = n.h.subarray(t, t + e))
            : ((n = n.h), (t = t === (e = t + e) ? new Uint8Array(0) : Xg ? n.slice(t, e) : new Uint8Array(n.subarray(t, e)))),
          t.length == 0 ? Os() : new Ri(t, pr)
        );
      }
      li.prototype.toJSON = void 0;
      var Ch = [];
      function xp(n) {
        var e = n.g;
        if (e.g == e.l) return !1;
        n.l = n.g.g;
        var t = Ni(n.g);
        if (((e = t >>> 3), !((t &= 7) >= 0 && t <= 5))) throw Pp(t, n.l);
        if (e < 1) throw Error(`Invalid field number: ${e} (at position ${n.l})`);
        return (n.m = e), (n.h = t), !0;
      }
      function Po(n) {
        switch (n.h) {
          case 0:
            n.h != 0 ? Po(n) : iu(n.g);
            break;
          case 1:
            Rs((n = n.g), n.g + 8);
            break;
          case 2:
            if (n.h != 2) Po(n);
            else {
              var e = Ni(n.g);
              Rs((n = n.g), n.g + e);
            }
            break;
          case 5:
            Rs((n = n.g), n.g + 4);
            break;
          case 3:
            for (e = n.m; ; ) {
              if (!xp(n)) throw Error("Unmatched start-group tag: stream EOF");
              if (n.h == 4) {
                if (n.m != e) throw Error("Unmatched end-group tag");
                break;
              }
              Po(n);
            }
            break;
          default:
            throw Pp(n.h, n.l);
        }
      }
      function bA(n, e, t) {
        const i = n.g.l,
          s = Ni(n.g),
          r = n.g.g + s;
        let A = r - i;
        if ((A <= 0 && ((n.g.l = r), t(e, n, void 0, void 0, void 0), (A = r - n.g.g)), A))
          throw Error(
            `Message parsing ended unexpectedly. Expected to read ${s} bytes, instead read ${
              s - A
            } bytes, either the data ended unexpectedly or the message misreported its own length`
          );
        return (n.g.g = r), (n.g.l = i), e;
      }
      function su(n) {
        var e = Ni(n.g),
          t = wp((n = n.g), e);
        if (((n = n.h), bg)) {
          var i,
            s = n;
          (i = Da) || (i = Da = new TextDecoder("utf-8", { fatal: !0 })), (e = t + e), (s = t === 0 && e === s.length ? s : s.subarray(t, e));
          try {
            var r = i.decode(s);
          } catch (o) {
            if (FA === void 0) {
              try {
                i.decode(new Uint8Array([128]));
              } catch {}
              try {
                i.decode(new Uint8Array([97])), (FA = !0);
              } catch {
                FA = !1;
              }
            }
            throw (!FA && (Da = void 0), o);
          }
        } else {
          (e = (r = t) + e), (t = []);
          let o,
            a = null;
          for (; r < e; ) {
            var A = n[r++];
            A < 128
              ? t.push(A)
              : A < 224
              ? r >= e
                ? ms()
                : ((o = n[r++]), A < 194 || (192 & o) != 128 ? (r--, ms()) : t.push(((31 & A) << 6) | (63 & o)))
              : A < 240
              ? r >= e - 1
                ? ms()
                : ((o = n[r++]),
                  (192 & o) != 128 || (A === 224 && o < 160) || (A === 237 && o >= 160) || (192 & (i = n[r++])) != 128
                    ? (r--, ms())
                    : t.push(((15 & A) << 12) | ((63 & o) << 6) | (63 & i)))
              : A <= 244
              ? r >= e - 2
                ? ms()
                : ((o = n[r++]),
                  (192 & o) != 128 || (o - 144 + (A << 28)) >> 30 != 0 || (192 & (i = n[r++])) != 128 || (192 & (s = n[r++])) != 128
                    ? (r--, ms())
                    : ((A = ((7 & A) << 18) | ((63 & o) << 12) | ((63 & i) << 6) | (63 & s)),
                      (A -= 65536),
                      t.push(55296 + ((A >> 10) & 1023), 56320 + (1023 & A))))
              : ms(),
              t.length >= 8192 && ((a = lh(a, t)), (t.length = 0));
          }
          r = lh(a, t);
        }
        return r;
      }
      function yp(n) {
        const e = Ni(n.g);
        return _p(n.g, e);
      }
      function na(n, e, t) {
        var i = Ni(n.g);
        for (i = n.g.g + i; n.g.g < i; ) t.push(e(n.g));
      }
      var NA = [];
      function Zn(n, e, t) {
        e.g ? e.m(n, e.g, e.h, t) : e.m(n, e.h, t);
      }
      var me = class {
        constructor(n, e) {
          this.u = hp(n, e);
        }
        toJSON() {
          try {
            var n = up(this);
          } finally {
            cp = void 0;
          }
          return n;
        }
        l() {
          var n = YP;
          return n.g ? n.l(this, n.g, n.h) : n.l(this, n.h, n.defaultValue);
        }
        clone() {
          const n = this.u;
          return new this.constructor($o(n, 0 | n[_e], !1));
        }
        O() {
          return !!(2 & (0 | this.u[_e]));
        }
      };
      function Sh(n) {
        return n ? (/^\d+$/.test(n) ? (Xo(n), new Bc(dt, zt)) : null) : (fP ||= new Bc(0, 0));
      }
      (me.prototype.W = IA),
        (me.prototype.toString = function () {
          return this.u.toString();
        });
      var Bc = class {
        constructor(n, e) {
          (this.h = n >>> 0), (this.g = e >>> 0);
        }
      };
      let fP;
      function Ih(n) {
        return n ? (/^-?\d+$/.test(n) ? (Xo(n), new Oc(dt, zt)) : null) : (dP ||= new Oc(0, 0));
      }
      var Oc = class {
        constructor(n, e) {
          (this.h = n >>> 0), (this.g = e >>> 0);
        }
      };
      let dP;
      function or(n, e, t) {
        for (; t > 0 || e > 127; ) n.g.push((127 & e) | 128), (e = ((e >>> 7) | (t << 25)) >>> 0), (t >>>= 7);
        n.g.push(e);
      }
      function Nr(n, e) {
        for (; e > 127; ) n.g.push((127 & e) | 128), (e >>>= 7);
        n.g.push(e);
      }
      function ia(n, e) {
        if (e >= 0) Nr(n, e);
        else {
          for (let t = 0; t < 9; t++) n.g.push((127 & e) | 128), (e >>= 7);
          n.g.push(1);
        }
      }
      function xA(n, e) {
        n.g.push((e >>> 0) & 255), n.g.push((e >>> 8) & 255), n.g.push((e >>> 16) & 255), n.g.push((e >>> 24) & 255);
      }
      function wr(n, e) {
        e.length !== 0 && (n.l.push(e), (n.h += e.length));
      }
      function Cn(n, e, t) {
        Nr(n.g, 8 * e + t);
      }
      function ru(n, e) {
        return Cn(n, e, 2), (e = n.g.end()), wr(n, e), e.push(n.h), e;
      }
      function Au(n, e) {
        var t = e.pop();
        for (t = n.h + n.g.length() - t; t > 127; ) e.push((127 & t) | 128), (t >>>= 7), n.h++;
        e.push(t), n.h++;
      }
      function sa(n, e, t) {
        Cn(n, e, 2), Nr(n.g, t.length), wr(n, n.g.end()), wr(n, t);
      }
      function Bo(n, e, t, i) {
        t != null && ((e = ru(n, e)), i(t, n), Au(n, e));
      }
      function $n() {
        const n = class {
          constructor() {
            throw Error();
          }
        };
        return Object.setPrototypeOf(n, n.prototype), n;
      }
      var ou = $n(),
        Tp = $n(),
        au = $n(),
        cu = $n(),
        Ep = $n(),
        Dp = $n(),
        lu = $n(),
        Mp = $n(),
        Cp = $n(),
        kr = class {
          constructor(n, e, t) {
            (this.g = n), (this.h = e), (n = ou), (this.l = (!!n && t === n) || !1);
          }
        };
      function ra(n, e) {
        return new kr(n, e, ou);
      }
      function Sp(n, e, t, i, s) {
        Bo(n, t, Rp(e, i), s);
      }
      const pP = ra(function (n, e, t, i, s) {
          return n.h === 2 && (bA(n, $l(e, i, t), s), !0);
        }, Sp),
        mP = ra(function (n, e, t, i, s) {
          return n.h === 2 && (bA(n, $l(e, i, t), s), !0);
        }, Sp);
      var Aa = Symbol(),
        uu = Symbol(),
        bh = Symbol(),
        zh = Symbol();
      let Ip, bp;
      function Ns(n, e, t, i) {
        var s = i[n];
        if (s) return s;
        ((s = {}).Ma = i),
          (s.T = (function (u) {
            switch (typeof u) {
              case "boolean":
                return (lp ||= [0, void 0, !0]);
              case "number":
                return u > 0 ? void 0 : u === 0 ? (lP ||= [0, void 0]) : [-u, void 0];
              case "string":
                return [0, u];
              case "object":
                return u;
            }
          })(i[0]));
        var r = i[1];
        let A = 1;
        r && r.constructor === Object && ((s.ga = r), typeof (r = i[++A]) == "function" && ((s.la = !0), (Ip ??= r), (bp ??= i[A + 1]), (r = i[(A += 2)])));
        const o = {};
        for (; r && Array.isArray(r) && r.length && typeof r[0] == "number" && r[0] > 0; ) {
          for (var a = 0; a < r.length; a++) o[r[a]] = r;
          r = i[++A];
        }
        for (a = 1; r !== void 0; ) {
          let u;
          typeof r == "number" && ((a += r), (r = i[++A]));
          var c = void 0;
          if ((r instanceof kr ? (u = r) : ((u = pP), A--), u?.l)) {
            (r = i[++A]), (c = i);
            var l = A;
            typeof r == "function" && ((r = r()), (c[l] = r)), (c = r);
          }
          for (l = a + 1, typeof (r = i[++A]) == "number" && r < 0 && ((l -= r), (r = i[++A])); a < l; a++) {
            const h = o[a];
            c ? t(s, a, u, c, h) : e(s, a, u, h);
          }
        }
        return (i[n] = s);
      }
      function zp(n) {
        return Array.isArray(n) ? (n[0] instanceof kr ? n : [mP, n]) : [n, void 0];
      }
      function Rp(n, e) {
        return n instanceof me ? n.u : Array.isArray(n) ? is(n, e, !1) : void 0;
      }
      function hu(n, e, t, i) {
        const s = t.g;
        n[e] = i ? (r, A, o) => s(r, A, o, i) : s;
      }
      function fu(n, e, t, i, s) {
        const r = t.g;
        let A, o;
        n[e] = (a, c, l) => r(a, c, l, (o ||= Ns(uu, hu, fu, i).T), (A ||= du(i)), s);
      }
      function du(n) {
        let e = n[bh];
        if (e != null) return e;
        const t = Ns(uu, hu, fu, n);
        return (
          (e = t.la
            ? (i, s) => Ip(i, s, t)
            : (i, s) => {
                const r = 0 | i[_e];
                for (; xp(s) && s.h != 4; ) {
                  var A = s.m,
                    o = t[A];
                  if (o == null) {
                    var a = t.ga;
                    a && (a = a[A]) && (a = gP(a)) != null && (o = t[A] = a);
                  }
                  (o != null && o(s, i, A)) ||
                    ((A = (o = s).l),
                    Po(o),
                    o.fa ? (o = void 0) : ((a = o.g.g - A), (o.g.g = A), (o = _p(o.g, a))),
                    (A = i),
                    o && ((a = A[mr]) ? a.push(o) : (A[mr] = [o])));
                }
                return 8192 & r && Or(i), !0;
              }),
          (n[bh] = e)
        );
      }
      function gP(n) {
        const e = (n = zp(n))[0].g;
        if ((n = n[1])) {
          const t = du(n),
            i = Ns(uu, hu, fu, n).T;
          return (s, r, A) => e(s, r, A, i, t);
        }
        return e;
      }
      function oa(n, e, t) {
        n[e] = t.h;
      }
      function aa(n, e, t, i) {
        let s, r;
        const A = t.h;
        n[e] = (o, a, c) => A(o, a, c, (r ||= Ns(Aa, oa, aa, i).T), (s ||= Bp(i)));
      }
      function Bp(n) {
        let e = n[zh];
        if (!e) {
          const t = Ns(Aa, oa, aa, n);
          (e = (i, s) => Op(i, s, t)), (n[zh] = e);
        }
        return e;
      }
      function Op(n, e, t) {
        (function (i, s, r) {
          const A = 512 & s ? 0 : -1,
            o = i.length,
            a = o + ((s = 64 & s ? 256 & s : !!o && Ko(i[o - 1])) ? -1 : 0);
          for (let c = 0; c < a; c++) r(c - A, i[c]);
          if (s) {
            i = i[o - 1];
            for (const c in i) !isNaN(c) && r(+c, i[c]);
          }
        })(n, 0 | n[_e] | (t.T[1] ? 512 : 0), (i, s) => {
          if (s != null) {
            var r = (function (A, o) {
              var a = A[o];
              if (a) return a;
              if ((a = A.ga) && (a = a[o])) {
                var c = (a = zp(a))[0].h;
                if ((a = a[1])) {
                  const l = Bp(a),
                    u = Ns(Aa, oa, aa, a).T;
                  a = A.la ? bp(u, l) : (h, d, m) => c(h, d, m, u, l);
                } else a = c;
                return (A[o] = a);
              }
            })(t, i);
            r && r(e, s, i);
          }
        }),
          (n = Gl(n)) &&
            (function (i, s) {
              wr(i, i.g.end());
              for (let r = 0; r < s.length; r++) wr(i, Ul(s[r]) || new Uint8Array(0));
            })(e, n);
      }
      function Gr(n, e) {
        if (Array.isArray(e)) {
          var t = 0 | e[_e];
          if (4 & t) return e;
          for (var i = 0, s = 0; i < e.length; i++) {
            const r = n(e[i]);
            r != null && (e[s++] = r);
          }
          return s < i && (e.length = s), Ut(e, -6145 & (5 | t)), 2 & t && Object.freeze(e), e;
        }
      }
      function an(n, e, t) {
        return new kr(n, e, t);
      }
      function jr(n, e, t) {
        return new kr(n, e, t);
      }
      function cn(n, e, t) {
        St(n, 0 | n[_e], e, t);
      }
      var PP = ra(
        function (n, e, t, i, s) {
          return (
            n.h === 2 &&
            ((n = bA(n, is([void 0, void 0], i, !0), s)),
            ls((i = 0 | e[_e])),
            (s = Gi(e, i, t)) instanceof li
              ? (2 & s.M) != 0
                ? ((s = s.da()).push(n), St(e, i, t, s))
                : s.Ja(n)
              : Array.isArray(s)
              ? (2 & (0 | s[_e]) && St(e, i, t, (s = dp(s))), s.push(n))
              : St(e, i, t, [n]),
            !0)
          );
        },
        function (n, e, t, i, s) {
          if (e instanceof li)
            e.forEach((r, A) => {
              Bo(n, t, is([A, r], i, !1), s);
            });
          else if (Array.isArray(e))
            for (let r = 0; r < e.length; r++) {
              const A = e[r];
              Array.isArray(A) && Bo(n, t, is(A, i, !1), s);
            }
        }
      );
      function Lp(n, e, t) {
        if (
          ((e = (function (i) {
            if (i == null) return i;
            const s = typeof i;
            if (s === "bigint") return String(vA(64, i));
            if (wA(i)) {
              if (s === "string") return op(i);
              if (s === "number") return Wl(i);
            }
          })(e)),
          e != null && (typeof e == "string" && Ih(e), e != null))
        )
          switch ((Cn(n, t, 0), typeof e)) {
            case "number":
              (n = n.g), Ls(e), or(n, dt, zt);
              break;
            case "bigint":
              (t = BigInt.asUintN(64, e)), (t = new Oc(Number(t & BigInt(4294967295)), Number(t >> BigInt(32)))), or(n.g, t.h, t.g);
              break;
            default:
              (t = Ih(e)), or(n.g, t.h, t.g);
          }
      }
      function Up(n, e, t) {
        (e = Lr(e)) != null && e != null && (Cn(n, t, 0), ia(n.g, e));
      }
      function Fp(n, e, t) {
        (e = ip(e)) != null && (Cn(n, t, 0), n.g.g.push(e ? 1 : 0));
      }
      function Np(n, e, t) {
        (e = Pr(e)) != null && sa(n, t, Qd(e));
      }
      function kp(n, e, t, i, s) {
        Bo(n, t, Rp(e, i), s);
      }
      function Gp(n, e, t) {
        e == null || typeof e == "string" || e instanceof Ri || (Bs(e) ? Bs(e) && Fl(Zd) : (e = void 0)), e != null && sa(n, t, tu(e).buffer);
      }
      function jp(n, e, t) {
        return (n.h === 5 || n.h === 2) && ((e = Fr(e, 0 | e[_e], t, !1)), n.h == 2 ? na(n, Rc, e) : e.push(Rc(n.g)), !0);
      }
      var Mi = an(
          function (n, e, t) {
            if (n.h !== 1) return !1;
            var i = n.g;
            n = zc(i);
            const s = zc(i);
            i = 2 * (s >> 31) + 1;
            const r = (s >>> 20) & 2047;
            return (
              (n = 4294967296 * (1048575 & s) + n),
              cn(e, t, r == 2047 ? (n ? NaN : i * (1 / 0)) : r == 0 ? 5e-324 * i * n : i * Math.pow(2, r - 1075) * (n + 4503599627370496)),
              !0
            );
          },
          function (n, e, t) {
            (e = us(e)) != null &&
              (Cn(n, t, 1),
              (n = n.g),
              (t = tp ||= new DataView(new ArrayBuffer(8))).setFloat64(0, +e, !0),
              (dt = t.getUint32(0, !0)),
              (zt = t.getUint32(4, !0)),
              xA(n, dt),
              xA(n, zt));
          },
          $n()
        ),
        Ft = an(
          function (n, e, t) {
            return n.h === 5 && (cn(e, t, Rc(n.g)), !0);
          },
          function (n, e, t) {
            (e = us(e)) != null && (Cn(n, t, 5), (n = n.g), jl(e), xA(n, dt));
          },
          lu
        ),
        vP = jr(
          jp,
          function (n, e, t) {
            if ((e = Gr(us, e)) != null)
              for (let A = 0; A < e.length; A++) {
                var i = n,
                  s = t,
                  r = e[A];
                r != null && (Cn(i, s, 5), (i = i.g), jl(r), xA(i, dt));
              }
          },
          lu
        ),
        pu = jr(
          jp,
          function (n, e, t) {
            if ((e = Gr(us, e)) != null && e.length) {
              Cn(n, t, 2), Nr(n.g, 4 * e.length);
              for (let i = 0; i < e.length; i++) (t = n.g), jl(e[i]), xA(t, dt);
            }
          },
          lu
        ),
        as = an(
          function (n, e, t) {
            return n.h === 0 && (cn(e, t, nu(n.g, Ql)), !0);
          },
          Lp,
          Dp
        ),
        Ba = an(
          function (n, e, t) {
            return n.h === 0 && (cn(e, t, (n = nu(n.g, Ql)) === 0 ? void 0 : n), !0);
          },
          Lp,
          Dp
        ),
        wP = an(
          function (n, e, t) {
            return n.h === 0 && (cn(e, t, nu(n.g, Hl)), !0);
          },
          function (n, e, t) {
            if ((e = eP(e)) != null && (typeof e == "string" && Sh(e), e != null))
              switch ((Cn(n, t, 0), typeof e)) {
                case "number":
                  (n = n.g), Ls(e), or(n, dt, zt);
                  break;
                case "bigint":
                  (t = BigInt.asUintN(64, e)), (t = new Bc(Number(t & BigInt(4294967295)), Number(t >> BigInt(32)))), or(n.g, t.h, t.g);
                  break;
                default:
                  (t = Sh(e)), or(n.g, t.h, t.g);
              }
          },
          $n()
        ),
        Rt = an(
          function (n, e, t) {
            return n.h === 0 && (cn(e, t, os(n.g)), !0);
          },
          Up,
          cu
        ),
        ca = jr(
          function (n, e, t) {
            return (n.h === 0 || n.h === 2) && ((e = Fr(e, 0 | e[_e], t, !1)), n.h == 2 ? na(n, os, e) : e.push(os(n.g)), !0);
          },
          function (n, e, t) {
            if ((e = Gr(Lr, e)) != null && e.length) {
              t = ru(n, t);
              for (let i = 0; i < e.length; i++) ia(n.g, e[i]);
              Au(n, t);
            }
          },
          cu
        ),
        rr = an(
          function (n, e, t) {
            return n.h === 0 && (cn(e, t, (n = os(n.g)) === 0 ? void 0 : n), !0);
          },
          Up,
          cu
        ),
        yt = an(
          function (n, e, t) {
            return n.h === 0 && (cn(e, t, iu(n.g)), !0);
          },
          Fp,
          Tp
        ),
        ar = an(
          function (n, e, t) {
            return n.h === 0 && (cn(e, t, (n = iu(n.g)) === !1 ? void 0 : n), !0);
          },
          Fp,
          Tp
        ),
        Jt = jr(
          function (n, e, t) {
            return n.h === 2 && ((n = su(n)), Fr(e, 0 | e[_e], t, !1).push(n), !0);
          },
          function (n, e, t) {
            if ((e = Gr(Pr, e)) != null)
              for (let A = 0; A < e.length; A++) {
                var i = n,
                  s = t,
                  r = e[A];
                r != null && sa(i, s, Qd(r));
              }
          },
          au
        ),
        Zi = an(
          function (n, e, t) {
            return n.h === 2 && (cn(e, t, (n = su(n)) === "" ? void 0 : n), !0);
          },
          Np,
          au
        ),
        At = an(
          function (n, e, t) {
            return n.h === 2 && (cn(e, t, su(n)), !0);
          },
          Np,
          au
        ),
        Gt = (function (n, e, t = ou) {
          return new kr(n, e, t);
        })(
          function (n, e, t, i, s) {
            return n.h === 2 && ((i = is(void 0, i, !0)), Fr(e, 0 | e[_e], t, !0).push(i), bA(n, i, s), !0);
          },
          function (n, e, t, i, s) {
            if (Array.isArray(e)) for (let r = 0; r < e.length; r++) kp(n, e[r], t, i, s);
          }
        ),
        rt = ra(function (n, e, t, i, s, r) {
          return n.h === 2 && (pp(e, 0 | e[_e], r, t), bA(n, (e = $l(e, i, t)), s), !0);
        }, kp),
        Hp = an(
          function (n, e, t) {
            return n.h === 2 && (cn(e, t, yp(n)), !0);
          },
          Gp,
          Mp
        ),
        _P = jr(
          function (n, e, t) {
            return (n.h === 0 || n.h === 2) && ((e = Fr(e, 0 | e[_e], t, !1)), n.h == 2 ? na(n, Ni, e) : e.push(Ni(n.g)), !0);
          },
          function (n, e, t) {
            if ((e = Gr(sp, e)) != null)
              for (let A = 0; A < e.length; A++) {
                var i = n,
                  s = t,
                  r = e[A];
                r != null && (Cn(i, s, 0), Nr(i.g, r));
              }
          },
          Ep
        ),
        xP = an(
          function (n, e, t) {
            return n.h === 0 && (cn(e, t, (n = Ni(n.g)) === 0 ? void 0 : n), !0);
          },
          function (n, e, t) {
            (e = sp(e)) != null && e != null && (Cn(n, t, 0), Nr(n.g, e));
          },
          Ep
        ),
        Dn = an(
          function (n, e, t) {
            return n.h === 0 && (cn(e, t, os(n.g)), !0);
          },
          function (n, e, t) {
            (e = Lr(e)) != null && ((e = parseInt(e, 10)), Cn(n, t, 0), ia(n.g, e));
          },
          Cp
        );
      class yP {
        constructor(e, t) {
          (this.h = e), (this.g = t), (this.l = Je), (this.m = De), (this.defaultValue = void 0);
        }
        register() {
          Ho(this);
        }
      }
      function ei(n, e) {
        return new yP(n, e);
      }
      function hs(n, e) {
        return (t, i) => {
          if (NA.length) {
            const r = NA.pop();
            r.o(i), Ra(r.g, t, i), (t = r);
          } else
            t = new (class {
              constructor(r, A) {
                if (Ch.length) {
                  const o = Ch.pop();
                  Ra(o, r, A), (r = o);
                } else
                  r = new (class {
                    constructor(o, a) {
                      (this.h = null), (this.m = !1), (this.g = this.l = this.j = 0), Ra(this, o, a);
                    }
                    clear() {
                      (this.h = null), (this.m = !1), (this.g = this.l = this.j = 0), (this.aa = !1);
                    }
                  })(r, A);
                (this.g = r), (this.l = this.g.g), (this.h = this.m = -1), this.o(A);
              }
              o({ fa: r = !1 } = {}) {
                this.fa = r;
              }
            })(t, i);
          try {
            const r = new n(),
              A = r.u;
            du(e)(A, t);
            var s = r;
          } finally {
            t.g.clear(), (t.m = -1), (t.h = -1), NA.length < 100 && NA.push(t);
          }
          return s;
        };
      }
      function la(n) {
        return function () {
          const e = new (class {
            constructor() {
              (this.l = []),
                (this.h = 0),
                (this.g = new (class {
                  constructor() {
                    this.g = [];
                  }
                  length() {
                    return this.g.length;
                  }
                  end() {
                    const A = this.g;
                    return (this.g = []), A;
                  }
                })());
            }
          })();
          Op(this.u, e, Ns(Aa, oa, aa, n)), wr(e, e.g.end());
          const t = new Uint8Array(e.h),
            i = e.l,
            s = i.length;
          let r = 0;
          for (let A = 0; A < s; A++) {
            const o = i[A];
            t.set(o, r), (r += o.length);
          }
          return (e.l = [t]), t;
        };
      }
      var Rh = class extends me {
          constructor(n) {
            super(n);
          }
        },
        Bh = [
          0,
          Zi,
          an(
            function (n, e, t) {
              return n.h === 2 && (cn(e, t, (n = yp(n)) === Os() ? void 0 : n), !0);
            },
            function (n, e, t) {
              if (e != null) {
                if (e instanceof me) {
                  const i = e.Oa;
                  return void (i && ((e = i(e)), e != null && sa(n, t, tu(e).buffer)));
                }
                if (Array.isArray(e)) return;
              }
              Gp(n, e, t);
            },
            Mp
          ),
        ];
      let Oa,
        Oh = globalThis.trustedTypes;
      function Lh(n) {
        Oa === void 0 &&
          (Oa = (function () {
            let t = null;
            if (!Oh) return t;
            try {
              const i = (s) => s;
              t = Oh.createPolicy("goog#html", { createHTML: i, createScript: i, createScriptURL: i });
            } catch {}
            return t;
          })());
        var e = Oa;
        return new (class {
          constructor(t) {
            this.g = t;
          }
          toString() {
            return this.g + "";
          }
        })(e ? e.createScriptURL(n) : n);
      }
      function TP(n, ...e) {
        if (e.length === 0) return Lh(n[0]);
        let t = n[0];
        for (let i = 0; i < e.length; i++) t += encodeURIComponent(e[i]) + n[i + 1];
        return Lh(t);
      }
      var Qp = [0, Rt, Dn, yt, -1, ca, Dn, -1],
        EP = class extends me {
          constructor(n) {
            super(n);
          }
        },
        Vp = [
          0,
          yt,
          At,
          yt,
          Dn,
          -1,
          jr(
            function (n, e, t) {
              return (n.h === 0 || n.h === 2) && ((e = Fr(e, 0 | e[_e], t, !1)), n.h == 2 ? na(n, hP, e) : e.push(os(n.g)), !0);
            },
            function (n, e, t) {
              if ((e = Gr(Lr, e)) != null && e.length) {
                t = ru(n, t);
                for (let i = 0; i < e.length; i++) ia(n.g, e[i]);
                Au(n, t);
              }
            },
            Cp
          ),
          At,
          -1,
          [0, yt, -1],
          Dn,
          yt,
          -1,
        ],
        Wp = [0, At, -2],
        Uh = class extends me {
          constructor(n) {
            super(n);
          }
        },
        Kp = [0],
        Yp = [0, Rt, yt, 1, yt, -3],
        Mn = class extends me {
          constructor(n) {
            super(n, 2);
          }
        },
        Nt = {};
      Nt[336783863] = [
        0,
        At,
        yt,
        -1,
        Rt,
        [0, [1, 2, 3, 4, 5, 6, 7, 8, 9], rt, Kp, rt, Vp, rt, Wp, rt, Yp, rt, Qp, rt, [0, At, -2], rt, [0, At, Dn], rt, [0, Dn, At, -1], rt, [0, Dn, -1]],
        [0, At],
        yt,
        [0, [1, 3], [2, 4], rt, [0, ca], -1, rt, [0, Jt], -1, Gt, [0, At, -1]],
        At,
      ];
      var Fh = [0, Ba, -1, ar, -3, Ba, ca, Zi, rr, Ba, -1, ar, rr, ar, -2, Zi];
      function Sn(n, e) {
        bc(n, 2, Ur(e), "");
      }
      function gt(n, e) {
        ta(n, 3, e);
      }
      function Ye(n, e) {
        ta(n, 4, e);
      }
      var An = class extends me {
          constructor(n) {
            super(n, 500);
          }
          o(n) {
            return De(this, 0, 7, n);
          }
        },
        uA = [-1, {}],
        Nh = [0, At, 1, uA],
        kh = [0, At, Jt, uA];
      function In(n, e) {
        zo(n, 1, An, e);
      }
      function wt(n, e) {
        ta(n, 10, e);
      }
      function et(n, e) {
        ta(n, 15, e);
      }
      var pn = class extends me {
          constructor(n) {
            super(n, 500);
          }
          o(n) {
            return De(this, 0, 1001, n);
          }
        },
        qp = [
          -500,
          Gt,
          [-500, Zi, -1, Jt, -3, [-2, Nt, yt], Gt, Bh, rr, -1, Nh, kh, Gt, [0, Zi, ar], Zi, Fh, rr, Jt, 987, Jt],
          4,
          Gt,
          [-500, At, -1, [-1, {}], 998, At],
          Gt,
          [-500, At, Jt, -1, [-2, {}, yt], 997, Jt, -1],
          rr,
          Gt,
          [-500, At, Jt, uA, 998, Jt],
          Jt,
          rr,
          Nh,
          kh,
          Gt,
          [0, Zi, -1, uA],
          Jt,
          -2,
          Fh,
          Zi,
          -1,
          ar,
          [0, ar, xP],
          978,
          uA,
          Gt,
          Bh,
        ];
      pn.prototype.g = la(qp);
      var DP = hs(pn, qp),
        MP = class extends me {
          constructor(n) {
            super(n);
          }
        },
        Xp = class extends me {
          constructor(n) {
            super(n);
          }
          g() {
            return Fi(this, MP, 1);
          }
        },
        Jp = [0, Gt, [0, Rt, Ft, At, -1]],
        ua = hs(Xp, Jp),
        CP = class extends me {
          constructor(n) {
            super(n);
          }
        },
        SP = class extends me {
          constructor(n) {
            super(n);
          }
        },
        La = class extends me {
          constructor(n) {
            super(n);
          }
          h() {
            return Je(this, CP, 2);
          }
          g() {
            return Fi(this, SP, 5);
          }
        },
        Zp = hs(
          class extends me {
            constructor(n) {
              super(n);
            }
          },
          [0, Jt, ca, pu, [0, Dn, [0, Rt, -3], [0, Ft, -3], [0, Rt, -1, [0, Gt, [0, Rt, -2]]], Gt, [0, Ft, -1, At, Ft]], At, -1, as, Gt, [0, Rt, Ft], Jt, as]
        ),
        $p = class extends me {
          constructor(n) {
            super(n);
          }
        },
        cr = hs(
          class extends me {
            constructor(n) {
              super(n);
            }
          },
          [0, Gt, [0, Ft, -4]]
        ),
        em = class extends me {
          constructor(n) {
            super(n);
          }
        },
        zA = hs(
          class extends me {
            constructor(n) {
              super(n);
            }
          },
          [0, Gt, [0, Ft, -4]]
        ),
        IP = class extends me {
          constructor(n) {
            super(n);
          }
        },
        bP = [0, Rt, -1, pu, Dn],
        tm = class extends me {
          constructor(n) {
            super(n);
          }
        };
      tm.prototype.g = la([0, Ft, -4, as]);
      var zP = class extends me {
          constructor(n) {
            super(n);
          }
        },
        RP = hs(
          class extends me {
            constructor(n) {
              super(n);
            }
          },
          [0, Gt, [0, 1, Rt, At, Jp], as]
        ),
        Gh = class extends me {
          constructor(n) {
            super(n);
          }
        },
        BP = class extends me {
          constructor(n) {
            super(n);
          }
          ma() {
            const n = fp(this);
            return n ?? Os();
          }
        },
        OP = class extends me {
          constructor(n) {
            super(n);
          }
        },
        nm = [1, 2],
        LP = hs(
          class extends me {
            constructor(n) {
              super(n);
            }
          },
          [0, Gt, [0, nm, rt, [0, pu], rt, [0, Hp], Rt, At], as]
        ),
        mu = class extends me {
          constructor(n) {
            super(n);
          }
        },
        im = [0, At, Rt, Ft, Jt, -1],
        jh = class extends me {
          constructor(n) {
            super(n);
          }
        },
        UP = [0, yt, -1],
        Hh = class extends me {
          constructor(n) {
            super(n);
          }
        },
        vo = [1, 2, 3, 4, 5],
        Oo = class extends me {
          constructor(n) {
            super(n);
          }
          g() {
            return fp(this) != null;
          }
          h() {
            return Gn(this, 2) != null;
          }
        },
        Tt = class extends me {
          constructor(n) {
            super(n);
          }
          g() {
            return ip(vr(this, 2)) ?? !1;
          }
        },
        sm = [0, Hp, At, [0, Rt, as, -1], [0, wP, as]],
        Ot = [0, sm, yt, [0, vo, rt, Yp, rt, Vp, rt, Qp, rt, Kp, rt, Wp], Dn],
        ha = class extends me {
          constructor(n) {
            super(n);
          }
        },
        gu = [0, Ot, Ft, -1, Rt],
        FP = ei(502141897, ha);
      Nt[502141897] = gu;
      var NP = hs(
          class extends me {
            constructor(n) {
              super(n);
            }
          },
          [0, [0, Dn, -1, vP, _P], bP]
        ),
        rm = class extends me {
          constructor(n) {
            super(n);
          }
        },
        Am = class extends me {
          constructor(n) {
            super(n);
          }
        },
        Pu = [0, Ot, Ft, [0, Ot], yt],
        om = [0, Ot, gu, Pu, Ft, [0, [0, sm]]],
        kP = ei(508968150, Am);
      (Nt[508968150] = om), (Nt[508968149] = Pu);
      var am = class extends me {
          constructor(n) {
            super(n);
          }
        },
        GP = ei(513916220, am);
      Nt[513916220] = [0, Ot, om, Rt];
      var Gs = class extends me {
          constructor(n) {
            super(n);
          }
          h() {
            return Je(this, mu, 2);
          }
          g() {
            mt(this, 2);
          }
        },
        cm = [0, Ot, im];
      Nt[478825465] = cm;
      var jP = class extends me {
          constructor(n) {
            super(n);
          }
        },
        lm = class extends me {
          constructor(n) {
            super(n);
          }
        },
        vu = class extends me {
          constructor(n) {
            super(n);
          }
        },
        wu = class extends me {
          constructor(n) {
            super(n);
          }
        },
        um = class extends me {
          constructor(n) {
            super(n);
          }
        },
        Qh = [0, Ot, [0, Ot], cm, -1],
        hm = [0, Ot, Ft, Rt],
        _u = [0, Ot, Ft],
        fm = [0, Ot, hm, _u, Ft],
        HP = ei(479097054, um);
      (Nt[479097054] = [0, Ot, fm, Qh]), (Nt[463370452] = Qh), (Nt[464864288] = hm);
      var QP = ei(462713202, wu);
      (Nt[462713202] = fm), (Nt[474472470] = _u);
      var VP = class extends me {
          constructor(n) {
            super(n);
          }
        },
        dm = class extends me {
          constructor(n) {
            super(n);
          }
        },
        pm = class extends me {
          constructor(n) {
            super(n);
          }
        },
        mm = class extends me {
          constructor(n) {
            super(n);
          }
        },
        xu = [0, Ot, Ft, -1, Rt],
        Lc = [0, Ot, Ft, yt];
      mm.prototype.g = la([0, Ot, _u, [0, Ot], gu, Pu, xu, Lc]);
      var gm = class extends me {
          constructor(n) {
            super(n);
          }
        },
        WP = ei(456383383, gm);
      Nt[456383383] = [0, Ot, im];
      var Pm = class extends me {
          constructor(n) {
            super(n);
          }
        },
        KP = ei(476348187, Pm);
      Nt[476348187] = [0, Ot, UP];
      var vm = class extends me {
          constructor(n) {
            super(n);
          }
        },
        Vh = class extends me {
          constructor(n) {
            super(n);
          }
        },
        wm = [0, Dn, -1],
        YP = ei(
          458105876,
          class extends me {
            constructor(n) {
              super(n);
            }
            g() {
              var n = this.u;
              const e = 0 | n[_e],
                t = 2 & e;
              return (
                (n = (function (i, s, r) {
                  var A = Vh;
                  const o = 2 & s;
                  let a = !1;
                  if (r == null) {
                    if (o) return Mh();
                    r = [];
                  } else if (r.constructor === li) {
                    if ((2 & r.M) == 0 || o) return r;
                    r = r.da();
                  } else Array.isArray(r) ? (a = !!(2 & (0 | r[_e]))) : (r = []);
                  if (o) {
                    if (!r.length) return Mh();
                    a || ((a = !0), Or(r));
                  } else a && ((a = !1), (r = dp(r)));
                  return a || (64 & (0 | r[_e]) ? (r[_e] &= -33) : 32 & s && Vo(r, 32)), St(i, s, 2, (A = new li(r, A, tP, void 0))), A;
                })(n, e, Gi(n, e, 2))),
                !t && Vh && (n.pa = !0),
                n
              );
            }
          }
        );
      Nt[458105876] = [0, wm, PP, [!0, as, [0, At, -1, Jt]]];
      var yu = class extends me {
          constructor(n) {
            super(n);
          }
        },
        _m = ei(458105758, yu);
      Nt[458105758] = [0, Ot, At, wm];
      var xm = class extends me {
          constructor(n) {
            super(n);
          }
        },
        qP = ei(443442058, xm);
      (Nt[443442058] = [0, Ot, At, Rt, Ft, Jt, -1, yt, Ft]), (Nt[514774813] = xu);
      var ym = class extends me {
          constructor(n) {
            super(n);
          }
        },
        XP = ei(516587230, ym);
      function Uc(n, e) {
        return (
          (e = e ? e.clone() : new mu()),
          n.displayNamesLocale !== void 0 ? mt(e, 1, Ur(n.displayNamesLocale)) : n.displayNamesLocale === void 0 && mt(e, 1),
          n.maxResults !== void 0 ? ui(e, 2, n.maxResults) : "maxResults" in n && mt(e, 2),
          n.scoreThreshold !== void 0 ? Pe(e, 3, n.scoreThreshold) : "scoreThreshold" in n && mt(e, 3),
          n.categoryAllowlist !== void 0 ? Ro(e, 4, n.categoryAllowlist) : "categoryAllowlist" in n && mt(e, 4),
          n.categoryDenylist !== void 0 ? Ro(e, 5, n.categoryDenylist) : "categoryDenylist" in n && mt(e, 5),
          e
        );
      }
      function Tu(n, e = -1, t = "") {
        return {
          categories: n.map((i) => ({
            index: Nn(i, 1) ?? 0 ?? -1,
            score: Bt(i, 2) ?? 0,
            categoryName: Gn(i, 3) ?? "" ?? "",
            displayName: Gn(i, 4) ?? "" ?? "",
          })),
          headIndex: e,
          headName: t,
        };
      }
      function Tm(n) {
        var e = Is(n, 3, us, Ss()),
          t = Is(n, 2, Lr, Ss()),
          i = Is(n, 1, Pr, Ss()),
          s = Is(n, 9, Pr, Ss());
        const r = { categories: [], keypoints: [] };
        for (let A = 0; A < e.length; A++) r.categories.push({ score: e[A], index: t[A] ?? -1, categoryName: i[A] ?? "", displayName: s[A] ?? "" });
        if (
          ((e = Je(n, La, 4)?.h()) &&
            (r.boundingBox = { originX: Nn(e, 1) ?? 0, originY: Nn(e, 2) ?? 0, width: Nn(e, 3) ?? 0, height: Nn(e, 4) ?? 0, angle: 0 }),
          Je(n, La, 4)?.g().length)
        )
          for (const A of Je(n, La, 4).g()) r.keypoints.push({ x: go(A, 1) ?? 0, y: go(A, 2) ?? 0, score: go(A, 4) ?? 0, label: Gn(A, 3) ?? "" });
        return r;
      }
      function fa(n) {
        const e = [];
        for (const t of Fi(n, em, 1)) e.push({ x: Bt(t, 1) ?? 0, y: Bt(t, 2) ?? 0, z: Bt(t, 3) ?? 0, visibility: Bt(t, 4) ?? 0 });
        return e;
      }
      function hA(n) {
        const e = [];
        for (const t of Fi(n, $p, 1)) e.push({ x: Bt(t, 1) ?? 0, y: Bt(t, 2) ?? 0, z: Bt(t, 3) ?? 0, visibility: Bt(t, 4) ?? 0 });
        return e;
      }
      function Wh(n) {
        return Array.from(n, (e) => (e > 127 ? e - 256 : e));
      }
      function Kh(n, e) {
        if (n.length !== e.length) throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${n.length} vs. ${e.length}).`);
        let t = 0,
          i = 0,
          s = 0;
        for (let r = 0; r < n.length; r++) (t += n[r] * e[r]), (i += n[r] * n[r]), (s += e[r] * e[r]);
        if (i <= 0 || s <= 0) throw Error("Cannot compute cosine similarity on embedding with 0 norm.");
        return t / Math.sqrt(i * s);
      }
      let kA;
      (Nt[516587230] = [0, Ot, xu, Lc, Ft]), (Nt[518928384] = Lc);
      const JP = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
      async function Em() {
        if (kA === void 0)
          try {
            await WebAssembly.instantiate(JP), (kA = !0);
          } catch {
            kA = !1;
          }
        return kA;
      }
      async function Xr(n, e = TP``) {
        const t = (await Em()) ? "wasm_internal" : "wasm_nosimd_internal";
        return { wasmLoaderPath: `${e}/${n}_${t}.js`, wasmBinaryPath: `${e}/${n}_${t}.wasm` };
      }
      var Ts = class {};
      function Dm() {
        var n = navigator;
        return (
          typeof OffscreenCanvas < "u" &&
          (!(function (e = navigator) {
            return (e = e.userAgent).includes("Safari") && !e.includes("Chrome");
          })(n) ||
            !!((n = n.userAgent.match(/Version\/([\d]+).*Safari/)) && n.length >= 1 && Number(n[1]) >= 17))
        );
      }
      async function Yh(n) {
        if (typeof importScripts != "function") {
          const e = document.createElement("script");
          return (
            (e.src = n.toString()),
            (e.crossOrigin = "anonymous"),
            new Promise((t, i) => {
              e.addEventListener(
                "load",
                () => {
                  t();
                },
                !1
              ),
                e.addEventListener(
                  "error",
                  (s) => {
                    i(s);
                  },
                  !1
                ),
                document.body.appendChild(e);
            })
          );
        }
        importScripts(n.toString());
      }
      function Mm(n) {
        return n.videoWidth !== void 0
          ? [n.videoWidth, n.videoHeight]
          : n.naturalWidth !== void 0
          ? [n.naturalWidth, n.naturalHeight]
          : n.displayWidth !== void 0
          ? [n.displayWidth, n.displayHeight]
          : [n.width, n.height];
      }
      function we(n, e, t) {
        n.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"),
          t((e = n.i.stringToNewUTF8(e))),
          n.i._free(e);
      }
      function qh(n, e, t) {
        if (!n.i.canvas) throw Error("No OpenGL canvas configured.");
        if ((t ? n.i._bindTextureToStream(t) : n.i._bindTextureToCanvas(), !(t = n.i.canvas.getContext("webgl2") || n.i.canvas.getContext("webgl"))))
          throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
        n.i.gpuOriginForWebTexturesIsBottomLeft && t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !0),
          t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e),
          n.i.gpuOriginForWebTexturesIsBottomLeft && t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !1);
        const [i, s] = Mm(e);
        return !n.l || (i === n.i.canvas.width && s === n.i.canvas.height) || ((n.i.canvas.width = i), (n.i.canvas.height = s)), [i, s];
      }
      function Xh(n, e, t) {
        n.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
        const i = new Uint32Array(e.length);
        for (let s = 0; s < e.length; s++) i[s] = n.i.stringToNewUTF8(e[s]);
        (e = n.i._malloc(4 * i.length)), n.i.HEAPU32.set(i, e >> 2), t(e);
        for (const s of i) n.i._free(s);
        n.i._free(e);
      }
      function ii(n, e, t) {
        (n.i.simpleListeners = n.i.simpleListeners || {}), (n.i.simpleListeners[e] = t);
      }
      function Hi(n, e, t) {
        let i = [];
        (n.i.simpleListeners = n.i.simpleListeners || {}),
          (n.i.simpleListeners[e] = (s, r, A) => {
            r ? (t(i, A), (i = [])) : i.push(s);
          });
      }
      (Ts.forVisionTasks = function (n) {
        return Xr("vision", n);
      }),
        (Ts.forTextTasks = function (n) {
          return Xr("text", n);
        }),
        (Ts.forGenAiExperimentalTasks = function (n) {
          return Xr("genai_experimental", n);
        }),
        (Ts.forGenAiTasks = function (n) {
          return Xr("genai", n);
        }),
        (Ts.forAudioTasks = function (n) {
          return Xr("audio", n);
        }),
        (Ts.isSimdSupported = function () {
          return Em();
        });
      async function ZP(n, e, t, i) {
        return (
          (n = await (async (s, r, A, o, a) => {
            if ((r && (await Yh(r)), !self.ModuleFactory || (A && (await Yh(A), !self.ModuleFactory)))) throw Error("ModuleFactory not set.");
            return (
              self.Module && a && (((r = self.Module).locateFile = a.locateFile), a.mainScriptUrlOrBlob && (r.mainScriptUrlOrBlob = a.mainScriptUrlOrBlob)),
              (a = await self.ModuleFactory(self.Module || a)),
              (self.ModuleFactory = self.Module = void 0),
              new s(a, o)
            );
          })(n, t.wasmLoaderPath, t.assetLoaderPath, e, {
            locateFile: (s) =>
              s.endsWith(".wasm") ? t.wasmBinaryPath.toString() : t.assetBinaryPath && s.endsWith(".data") ? t.assetBinaryPath.toString() : s,
          })),
          await n.o(i),
          n
        );
      }
      function Ua(n, e) {
        const t = Je(n.baseOptions, Oo, 1) || new Oo();
        typeof e == "string" ? (mt(t, 2, Ur(e)), mt(t, 1)) : e instanceof Uint8Array && (mt(t, 1, kl(e, !1)), mt(t, 2)), De(n.baseOptions, 0, 1, t);
      }
      function Jh(n) {
        try {
          const e = n.G.length;
          if (e === 1) throw Error(n.G[0].message);
          if (e > 1) throw Error("Encountered multiple errors: " + n.G.map((t) => t.message).join(", "));
        } finally {
          n.G = [];
        }
      }
      function ce(n, e) {
        n.B = Math.max(n.B, e);
      }
      function da(n, e) {
        (n.A = new An()), Sn(n.A, "PassThroughCalculator"), gt(n.A, "free_memory"), Ye(n.A, "free_memory_unused_out"), wt(e, "free_memory"), In(e, n.A);
      }
      function _r(n, e) {
        gt(n.A, e), Ye(n.A, e + "_unused_out");
      }
      function pa(n) {
        n.g.addBoolToStream(!0, "free_memory", n.B);
      }
      var Fc = class {
        constructor(n) {
          (this.g = n), (this.G = []), (this.B = 0), this.g.setAutoRenderToScreen(!1);
        }
        l(n, e = !0) {
          if (e) {
            const t = n.baseOptions || {};
            if (n.baseOptions?.modelAssetBuffer && n.baseOptions?.modelAssetPath)
              throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
            if (!(Je(this.baseOptions, Oo, 1)?.g() || Je(this.baseOptions, Oo, 1)?.h() || n.baseOptions?.modelAssetBuffer || n.baseOptions?.modelAssetPath))
              throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
            if (
              ((function (i, s) {
                let r = Je(i.baseOptions, Hh, 3);
                if (!r) {
                  var A = (r = new Hh()),
                    o = new Uh();
                  lA(A, 4, vo, o);
                }
                "delegate" in s && (s.delegate === "GPU" ? ((s = r), (A = new EP()), lA(s, 2, vo, A)) : ((s = r), (A = new Uh()), lA(s, 4, vo, A))),
                  De(i.baseOptions, 0, 3, r);
              })(this, t),
              t.modelAssetPath)
            )
              return fetch(t.modelAssetPath.toString())
                .then((i) => {
                  if (i.ok) return i.arrayBuffer();
                  throw Error(`Failed to fetch model: ${t.modelAssetPath} (${i.status})`);
                })
                .then((i) => {
                  try {
                    this.g.i.FS_unlink("/model.dat");
                  } catch {}
                  this.g.i.FS_createDataFile("/", "model.dat", new Uint8Array(i), !0, !1, !1), Ua(this, "/model.dat"), this.m(), this.J();
                });
            if (t.modelAssetBuffer instanceof Uint8Array) Ua(this, t.modelAssetBuffer);
            else if (t.modelAssetBuffer)
              return (async function (i) {
                const s = [];
                for (var r = 0; ; ) {
                  const { done: A, value: o } = await i.read();
                  if (A) break;
                  s.push(o), (r += o.length);
                }
                if (s.length === 0) return new Uint8Array(0);
                if (s.length === 1) return s[0];
                (i = new Uint8Array(r)), (r = 0);
                for (const A of s) i.set(A, r), (r += A.length);
                return i;
              })(t.modelAssetBuffer).then((i) => {
                Ua(this, i), this.m(), this.J();
              });
          }
          return this.m(), this.J(), Promise.resolve();
        }
        J() {}
        ca() {
          let n;
          if (
            (this.g.ca((e) => {
              n = DP(e);
            }),
            !n)
          )
            throw Error("Failed to retrieve CalculatorGraphConfig");
          return n;
        }
        setGraph(n, e) {
          this.g.attachErrorListener((t, i) => {
            this.G.push(Error(i));
          }),
            this.g.Ha(),
            this.g.setGraph(n, e),
            (this.A = void 0),
            Jh(this);
        }
        finishProcessing() {
          this.g.finishProcessing(), Jh(this);
        }
        close() {
          (this.A = void 0), this.g.closeGraph();
        }
      };
      function Oi(n, e) {
        if (!n) throw Error(`Unable to obtain required WebGL resource: ${e}`);
        return n;
      }
      Fc.prototype.close = Fc.prototype.close;
      class $P {
        constructor(e, t, i, s) {
          (this.g = e), (this.h = t), (this.m = i), (this.l = s);
        }
        bind() {
          this.g.bindVertexArray(this.h);
        }
        close() {
          this.g.deleteVertexArray(this.h), this.g.deleteBuffer(this.m), this.g.deleteBuffer(this.l);
        }
      }
      function Zh(n, e, t) {
        const i = n.g;
        if (
          ((t = Oi(i.createShader(t), "Failed to create WebGL shader")), i.shaderSource(t, e), i.compileShader(t), !i.getShaderParameter(t, i.COMPILE_STATUS))
        )
          throw Error(`Could not compile WebGL shader: ${i.getShaderInfoLog(t)}`);
        return i.attachShader(n.h, t), t;
      }
      function $h(n, e) {
        const t = n.g,
          i = Oi(t.createVertexArray(), "Failed to create vertex array");
        t.bindVertexArray(i);
        const s = Oi(t.createBuffer(), "Failed to create buffer");
        t.bindBuffer(t.ARRAY_BUFFER, s),
          t.enableVertexAttribArray(n.P),
          t.vertexAttribPointer(n.P, 2, t.FLOAT, !1, 0, 0),
          t.bufferData(t.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), t.STATIC_DRAW);
        const r = Oi(t.createBuffer(), "Failed to create buffer");
        return (
          t.bindBuffer(t.ARRAY_BUFFER, r),
          t.enableVertexAttribArray(n.J),
          t.vertexAttribPointer(n.J, 2, t.FLOAT, !1, 0, 0),
          t.bufferData(t.ARRAY_BUFFER, new Float32Array(e ? [0, 1, 0, 0, 1, 0, 1, 1] : [0, 0, 0, 1, 1, 1, 1, 0]), t.STATIC_DRAW),
          t.bindBuffer(t.ARRAY_BUFFER, null),
          t.bindVertexArray(null),
          new $P(t, i, s, r)
        );
      }
      function Eu(n, e) {
        if (n.g) {
          if (e !== n.g) throw Error("Cannot change GL context once initialized");
        } else n.g = e;
      }
      function Du(n, e, t, i) {
        return (
          Eu(n, e),
          n.h || (n.m(), n.C()),
          t ? (n.s || (n.s = $h(n, !0)), (t = n.s)) : (n.v || (n.v = $h(n, !1)), (t = n.v)),
          e.useProgram(n.h),
          t.bind(),
          n.l(),
          (n = i()),
          t.g.bindVertexArray(null),
          n
        );
      }
      function ma(n, e, t) {
        return (
          Eu(n, e),
          (n = Oi(e.createTexture(), "Failed to create texture")),
          e.bindTexture(e.TEXTURE_2D, n),
          e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
          e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
          e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t ?? e.LINEAR),
          e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t ?? e.LINEAR),
          e.bindTexture(e.TEXTURE_2D, null),
          n
        );
      }
      function ga(n, e, t) {
        Eu(n, e),
          n.A || (n.A = Oi(e.createFramebuffer(), "Failed to create framebuffe.")),
          e.bindFramebuffer(e.FRAMEBUFFER, n.A),
          e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);
      }
      function Mu(n) {
        n.g?.bindFramebuffer(n.g.FRAMEBUFFER, null);
      }
      var Cu = class {
        G() {
          return `
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D inputTexture;
  void main() {
    gl_FragColor = texture2D(inputTexture, vTex);
  }
 `;
        }
        m() {
          const n = this.g;
          if (
            ((this.h = Oi(n.createProgram(), "Failed to create WebGL program")),
            (this.Z = Zh(
              this,
              `
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,
              n.VERTEX_SHADER
            )),
            (this.Y = Zh(this, this.G(), n.FRAGMENT_SHADER)),
            n.linkProgram(this.h),
            !n.getProgramParameter(this.h, n.LINK_STATUS))
          )
            throw Error(`Error during program linking: ${n.getProgramInfoLog(this.h)}`);
          (this.P = n.getAttribLocation(this.h, "aVertex")), (this.J = n.getAttribLocation(this.h, "aTex"));
        }
        C() {}
        l() {}
        close() {
          if (this.h) {
            const n = this.g;
            n.deleteProgram(this.h), n.deleteShader(this.Z), n.deleteShader(this.Y);
          }
          this.A && this.g.deleteFramebuffer(this.A), this.v && this.v.close(), this.s && this.s.close();
        }
      };
      function Ci(n, e) {
        switch (e) {
          case 0:
            return n.g.find((t) => t instanceof Uint8Array);
          case 1:
            return n.g.find((t) => t instanceof Float32Array);
          case 2:
            return n.g.find((t) => typeof WebGLTexture < "u" && t instanceof WebGLTexture);
          default:
            throw Error(`Type is not supported: ${e}`);
        }
      }
      function Nc(n) {
        var e = Ci(n, 1);
        if (!e) {
          if ((e = Ci(n, 0))) e = new Float32Array(e).map((i) => i / 255);
          else {
            e = new Float32Array(n.width * n.height);
            const i = xr(n);
            var t = Su(n);
            if (
              (ga(t, i, Cm(n)),
              "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) ||
                (navigator.userAgent.includes("Mac") && "document" in self && "ontouchend" in self.document))
            ) {
              (t = new Float32Array(n.width * n.height * 4)), i.readPixels(0, 0, n.width, n.height, i.RGBA, i.FLOAT, t);
              for (let s = 0, r = 0; s < e.length; ++s, r += 4) e[s] = t[r];
            } else i.readPixels(0, 0, n.width, n.height, i.RED, i.FLOAT, e);
          }
          n.g.push(e);
        }
        return e;
      }
      function Cm(n) {
        let e = Ci(n, 2);
        if (!e) {
          const t = xr(n);
          e = Im(n);
          const i = Nc(n),
            s = Sm(n);
          t.texImage2D(t.TEXTURE_2D, 0, s, n.width, n.height, 0, t.RED, t.FLOAT, i), kc(n);
        }
        return e;
      }
      function xr(n) {
        if (!n.canvas) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
        return n.h || (n.h = Oi(n.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), n.h;
      }
      function Sm(n) {
        if (((n = xr(n)), !GA))
          if (n.getExtension("EXT_color_buffer_float") && n.getExtension("OES_texture_float_linear") && n.getExtension("EXT_float_blend")) GA = n.R32F;
          else {
            if (!n.getExtension("EXT_color_buffer_half_float")) throw Error("GPU does not fully support 4-channel float32 or float16 formats");
            GA = n.R16F;
          }
        return GA;
      }
      function Su(n) {
        return n.l || (n.l = new Cu()), n.l;
      }
      function Im(n) {
        const e = xr(n);
        e.viewport(0, 0, n.width, n.height), e.activeTexture(e.TEXTURE0);
        let t = Ci(n, 2);
        return t || ((t = ma(Su(n), e, n.m ? e.LINEAR : e.NEAREST)), n.g.push(t), (n.j = !0)), e.bindTexture(e.TEXTURE_2D, t), t;
      }
      function kc(n) {
        n.h.bindTexture(n.h.TEXTURE_2D, null);
      }
      var GA,
        Vt = class {
          constructor(n, e, t, i, s, r, A) {
            (this.g = n),
              (this.m = e),
              (this.j = t),
              (this.canvas = i),
              (this.l = s),
              (this.width = r),
              (this.height = A),
              this.j && --ef === 0 && console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources.");
          }
          Da() {
            return !!Ci(this, 0);
          }
          ja() {
            return !!Ci(this, 1);
          }
          R() {
            return !!Ci(this, 2);
          }
          ia() {
            return (e = Ci((n = this), 0)) || ((e = Nc(n)), (e = new Uint8Array(e.map((t) => 255 * t))), n.g.push(e)), e;
            var n, e;
          }
          ha() {
            return Nc(this);
          }
          N() {
            return Cm(this);
          }
          clone() {
            const n = [];
            for (const e of this.g) {
              let t;
              if (e instanceof Uint8Array) t = new Uint8Array(e);
              else if (e instanceof Float32Array) t = new Float32Array(e);
              else {
                if (!(e instanceof WebGLTexture)) throw Error(`Type is not supported: ${e}`);
                {
                  const i = xr(this),
                    s = Su(this);
                  i.activeTexture(i.TEXTURE1), (t = ma(s, i, this.m ? i.LINEAR : i.NEAREST)), i.bindTexture(i.TEXTURE_2D, t);
                  const r = Sm(this);
                  i.texImage2D(i.TEXTURE_2D, 0, r, this.width, this.height, 0, i.RED, i.FLOAT, null),
                    i.bindTexture(i.TEXTURE_2D, null),
                    ga(s, i, t),
                    Du(s, i, !1, () => {
                      Im(this), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), i.drawArrays(i.TRIANGLE_FAN, 0, 4), kc(this);
                    }),
                    Mu(s),
                    kc(this);
                }
              }
              n.push(t);
            }
            return new Vt(n, this.m, this.R(), this.canvas, this.l, this.width, this.height);
          }
          close() {
            this.j && xr(this).deleteTexture(Ci(this, 2)), (ef = -1);
          }
        };
      (Vt.prototype.close = Vt.prototype.close),
        (Vt.prototype.clone = Vt.prototype.clone),
        (Vt.prototype.getAsWebGLTexture = Vt.prototype.N),
        (Vt.prototype.getAsFloat32Array = Vt.prototype.ha),
        (Vt.prototype.getAsUint8Array = Vt.prototype.ia),
        (Vt.prototype.hasWebGLTexture = Vt.prototype.R),
        (Vt.prototype.hasFloat32Array = Vt.prototype.ja),
        (Vt.prototype.hasUint8Array = Vt.prototype.Da);
      var ef = 250;
      function Ai(n, e) {
        switch (e) {
          case 0:
            return n.g.find((t) => t instanceof ImageData);
          case 1:
            return n.g.find((t) => typeof ImageBitmap < "u" && t instanceof ImageBitmap);
          case 2:
            return n.g.find((t) => typeof WebGLTexture < "u" && t instanceof WebGLTexture);
          default:
            throw Error(`Type is not supported: ${e}`);
        }
      }
      function bm(n) {
        var e = Ai(n, 0);
        if (!e) {
          e = yr(n);
          const t = Pa(n),
            i = new Uint8Array(n.width * n.height * 4);
          ga(t, e, wo(n)),
            e.readPixels(0, 0, n.width, n.height, e.RGBA, e.UNSIGNED_BYTE, i),
            Mu(t),
            (e = new ImageData(new Uint8ClampedArray(i.buffer), n.width, n.height)),
            n.g.push(e);
        }
        return e;
      }
      function wo(n) {
        let e = Ai(n, 2);
        if (!e) {
          const t = yr(n);
          e = _o(n);
          const i = Ai(n, 1) || bm(n);
          t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, i), oA(n);
        }
        return e;
      }
      function yr(n) {
        if (!n.canvas) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
        return n.h || (n.h = Oi(n.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), n.h;
      }
      function Pa(n) {
        return n.l || (n.l = new Cu()), n.l;
      }
      function _o(n) {
        const e = yr(n);
        e.viewport(0, 0, n.width, n.height), e.activeTexture(e.TEXTURE0);
        let t = Ai(n, 2);
        return t || ((t = ma(Pa(n), e)), n.g.push(t), (n.m = !0)), e.bindTexture(e.TEXTURE_2D, t), t;
      }
      function oA(n) {
        n.h.bindTexture(n.h.TEXTURE_2D, null);
      }
      function tf(n) {
        const e = yr(n);
        return Du(Pa(n), e, !0, () =>
          (function (t, i) {
            const s = t.canvas;
            if (s.width === t.width && s.height === t.height) return i();
            const r = s.width,
              A = s.height;
            return (s.width = t.width), (s.height = t.height), (t = i()), (s.width = r), (s.height = A), t;
          })(n, () => {
            if (
              (e.bindFramebuffer(e.FRAMEBUFFER, null),
              e.clearColor(0, 0, 0, 0),
              e.clear(e.COLOR_BUFFER_BIT),
              e.drawArrays(e.TRIANGLE_FAN, 0, 4),
              !(n.canvas instanceof OffscreenCanvas))
            )
              throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");
            return n.canvas.transferToImageBitmap();
          })
        );
      }
      var Wt = class {
        constructor(n, e, t, i, s, r, A) {
          (this.g = n),
            (this.j = e),
            (this.m = t),
            (this.canvas = i),
            (this.l = s),
            (this.width = r),
            (this.height = A),
            (this.j || this.m) && --nf === 0 && console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources.");
        }
        Ca() {
          return !!Ai(this, 0);
        }
        ka() {
          return !!Ai(this, 1);
        }
        R() {
          return !!Ai(this, 2);
        }
        Aa() {
          return bm(this);
        }
        za() {
          var n = Ai(this, 1);
          return n || (wo(this), _o(this), (n = tf(this)), oA(this), this.g.push(n), (this.j = !0)), n;
        }
        N() {
          return wo(this);
        }
        clone() {
          const n = [];
          for (const e of this.g) {
            let t;
            if (e instanceof ImageData) t = new ImageData(e.data, this.width, this.height);
            else if (e instanceof WebGLTexture) {
              const i = yr(this),
                s = Pa(this);
              i.activeTexture(i.TEXTURE1),
                (t = ma(s, i)),
                i.bindTexture(i.TEXTURE_2D, t),
                i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, this.width, this.height, 0, i.RGBA, i.UNSIGNED_BYTE, null),
                i.bindTexture(i.TEXTURE_2D, null),
                ga(s, i, t),
                Du(s, i, !1, () => {
                  _o(this), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), i.drawArrays(i.TRIANGLE_FAN, 0, 4), oA(this);
                }),
                Mu(s),
                oA(this);
            } else {
              if (!(e instanceof ImageBitmap)) throw Error(`Type is not supported: ${e}`);
              wo(this), _o(this), (t = tf(this)), oA(this);
            }
            n.push(t);
          }
          return new Wt(n, this.ka(), this.R(), this.canvas, this.l, this.width, this.height);
        }
        close() {
          this.j && Ai(this, 1).close(), this.m && yr(this).deleteTexture(Ai(this, 2)), (nf = -1);
        }
      };
      (Wt.prototype.close = Wt.prototype.close),
        (Wt.prototype.clone = Wt.prototype.clone),
        (Wt.prototype.getAsWebGLTexture = Wt.prototype.N),
        (Wt.prototype.getAsImageBitmap = Wt.prototype.za),
        (Wt.prototype.getAsImageData = Wt.prototype.Aa),
        (Wt.prototype.hasWebGLTexture = Wt.prototype.R),
        (Wt.prototype.hasImageBitmap = Wt.prototype.ka),
        (Wt.prototype.hasImageData = Wt.prototype.Ca);
      var nf = 250;
      function ti(...n) {
        return n.map(([e, t]) => ({ start: e, end: t }));
      }
      const e0 = (function (n) {
        return class extends n {
          Ha() {
            this.i._registerModelResourcesGraphService();
          }
        };
      })(
        ((sf = class {
          constructor(n, e) {
            (this.l = !0),
              (this.i = n),
              (this.g = null),
              (this.h = 0),
              (this.m = typeof this.i._addIntToInputStream == "function"),
              e !== void 0
                ? (this.i.canvas = e)
                : Dm()
                ? (this.i.canvas = new OffscreenCanvas(1, 1))
                : (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."),
                  (this.i.canvas = document.createElement("canvas")));
          }
          async initializeGraph(n) {
            const e = await (await fetch(n)).arrayBuffer();
            (n = !(n.endsWith(".pbtxt") || n.endsWith(".textproto"))), this.setGraph(new Uint8Array(e), n);
          }
          setGraphFromString(n) {
            this.setGraph(new TextEncoder().encode(n), !1);
          }
          setGraph(n, e) {
            const t = n.length,
              i = this.i._malloc(t);
            this.i.HEAPU8.set(n, i), e ? this.i._changeBinaryGraph(t, i) : this.i._changeTextGraph(t, i), this.i._free(i);
          }
          configureAudio(n, e, t, i, s) {
            this.i._configureAudio ||
              console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'),
              we(this, i || "input_audio", (r) => {
                we(this, (s = s || "audio_header"), (A) => {
                  this.i._configureAudio(r, A, n, e ?? 0, t);
                });
              });
          }
          setAutoResizeCanvas(n) {
            this.l = n;
          }
          setAutoRenderToScreen(n) {
            this.i._setAutoRenderToScreen(n);
          }
          setGpuBufferVerticalFlip(n) {
            this.i.gpuOriginForWebTexturesIsBottomLeft = n;
          }
          ca(n) {
            ii(this, "__graph_config__", (e) => {
              n(e);
            }),
              we(this, "__graph_config__", (e) => {
                this.i._getGraphConfig(e, void 0);
              }),
              delete this.i.simpleListeners.__graph_config__;
          }
          attachErrorListener(n) {
            this.i.errorListener = n;
          }
          attachEmptyPacketListener(n, e) {
            (this.i.emptyPacketListeners = this.i.emptyPacketListeners || {}), (this.i.emptyPacketListeners[n] = e);
          }
          addAudioToStream(n, e, t) {
            this.addAudioToStreamWithShape(n, 0, 0, e, t);
          }
          addAudioToStreamWithShape(n, e, t, i, s) {
            const r = 4 * n.length;
            this.h !== r && (this.g && this.i._free(this.g), (this.g = this.i._malloc(r)), (this.h = r)),
              this.i.HEAPF32.set(n, this.g / 4),
              we(this, i, (A) => {
                this.i._addAudioToInputStream(this.g, e, t, A, s);
              });
          }
          addGpuBufferToStream(n, e, t) {
            we(this, e, (i) => {
              const [s, r] = qh(this, n, i);
              this.i._addBoundTextureToStream(i, s, r, t);
            });
          }
          addBoolToStream(n, e, t) {
            we(this, e, (i) => {
              this.i._addBoolToInputStream(n, i, t);
            });
          }
          addDoubleToStream(n, e, t) {
            we(this, e, (i) => {
              this.i._addDoubleToInputStream(n, i, t);
            });
          }
          addFloatToStream(n, e, t) {
            we(this, e, (i) => {
              this.i._addFloatToInputStream(n, i, t);
            });
          }
          addIntToStream(n, e, t) {
            we(this, e, (i) => {
              this.i._addIntToInputStream(n, i, t);
            });
          }
          addUintToStream(n, e, t) {
            we(this, e, (i) => {
              this.i._addUintToInputStream(n, i, t);
            });
          }
          addStringToStream(n, e, t) {
            we(this, e, (i) => {
              we(this, n, (s) => {
                this.i._addStringToInputStream(s, i, t);
              });
            });
          }
          addStringRecordToStream(n, e, t) {
            we(this, e, (i) => {
              Xh(this, Object.keys(n), (s) => {
                Xh(this, Object.values(n), (r) => {
                  this.i._addFlatHashMapToInputStream(s, r, Object.keys(n).length, i, t);
                });
              });
            });
          }
          addProtoToStream(n, e, t, i) {
            we(this, t, (s) => {
              we(this, e, (r) => {
                const A = this.i._malloc(n.length);
                this.i.HEAPU8.set(n, A), this.i._addProtoToInputStream(A, n.length, r, s, i), this.i._free(A);
              });
            });
          }
          addEmptyPacketToStream(n, e) {
            we(this, n, (t) => {
              this.i._addEmptyPacketToInputStream(t, e);
            });
          }
          addBoolVectorToStream(n, e, t) {
            we(this, e, (i) => {
              const s = this.i._allocateBoolVector(n.length);
              if (!s) throw Error("Unable to allocate new bool vector on heap.");
              for (const r of n) this.i._addBoolVectorEntry(s, r);
              this.i._addBoolVectorToInputStream(s, i, t);
            });
          }
          addDoubleVectorToStream(n, e, t) {
            we(this, e, (i) => {
              const s = this.i._allocateDoubleVector(n.length);
              if (!s) throw Error("Unable to allocate new double vector on heap.");
              for (const r of n) this.i._addDoubleVectorEntry(s, r);
              this.i._addDoubleVectorToInputStream(s, i, t);
            });
          }
          addFloatVectorToStream(n, e, t) {
            we(this, e, (i) => {
              const s = this.i._allocateFloatVector(n.length);
              if (!s) throw Error("Unable to allocate new float vector on heap.");
              for (const r of n) this.i._addFloatVectorEntry(s, r);
              this.i._addFloatVectorToInputStream(s, i, t);
            });
          }
          addIntVectorToStream(n, e, t) {
            we(this, e, (i) => {
              const s = this.i._allocateIntVector(n.length);
              if (!s) throw Error("Unable to allocate new int vector on heap.");
              for (const r of n) this.i._addIntVectorEntry(s, r);
              this.i._addIntVectorToInputStream(s, i, t);
            });
          }
          addUintVectorToStream(n, e, t) {
            we(this, e, (i) => {
              const s = this.i._allocateUintVector(n.length);
              if (!s) throw Error("Unable to allocate new unsigned int vector on heap.");
              for (const r of n) this.i._addUintVectorEntry(s, r);
              this.i._addUintVectorToInputStream(s, i, t);
            });
          }
          addStringVectorToStream(n, e, t) {
            we(this, e, (i) => {
              const s = this.i._allocateStringVector(n.length);
              if (!s) throw Error("Unable to allocate new string vector on heap.");
              for (const r of n)
                we(this, r, (A) => {
                  this.i._addStringVectorEntry(s, A);
                });
              this.i._addStringVectorToInputStream(s, i, t);
            });
          }
          addBoolToInputSidePacket(n, e) {
            we(this, e, (t) => {
              this.i._addBoolToInputSidePacket(n, t);
            });
          }
          addDoubleToInputSidePacket(n, e) {
            we(this, e, (t) => {
              this.i._addDoubleToInputSidePacket(n, t);
            });
          }
          addFloatToInputSidePacket(n, e) {
            we(this, e, (t) => {
              this.i._addFloatToInputSidePacket(n, t);
            });
          }
          addIntToInputSidePacket(n, e) {
            we(this, e, (t) => {
              this.i._addIntToInputSidePacket(n, t);
            });
          }
          addUintToInputSidePacket(n, e) {
            we(this, e, (t) => {
              this.i._addUintToInputSidePacket(n, t);
            });
          }
          addStringToInputSidePacket(n, e) {
            we(this, e, (t) => {
              we(this, n, (i) => {
                this.i._addStringToInputSidePacket(i, t);
              });
            });
          }
          addProtoToInputSidePacket(n, e, t) {
            we(this, t, (i) => {
              we(this, e, (s) => {
                const r = this.i._malloc(n.length);
                this.i.HEAPU8.set(n, r), this.i._addProtoToInputSidePacket(r, n.length, s, i), this.i._free(r);
              });
            });
          }
          addBoolVectorToInputSidePacket(n, e) {
            we(this, e, (t) => {
              const i = this.i._allocateBoolVector(n.length);
              if (!i) throw Error("Unable to allocate new bool vector on heap.");
              for (const s of n) this.i._addBoolVectorEntry(i, s);
              this.i._addBoolVectorToInputSidePacket(i, t);
            });
          }
          addDoubleVectorToInputSidePacket(n, e) {
            we(this, e, (t) => {
              const i = this.i._allocateDoubleVector(n.length);
              if (!i) throw Error("Unable to allocate new double vector on heap.");
              for (const s of n) this.i._addDoubleVectorEntry(i, s);
              this.i._addDoubleVectorToInputSidePacket(i, t);
            });
          }
          addFloatVectorToInputSidePacket(n, e) {
            we(this, e, (t) => {
              const i = this.i._allocateFloatVector(n.length);
              if (!i) throw Error("Unable to allocate new float vector on heap.");
              for (const s of n) this.i._addFloatVectorEntry(i, s);
              this.i._addFloatVectorToInputSidePacket(i, t);
            });
          }
          addIntVectorToInputSidePacket(n, e) {
            we(this, e, (t) => {
              const i = this.i._allocateIntVector(n.length);
              if (!i) throw Error("Unable to allocate new int vector on heap.");
              for (const s of n) this.i._addIntVectorEntry(i, s);
              this.i._addIntVectorToInputSidePacket(i, t);
            });
          }
          addUintVectorToInputSidePacket(n, e) {
            we(this, e, (t) => {
              const i = this.i._allocateUintVector(n.length);
              if (!i) throw Error("Unable to allocate new unsigned int vector on heap.");
              for (const s of n) this.i._addUintVectorEntry(i, s);
              this.i._addUintVectorToInputSidePacket(i, t);
            });
          }
          addStringVectorToInputSidePacket(n, e) {
            we(this, e, (t) => {
              const i = this.i._allocateStringVector(n.length);
              if (!i) throw Error("Unable to allocate new string vector on heap.");
              for (const s of n)
                we(this, s, (r) => {
                  this.i._addStringVectorEntry(i, r);
                });
              this.i._addStringVectorToInputSidePacket(i, t);
            });
          }
          attachBoolListener(n, e) {
            ii(this, n, e),
              we(this, n, (t) => {
                this.i._attachBoolListener(t);
              });
          }
          attachBoolVectorListener(n, e) {
            Hi(this, n, e),
              we(this, n, (t) => {
                this.i._attachBoolVectorListener(t);
              });
          }
          attachIntListener(n, e) {
            ii(this, n, e),
              we(this, n, (t) => {
                this.i._attachIntListener(t);
              });
          }
          attachIntVectorListener(n, e) {
            Hi(this, n, e),
              we(this, n, (t) => {
                this.i._attachIntVectorListener(t);
              });
          }
          attachUintListener(n, e) {
            ii(this, n, e),
              we(this, n, (t) => {
                this.i._attachUintListener(t);
              });
          }
          attachUintVectorListener(n, e) {
            Hi(this, n, e),
              we(this, n, (t) => {
                this.i._attachUintVectorListener(t);
              });
          }
          attachDoubleListener(n, e) {
            ii(this, n, e),
              we(this, n, (t) => {
                this.i._attachDoubleListener(t);
              });
          }
          attachDoubleVectorListener(n, e) {
            Hi(this, n, e),
              we(this, n, (t) => {
                this.i._attachDoubleVectorListener(t);
              });
          }
          attachFloatListener(n, e) {
            ii(this, n, e),
              we(this, n, (t) => {
                this.i._attachFloatListener(t);
              });
          }
          attachFloatVectorListener(n, e) {
            Hi(this, n, e),
              we(this, n, (t) => {
                this.i._attachFloatVectorListener(t);
              });
          }
          attachStringListener(n, e) {
            ii(this, n, e),
              we(this, n, (t) => {
                this.i._attachStringListener(t);
              });
          }
          attachStringVectorListener(n, e) {
            Hi(this, n, e),
              we(this, n, (t) => {
                this.i._attachStringVectorListener(t);
              });
          }
          attachProtoListener(n, e, t) {
            ii(this, n, e),
              we(this, n, (i) => {
                this.i._attachProtoListener(i, t || !1);
              });
          }
          attachProtoVectorListener(n, e, t) {
            Hi(this, n, e),
              we(this, n, (i) => {
                this.i._attachProtoVectorListener(i, t || !1);
              });
          }
          attachAudioListener(n, e, t) {
            this.i._attachAudioListener ||
              console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'),
              ii(this, n, (i, s) => {
                (i = new Float32Array(i.buffer, i.byteOffset, i.length / 4)), e(i, s);
              }),
              we(this, n, (i) => {
                this.i._attachAudioListener(i, t || !1);
              });
          }
          finishProcessing() {
            this.i._waitUntilIdle();
          }
          closeGraph() {
            this.i._closeGraph(), (this.i.simpleListeners = void 0), (this.i.emptyPacketListeners = void 0);
          }
        }),
        class extends sf {
          get ea() {
            return this.i;
          }
          oa(n, e, t) {
            we(this, e, (i) => {
              const [s, r] = qh(this, n, i);
              this.ea._addBoundTextureAsImageToStream(i, s, r, t);
            });
          }
          V(n, e) {
            ii(this, n, e),
              we(this, n, (t) => {
                this.ea._attachImageListener(t);
              });
          }
          ba(n, e) {
            Hi(this, n, e),
              we(this, n, (t) => {
                this.ea._attachImageVectorListener(t);
              });
          }
        })
      );
      var sf,
        jn = class extends e0 {};
      async function Ke(n, e, t) {
        return (async function (i, s, r, A) {
          return ZP(i, s, r, A);
        })(n, t.canvas ?? (Dm() ? void 0 : document.createElement("canvas")), e, t);
      }
      function zm(n, e, t, i) {
        if (n.U) {
          const r = new tm();
          if (t?.regionOfInterest) {
            if (!n.na) throw Error("This task doesn't support region-of-interest.");
            var s = t.regionOfInterest;
            if (s.left >= s.right || s.top >= s.bottom) throw Error("Expected RectF with left < right and top < bottom.");
            if (s.left < 0 || s.top < 0 || s.right > 1 || s.bottom > 1) throw Error("Expected RectF values to be in [0,1].");
            Pe(r, 1, (s.left + s.right) / 2), Pe(r, 2, (s.top + s.bottom) / 2), Pe(r, 4, s.right - s.left), Pe(r, 3, s.bottom - s.top);
          } else Pe(r, 1, 0.5), Pe(r, 2, 0.5), Pe(r, 4, 1), Pe(r, 3, 1);
          if (t?.rotationDegrees) {
            if (t?.rotationDegrees % 90 != 0) throw Error("Expected rotation to be a multiple of 90.");
            if ((Pe(r, 5, (-Math.PI * t.rotationDegrees) / 180), t?.rotationDegrees % 180 != 0)) {
              const [A, o] = Mm(e);
              (t = (Bt(r, 3) * o) / A), (s = (Bt(r, 4) * A) / o), Pe(r, 4, t), Pe(r, 3, s);
            }
          }
          n.g.addProtoToStream(r.g(), "mediapipe.NormalizedRect", n.U, i);
        }
        n.g.oa(e, n.Z, i ?? performance.now()), n.finishProcessing();
      }
      function Hn(n, e, t) {
        if (n.baseOptions?.g()) throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");
        zm(n, e, t, n.B + 1);
      }
      function di(n, e, t, i) {
        if (!n.baseOptions?.g()) throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");
        zm(n, e, t, i);
      }
      function Tr(n, e, t, i) {
        var s = e.data;
        const r = e.width,
          A = r * (e = e.height);
        if ((s instanceof Uint8Array || s instanceof Float32Array) && s.length !== A) throw Error("Unsupported channel count: " + s.length / A);
        return (n = new Vt([s], t, !1, n.g.i.canvas, n.P, r, e)), i ? n.clone() : n;
      }
      var dn = class extends Fc {
        constructor(n, e, t, i) {
          super(n), (this.g = n), (this.Z = e), (this.U = t), (this.na = i), (this.P = new Cu());
        }
        l(n, e = !0) {
          if (
            ("runningMode" in n && _A(this.baseOptions, 2, !!n.runningMode && n.runningMode !== "IMAGE"), n.canvas !== void 0 && this.g.i.canvas !== n.canvas)
          )
            throw Error("You must create a new task to reset the canvas.");
          return super.l(n, e);
        }
        close() {
          this.P.close(), super.close();
        }
      };
      dn.prototype.close = dn.prototype.close;
      var Rn = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "image_in", "norm_rect_in", !1),
            (this.j = { detections: [] }),
            De((n = this.h = new ha()), 0, 1, (e = new Tt())),
            Pe(this.h, 2, 0.5),
            Pe(this.h, 3, 0.3);
        }
        get baseOptions() {
          return Je(this.h, Tt, 1);
        }
        set baseOptions(n) {
          De(this.h, 0, 1, n);
        }
        o(n) {
          return (
            "minDetectionConfidence" in n && Pe(this.h, 2, n.minDetectionConfidence ?? 0.5),
            "minSuppressionThreshold" in n && Pe(this.h, 3, n.minSuppressionThreshold ?? 0.3),
            this.l(n)
          );
        }
        D(n, e) {
          return (this.j = { detections: [] }), Hn(this, n, e), this.j;
        }
        F(n, e, t) {
          return (this.j = { detections: [] }), di(this, n, t, e), this.j;
        }
        m() {
          var n = new pn();
          wt(n, "image_in"), wt(n, "norm_rect_in"), et(n, "detections");
          const e = new Mn();
          Zn(e, FP, this.h);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.face_detector.FaceDetectorGraph"),
            gt(t, "IMAGE:image_in"),
            gt(t, "NORM_RECT:norm_rect_in"),
            Ye(t, "DETECTIONS:detections"),
            t.o(e),
            In(n, t),
            this.g.attachProtoVectorListener("detections", (i, s) => {
              for (const r of i) (i = Zp(r)), this.j.detections.push(Tm(i));
              ce(this, s);
            }),
            this.g.attachEmptyPacketListener("detections", (i) => {
              ce(this, i);
            }),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (Rn.prototype.detectForVideo = Rn.prototype.F),
        (Rn.prototype.detect = Rn.prototype.D),
        (Rn.prototype.setOptions = Rn.prototype.o),
        (Rn.createFromModelPath = async function (n, e) {
          return Ke(Rn, n, { baseOptions: { modelAssetPath: e } });
        }),
        (Rn.createFromModelBuffer = function (n, e) {
          return Ke(Rn, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (Rn.createFromOptions = function (n, e) {
          return Ke(Rn, n, e);
        });
      var Iu = ti(
          [61, 146],
          [146, 91],
          [91, 181],
          [181, 84],
          [84, 17],
          [17, 314],
          [314, 405],
          [405, 321],
          [321, 375],
          [375, 291],
          [61, 185],
          [185, 40],
          [40, 39],
          [39, 37],
          [37, 0],
          [0, 267],
          [267, 269],
          [269, 270],
          [270, 409],
          [409, 291],
          [78, 95],
          [95, 88],
          [88, 178],
          [178, 87],
          [87, 14],
          [14, 317],
          [317, 402],
          [402, 318],
          [318, 324],
          [324, 308],
          [78, 191],
          [191, 80],
          [80, 81],
          [81, 82],
          [82, 13],
          [13, 312],
          [312, 311],
          [311, 310],
          [310, 415],
          [415, 308]
        ),
        bu = ti(
          [263, 249],
          [249, 390],
          [390, 373],
          [373, 374],
          [374, 380],
          [380, 381],
          [381, 382],
          [382, 362],
          [263, 466],
          [466, 388],
          [388, 387],
          [387, 386],
          [386, 385],
          [385, 384],
          [384, 398],
          [398, 362]
        ),
        zu = ti([276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]),
        Rm = ti([474, 475], [475, 476], [476, 477], [477, 474]),
        Ru = ti(
          [33, 7],
          [7, 163],
          [163, 144],
          [144, 145],
          [145, 153],
          [153, 154],
          [154, 155],
          [155, 133],
          [33, 246],
          [246, 161],
          [161, 160],
          [160, 159],
          [159, 158],
          [158, 157],
          [157, 173],
          [173, 133]
        ),
        Bu = ti([46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]),
        Bm = ti([469, 470], [470, 471], [471, 472], [472, 469]),
        Ou = ti(
          [10, 338],
          [338, 297],
          [297, 332],
          [332, 284],
          [284, 251],
          [251, 389],
          [389, 356],
          [356, 454],
          [454, 323],
          [323, 361],
          [361, 288],
          [288, 397],
          [397, 365],
          [365, 379],
          [379, 378],
          [378, 400],
          [400, 377],
          [377, 152],
          [152, 148],
          [148, 176],
          [176, 149],
          [149, 150],
          [150, 136],
          [136, 172],
          [172, 58],
          [58, 132],
          [132, 93],
          [93, 234],
          [234, 127],
          [127, 162],
          [162, 21],
          [21, 54],
          [54, 103],
          [103, 67],
          [67, 109],
          [109, 10]
        ),
        Om = [...Iu, ...bu, ...zu, ...Ru, ...Bu, ...Ou],
        Lm = ti(
          [127, 34],
          [34, 139],
          [139, 127],
          [11, 0],
          [0, 37],
          [37, 11],
          [232, 231],
          [231, 120],
          [120, 232],
          [72, 37],
          [37, 39],
          [39, 72],
          [128, 121],
          [121, 47],
          [47, 128],
          [232, 121],
          [121, 128],
          [128, 232],
          [104, 69],
          [69, 67],
          [67, 104],
          [175, 171],
          [171, 148],
          [148, 175],
          [118, 50],
          [50, 101],
          [101, 118],
          [73, 39],
          [39, 40],
          [40, 73],
          [9, 151],
          [151, 108],
          [108, 9],
          [48, 115],
          [115, 131],
          [131, 48],
          [194, 204],
          [204, 211],
          [211, 194],
          [74, 40],
          [40, 185],
          [185, 74],
          [80, 42],
          [42, 183],
          [183, 80],
          [40, 92],
          [92, 186],
          [186, 40],
          [230, 229],
          [229, 118],
          [118, 230],
          [202, 212],
          [212, 214],
          [214, 202],
          [83, 18],
          [18, 17],
          [17, 83],
          [76, 61],
          [61, 146],
          [146, 76],
          [160, 29],
          [29, 30],
          [30, 160],
          [56, 157],
          [157, 173],
          [173, 56],
          [106, 204],
          [204, 194],
          [194, 106],
          [135, 214],
          [214, 192],
          [192, 135],
          [203, 165],
          [165, 98],
          [98, 203],
          [21, 71],
          [71, 68],
          [68, 21],
          [51, 45],
          [45, 4],
          [4, 51],
          [144, 24],
          [24, 23],
          [23, 144],
          [77, 146],
          [146, 91],
          [91, 77],
          [205, 50],
          [50, 187],
          [187, 205],
          [201, 200],
          [200, 18],
          [18, 201],
          [91, 106],
          [106, 182],
          [182, 91],
          [90, 91],
          [91, 181],
          [181, 90],
          [85, 84],
          [84, 17],
          [17, 85],
          [206, 203],
          [203, 36],
          [36, 206],
          [148, 171],
          [171, 140],
          [140, 148],
          [92, 40],
          [40, 39],
          [39, 92],
          [193, 189],
          [189, 244],
          [244, 193],
          [159, 158],
          [158, 28],
          [28, 159],
          [247, 246],
          [246, 161],
          [161, 247],
          [236, 3],
          [3, 196],
          [196, 236],
          [54, 68],
          [68, 104],
          [104, 54],
          [193, 168],
          [168, 8],
          [8, 193],
          [117, 228],
          [228, 31],
          [31, 117],
          [189, 193],
          [193, 55],
          [55, 189],
          [98, 97],
          [97, 99],
          [99, 98],
          [126, 47],
          [47, 100],
          [100, 126],
          [166, 79],
          [79, 218],
          [218, 166],
          [155, 154],
          [154, 26],
          [26, 155],
          [209, 49],
          [49, 131],
          [131, 209],
          [135, 136],
          [136, 150],
          [150, 135],
          [47, 126],
          [126, 217],
          [217, 47],
          [223, 52],
          [52, 53],
          [53, 223],
          [45, 51],
          [51, 134],
          [134, 45],
          [211, 170],
          [170, 140],
          [140, 211],
          [67, 69],
          [69, 108],
          [108, 67],
          [43, 106],
          [106, 91],
          [91, 43],
          [230, 119],
          [119, 120],
          [120, 230],
          [226, 130],
          [130, 247],
          [247, 226],
          [63, 53],
          [53, 52],
          [52, 63],
          [238, 20],
          [20, 242],
          [242, 238],
          [46, 70],
          [70, 156],
          [156, 46],
          [78, 62],
          [62, 96],
          [96, 78],
          [46, 53],
          [53, 63],
          [63, 46],
          [143, 34],
          [34, 227],
          [227, 143],
          [123, 117],
          [117, 111],
          [111, 123],
          [44, 125],
          [125, 19],
          [19, 44],
          [236, 134],
          [134, 51],
          [51, 236],
          [216, 206],
          [206, 205],
          [205, 216],
          [154, 153],
          [153, 22],
          [22, 154],
          [39, 37],
          [37, 167],
          [167, 39],
          [200, 201],
          [201, 208],
          [208, 200],
          [36, 142],
          [142, 100],
          [100, 36],
          [57, 212],
          [212, 202],
          [202, 57],
          [20, 60],
          [60, 99],
          [99, 20],
          [28, 158],
          [158, 157],
          [157, 28],
          [35, 226],
          [226, 113],
          [113, 35],
          [160, 159],
          [159, 27],
          [27, 160],
          [204, 202],
          [202, 210],
          [210, 204],
          [113, 225],
          [225, 46],
          [46, 113],
          [43, 202],
          [202, 204],
          [204, 43],
          [62, 76],
          [76, 77],
          [77, 62],
          [137, 123],
          [123, 116],
          [116, 137],
          [41, 38],
          [38, 72],
          [72, 41],
          [203, 129],
          [129, 142],
          [142, 203],
          [64, 98],
          [98, 240],
          [240, 64],
          [49, 102],
          [102, 64],
          [64, 49],
          [41, 73],
          [73, 74],
          [74, 41],
          [212, 216],
          [216, 207],
          [207, 212],
          [42, 74],
          [74, 184],
          [184, 42],
          [169, 170],
          [170, 211],
          [211, 169],
          [170, 149],
          [149, 176],
          [176, 170],
          [105, 66],
          [66, 69],
          [69, 105],
          [122, 6],
          [6, 168],
          [168, 122],
          [123, 147],
          [147, 187],
          [187, 123],
          [96, 77],
          [77, 90],
          [90, 96],
          [65, 55],
          [55, 107],
          [107, 65],
          [89, 90],
          [90, 180],
          [180, 89],
          [101, 100],
          [100, 120],
          [120, 101],
          [63, 105],
          [105, 104],
          [104, 63],
          [93, 137],
          [137, 227],
          [227, 93],
          [15, 86],
          [86, 85],
          [85, 15],
          [129, 102],
          [102, 49],
          [49, 129],
          [14, 87],
          [87, 86],
          [86, 14],
          [55, 8],
          [8, 9],
          [9, 55],
          [100, 47],
          [47, 121],
          [121, 100],
          [145, 23],
          [23, 22],
          [22, 145],
          [88, 89],
          [89, 179],
          [179, 88],
          [6, 122],
          [122, 196],
          [196, 6],
          [88, 95],
          [95, 96],
          [96, 88],
          [138, 172],
          [172, 136],
          [136, 138],
          [215, 58],
          [58, 172],
          [172, 215],
          [115, 48],
          [48, 219],
          [219, 115],
          [42, 80],
          [80, 81],
          [81, 42],
          [195, 3],
          [3, 51],
          [51, 195],
          [43, 146],
          [146, 61],
          [61, 43],
          [171, 175],
          [175, 199],
          [199, 171],
          [81, 82],
          [82, 38],
          [38, 81],
          [53, 46],
          [46, 225],
          [225, 53],
          [144, 163],
          [163, 110],
          [110, 144],
          [52, 65],
          [65, 66],
          [66, 52],
          [229, 228],
          [228, 117],
          [117, 229],
          [34, 127],
          [127, 234],
          [234, 34],
          [107, 108],
          [108, 69],
          [69, 107],
          [109, 108],
          [108, 151],
          [151, 109],
          [48, 64],
          [64, 235],
          [235, 48],
          [62, 78],
          [78, 191],
          [191, 62],
          [129, 209],
          [209, 126],
          [126, 129],
          [111, 35],
          [35, 143],
          [143, 111],
          [117, 123],
          [123, 50],
          [50, 117],
          [222, 65],
          [65, 52],
          [52, 222],
          [19, 125],
          [125, 141],
          [141, 19],
          [221, 55],
          [55, 65],
          [65, 221],
          [3, 195],
          [195, 197],
          [197, 3],
          [25, 7],
          [7, 33],
          [33, 25],
          [220, 237],
          [237, 44],
          [44, 220],
          [70, 71],
          [71, 139],
          [139, 70],
          [122, 193],
          [193, 245],
          [245, 122],
          [247, 130],
          [130, 33],
          [33, 247],
          [71, 21],
          [21, 162],
          [162, 71],
          [170, 169],
          [169, 150],
          [150, 170],
          [188, 174],
          [174, 196],
          [196, 188],
          [216, 186],
          [186, 92],
          [92, 216],
          [2, 97],
          [97, 167],
          [167, 2],
          [141, 125],
          [125, 241],
          [241, 141],
          [164, 167],
          [167, 37],
          [37, 164],
          [72, 38],
          [38, 12],
          [12, 72],
          [38, 82],
          [82, 13],
          [13, 38],
          [63, 68],
          [68, 71],
          [71, 63],
          [226, 35],
          [35, 111],
          [111, 226],
          [101, 50],
          [50, 205],
          [205, 101],
          [206, 92],
          [92, 165],
          [165, 206],
          [209, 198],
          [198, 217],
          [217, 209],
          [165, 167],
          [167, 97],
          [97, 165],
          [220, 115],
          [115, 218],
          [218, 220],
          [133, 112],
          [112, 243],
          [243, 133],
          [239, 238],
          [238, 241],
          [241, 239],
          [214, 135],
          [135, 169],
          [169, 214],
          [190, 173],
          [173, 133],
          [133, 190],
          [171, 208],
          [208, 32],
          [32, 171],
          [125, 44],
          [44, 237],
          [237, 125],
          [86, 87],
          [87, 178],
          [178, 86],
          [85, 86],
          [86, 179],
          [179, 85],
          [84, 85],
          [85, 180],
          [180, 84],
          [83, 84],
          [84, 181],
          [181, 83],
          [201, 83],
          [83, 182],
          [182, 201],
          [137, 93],
          [93, 132],
          [132, 137],
          [76, 62],
          [62, 183],
          [183, 76],
          [61, 76],
          [76, 184],
          [184, 61],
          [57, 61],
          [61, 185],
          [185, 57],
          [212, 57],
          [57, 186],
          [186, 212],
          [214, 207],
          [207, 187],
          [187, 214],
          [34, 143],
          [143, 156],
          [156, 34],
          [79, 239],
          [239, 237],
          [237, 79],
          [123, 137],
          [137, 177],
          [177, 123],
          [44, 1],
          [1, 4],
          [4, 44],
          [201, 194],
          [194, 32],
          [32, 201],
          [64, 102],
          [102, 129],
          [129, 64],
          [213, 215],
          [215, 138],
          [138, 213],
          [59, 166],
          [166, 219],
          [219, 59],
          [242, 99],
          [99, 97],
          [97, 242],
          [2, 94],
          [94, 141],
          [141, 2],
          [75, 59],
          [59, 235],
          [235, 75],
          [24, 110],
          [110, 228],
          [228, 24],
          [25, 130],
          [130, 226],
          [226, 25],
          [23, 24],
          [24, 229],
          [229, 23],
          [22, 23],
          [23, 230],
          [230, 22],
          [26, 22],
          [22, 231],
          [231, 26],
          [112, 26],
          [26, 232],
          [232, 112],
          [189, 190],
          [190, 243],
          [243, 189],
          [221, 56],
          [56, 190],
          [190, 221],
          [28, 56],
          [56, 221],
          [221, 28],
          [27, 28],
          [28, 222],
          [222, 27],
          [29, 27],
          [27, 223],
          [223, 29],
          [30, 29],
          [29, 224],
          [224, 30],
          [247, 30],
          [30, 225],
          [225, 247],
          [238, 79],
          [79, 20],
          [20, 238],
          [166, 59],
          [59, 75],
          [75, 166],
          [60, 75],
          [75, 240],
          [240, 60],
          [147, 177],
          [177, 215],
          [215, 147],
          [20, 79],
          [79, 166],
          [166, 20],
          [187, 147],
          [147, 213],
          [213, 187],
          [112, 233],
          [233, 244],
          [244, 112],
          [233, 128],
          [128, 245],
          [245, 233],
          [128, 114],
          [114, 188],
          [188, 128],
          [114, 217],
          [217, 174],
          [174, 114],
          [131, 115],
          [115, 220],
          [220, 131],
          [217, 198],
          [198, 236],
          [236, 217],
          [198, 131],
          [131, 134],
          [134, 198],
          [177, 132],
          [132, 58],
          [58, 177],
          [143, 35],
          [35, 124],
          [124, 143],
          [110, 163],
          [163, 7],
          [7, 110],
          [228, 110],
          [110, 25],
          [25, 228],
          [356, 389],
          [389, 368],
          [368, 356],
          [11, 302],
          [302, 267],
          [267, 11],
          [452, 350],
          [350, 349],
          [349, 452],
          [302, 303],
          [303, 269],
          [269, 302],
          [357, 343],
          [343, 277],
          [277, 357],
          [452, 453],
          [453, 357],
          [357, 452],
          [333, 332],
          [332, 297],
          [297, 333],
          [175, 152],
          [152, 377],
          [377, 175],
          [347, 348],
          [348, 330],
          [330, 347],
          [303, 304],
          [304, 270],
          [270, 303],
          [9, 336],
          [336, 337],
          [337, 9],
          [278, 279],
          [279, 360],
          [360, 278],
          [418, 262],
          [262, 431],
          [431, 418],
          [304, 408],
          [408, 409],
          [409, 304],
          [310, 415],
          [415, 407],
          [407, 310],
          [270, 409],
          [409, 410],
          [410, 270],
          [450, 348],
          [348, 347],
          [347, 450],
          [422, 430],
          [430, 434],
          [434, 422],
          [313, 314],
          [314, 17],
          [17, 313],
          [306, 307],
          [307, 375],
          [375, 306],
          [387, 388],
          [388, 260],
          [260, 387],
          [286, 414],
          [414, 398],
          [398, 286],
          [335, 406],
          [406, 418],
          [418, 335],
          [364, 367],
          [367, 416],
          [416, 364],
          [423, 358],
          [358, 327],
          [327, 423],
          [251, 284],
          [284, 298],
          [298, 251],
          [281, 5],
          [5, 4],
          [4, 281],
          [373, 374],
          [374, 253],
          [253, 373],
          [307, 320],
          [320, 321],
          [321, 307],
          [425, 427],
          [427, 411],
          [411, 425],
          [421, 313],
          [313, 18],
          [18, 421],
          [321, 405],
          [405, 406],
          [406, 321],
          [320, 404],
          [404, 405],
          [405, 320],
          [315, 16],
          [16, 17],
          [17, 315],
          [426, 425],
          [425, 266],
          [266, 426],
          [377, 400],
          [400, 369],
          [369, 377],
          [322, 391],
          [391, 269],
          [269, 322],
          [417, 465],
          [465, 464],
          [464, 417],
          [386, 257],
          [257, 258],
          [258, 386],
          [466, 260],
          [260, 388],
          [388, 466],
          [456, 399],
          [399, 419],
          [419, 456],
          [284, 332],
          [332, 333],
          [333, 284],
          [417, 285],
          [285, 8],
          [8, 417],
          [346, 340],
          [340, 261],
          [261, 346],
          [413, 441],
          [441, 285],
          [285, 413],
          [327, 460],
          [460, 328],
          [328, 327],
          [355, 371],
          [371, 329],
          [329, 355],
          [392, 439],
          [439, 438],
          [438, 392],
          [382, 341],
          [341, 256],
          [256, 382],
          [429, 420],
          [420, 360],
          [360, 429],
          [364, 394],
          [394, 379],
          [379, 364],
          [277, 343],
          [343, 437],
          [437, 277],
          [443, 444],
          [444, 283],
          [283, 443],
          [275, 440],
          [440, 363],
          [363, 275],
          [431, 262],
          [262, 369],
          [369, 431],
          [297, 338],
          [338, 337],
          [337, 297],
          [273, 375],
          [375, 321],
          [321, 273],
          [450, 451],
          [451, 349],
          [349, 450],
          [446, 342],
          [342, 467],
          [467, 446],
          [293, 334],
          [334, 282],
          [282, 293],
          [458, 461],
          [461, 462],
          [462, 458],
          [276, 353],
          [353, 383],
          [383, 276],
          [308, 324],
          [324, 325],
          [325, 308],
          [276, 300],
          [300, 293],
          [293, 276],
          [372, 345],
          [345, 447],
          [447, 372],
          [352, 345],
          [345, 340],
          [340, 352],
          [274, 1],
          [1, 19],
          [19, 274],
          [456, 248],
          [248, 281],
          [281, 456],
          [436, 427],
          [427, 425],
          [425, 436],
          [381, 256],
          [256, 252],
          [252, 381],
          [269, 391],
          [391, 393],
          [393, 269],
          [200, 199],
          [199, 428],
          [428, 200],
          [266, 330],
          [330, 329],
          [329, 266],
          [287, 273],
          [273, 422],
          [422, 287],
          [250, 462],
          [462, 328],
          [328, 250],
          [258, 286],
          [286, 384],
          [384, 258],
          [265, 353],
          [353, 342],
          [342, 265],
          [387, 259],
          [259, 257],
          [257, 387],
          [424, 431],
          [431, 430],
          [430, 424],
          [342, 353],
          [353, 276],
          [276, 342],
          [273, 335],
          [335, 424],
          [424, 273],
          [292, 325],
          [325, 307],
          [307, 292],
          [366, 447],
          [447, 345],
          [345, 366],
          [271, 303],
          [303, 302],
          [302, 271],
          [423, 266],
          [266, 371],
          [371, 423],
          [294, 455],
          [455, 460],
          [460, 294],
          [279, 278],
          [278, 294],
          [294, 279],
          [271, 272],
          [272, 304],
          [304, 271],
          [432, 434],
          [434, 427],
          [427, 432],
          [272, 407],
          [407, 408],
          [408, 272],
          [394, 430],
          [430, 431],
          [431, 394],
          [395, 369],
          [369, 400],
          [400, 395],
          [334, 333],
          [333, 299],
          [299, 334],
          [351, 417],
          [417, 168],
          [168, 351],
          [352, 280],
          [280, 411],
          [411, 352],
          [325, 319],
          [319, 320],
          [320, 325],
          [295, 296],
          [296, 336],
          [336, 295],
          [319, 403],
          [403, 404],
          [404, 319],
          [330, 348],
          [348, 349],
          [349, 330],
          [293, 298],
          [298, 333],
          [333, 293],
          [323, 454],
          [454, 447],
          [447, 323],
          [15, 16],
          [16, 315],
          [315, 15],
          [358, 429],
          [429, 279],
          [279, 358],
          [14, 15],
          [15, 316],
          [316, 14],
          [285, 336],
          [336, 9],
          [9, 285],
          [329, 349],
          [349, 350],
          [350, 329],
          [374, 380],
          [380, 252],
          [252, 374],
          [318, 402],
          [402, 403],
          [403, 318],
          [6, 197],
          [197, 419],
          [419, 6],
          [318, 319],
          [319, 325],
          [325, 318],
          [367, 364],
          [364, 365],
          [365, 367],
          [435, 367],
          [367, 397],
          [397, 435],
          [344, 438],
          [438, 439],
          [439, 344],
          [272, 271],
          [271, 311],
          [311, 272],
          [195, 5],
          [5, 281],
          [281, 195],
          [273, 287],
          [287, 291],
          [291, 273],
          [396, 428],
          [428, 199],
          [199, 396],
          [311, 271],
          [271, 268],
          [268, 311],
          [283, 444],
          [444, 445],
          [445, 283],
          [373, 254],
          [254, 339],
          [339, 373],
          [282, 334],
          [334, 296],
          [296, 282],
          [449, 347],
          [347, 346],
          [346, 449],
          [264, 447],
          [447, 454],
          [454, 264],
          [336, 296],
          [296, 299],
          [299, 336],
          [338, 10],
          [10, 151],
          [151, 338],
          [278, 439],
          [439, 455],
          [455, 278],
          [292, 407],
          [407, 415],
          [415, 292],
          [358, 371],
          [371, 355],
          [355, 358],
          [340, 345],
          [345, 372],
          [372, 340],
          [346, 347],
          [347, 280],
          [280, 346],
          [442, 443],
          [443, 282],
          [282, 442],
          [19, 94],
          [94, 370],
          [370, 19],
          [441, 442],
          [442, 295],
          [295, 441],
          [248, 419],
          [419, 197],
          [197, 248],
          [263, 255],
          [255, 359],
          [359, 263],
          [440, 275],
          [275, 274],
          [274, 440],
          [300, 383],
          [383, 368],
          [368, 300],
          [351, 412],
          [412, 465],
          [465, 351],
          [263, 467],
          [467, 466],
          [466, 263],
          [301, 368],
          [368, 389],
          [389, 301],
          [395, 378],
          [378, 379],
          [379, 395],
          [412, 351],
          [351, 419],
          [419, 412],
          [436, 426],
          [426, 322],
          [322, 436],
          [2, 164],
          [164, 393],
          [393, 2],
          [370, 462],
          [462, 461],
          [461, 370],
          [164, 0],
          [0, 267],
          [267, 164],
          [302, 11],
          [11, 12],
          [12, 302],
          [268, 12],
          [12, 13],
          [13, 268],
          [293, 300],
          [300, 301],
          [301, 293],
          [446, 261],
          [261, 340],
          [340, 446],
          [330, 266],
          [266, 425],
          [425, 330],
          [426, 423],
          [423, 391],
          [391, 426],
          [429, 355],
          [355, 437],
          [437, 429],
          [391, 327],
          [327, 326],
          [326, 391],
          [440, 457],
          [457, 438],
          [438, 440],
          [341, 382],
          [382, 362],
          [362, 341],
          [459, 457],
          [457, 461],
          [461, 459],
          [434, 430],
          [430, 394],
          [394, 434],
          [414, 463],
          [463, 362],
          [362, 414],
          [396, 369],
          [369, 262],
          [262, 396],
          [354, 461],
          [461, 457],
          [457, 354],
          [316, 403],
          [403, 402],
          [402, 316],
          [315, 404],
          [404, 403],
          [403, 315],
          [314, 405],
          [405, 404],
          [404, 314],
          [313, 406],
          [406, 405],
          [405, 313],
          [421, 418],
          [418, 406],
          [406, 421],
          [366, 401],
          [401, 361],
          [361, 366],
          [306, 408],
          [408, 407],
          [407, 306],
          [291, 409],
          [409, 408],
          [408, 291],
          [287, 410],
          [410, 409],
          [409, 287],
          [432, 436],
          [436, 410],
          [410, 432],
          [434, 416],
          [416, 411],
          [411, 434],
          [264, 368],
          [368, 383],
          [383, 264],
          [309, 438],
          [438, 457],
          [457, 309],
          [352, 376],
          [376, 401],
          [401, 352],
          [274, 275],
          [275, 4],
          [4, 274],
          [421, 428],
          [428, 262],
          [262, 421],
          [294, 327],
          [327, 358],
          [358, 294],
          [433, 416],
          [416, 367],
          [367, 433],
          [289, 455],
          [455, 439],
          [439, 289],
          [462, 370],
          [370, 326],
          [326, 462],
          [2, 326],
          [326, 370],
          [370, 2],
          [305, 460],
          [460, 455],
          [455, 305],
          [254, 449],
          [449, 448],
          [448, 254],
          [255, 261],
          [261, 446],
          [446, 255],
          [253, 450],
          [450, 449],
          [449, 253],
          [252, 451],
          [451, 450],
          [450, 252],
          [256, 452],
          [452, 451],
          [451, 256],
          [341, 453],
          [453, 452],
          [452, 341],
          [413, 464],
          [464, 463],
          [463, 413],
          [441, 413],
          [413, 414],
          [414, 441],
          [258, 442],
          [442, 441],
          [441, 258],
          [257, 443],
          [443, 442],
          [442, 257],
          [259, 444],
          [444, 443],
          [443, 259],
          [260, 445],
          [445, 444],
          [444, 260],
          [467, 342],
          [342, 445],
          [445, 467],
          [459, 458],
          [458, 250],
          [250, 459],
          [289, 392],
          [392, 290],
          [290, 289],
          [290, 328],
          [328, 460],
          [460, 290],
          [376, 433],
          [433, 435],
          [435, 376],
          [250, 290],
          [290, 392],
          [392, 250],
          [411, 416],
          [416, 433],
          [433, 411],
          [341, 463],
          [463, 464],
          [464, 341],
          [453, 464],
          [464, 465],
          [465, 453],
          [357, 465],
          [465, 412],
          [412, 357],
          [343, 412],
          [412, 399],
          [399, 343],
          [360, 363],
          [363, 440],
          [440, 360],
          [437, 399],
          [399, 456],
          [456, 437],
          [420, 456],
          [456, 363],
          [363, 420],
          [401, 435],
          [435, 288],
          [288, 401],
          [372, 383],
          [383, 353],
          [353, 372],
          [339, 255],
          [255, 249],
          [249, 339],
          [448, 261],
          [261, 255],
          [255, 448],
          [133, 243],
          [243, 190],
          [190, 133],
          [133, 155],
          [155, 112],
          [112, 133],
          [33, 246],
          [246, 247],
          [247, 33],
          [33, 130],
          [130, 25],
          [25, 33],
          [398, 384],
          [384, 286],
          [286, 398],
          [362, 398],
          [398, 414],
          [414, 362],
          [362, 463],
          [463, 341],
          [341, 362],
          [263, 359],
          [359, 467],
          [467, 263],
          [263, 249],
          [249, 255],
          [255, 263],
          [466, 467],
          [467, 260],
          [260, 466],
          [75, 60],
          [60, 166],
          [166, 75],
          [238, 239],
          [239, 79],
          [79, 238],
          [162, 127],
          [127, 139],
          [139, 162],
          [72, 11],
          [11, 37],
          [37, 72],
          [121, 232],
          [232, 120],
          [120, 121],
          [73, 72],
          [72, 39],
          [39, 73],
          [114, 128],
          [128, 47],
          [47, 114],
          [233, 232],
          [232, 128],
          [128, 233],
          [103, 104],
          [104, 67],
          [67, 103],
          [152, 175],
          [175, 148],
          [148, 152],
          [119, 118],
          [118, 101],
          [101, 119],
          [74, 73],
          [73, 40],
          [40, 74],
          [107, 9],
          [9, 108],
          [108, 107],
          [49, 48],
          [48, 131],
          [131, 49],
          [32, 194],
          [194, 211],
          [211, 32],
          [184, 74],
          [74, 185],
          [185, 184],
          [191, 80],
          [80, 183],
          [183, 191],
          [185, 40],
          [40, 186],
          [186, 185],
          [119, 230],
          [230, 118],
          [118, 119],
          [210, 202],
          [202, 214],
          [214, 210],
          [84, 83],
          [83, 17],
          [17, 84],
          [77, 76],
          [76, 146],
          [146, 77],
          [161, 160],
          [160, 30],
          [30, 161],
          [190, 56],
          [56, 173],
          [173, 190],
          [182, 106],
          [106, 194],
          [194, 182],
          [138, 135],
          [135, 192],
          [192, 138],
          [129, 203],
          [203, 98],
          [98, 129],
          [54, 21],
          [21, 68],
          [68, 54],
          [5, 51],
          [51, 4],
          [4, 5],
          [145, 144],
          [144, 23],
          [23, 145],
          [90, 77],
          [77, 91],
          [91, 90],
          [207, 205],
          [205, 187],
          [187, 207],
          [83, 201],
          [201, 18],
          [18, 83],
          [181, 91],
          [91, 182],
          [182, 181],
          [180, 90],
          [90, 181],
          [181, 180],
          [16, 85],
          [85, 17],
          [17, 16],
          [205, 206],
          [206, 36],
          [36, 205],
          [176, 148],
          [148, 140],
          [140, 176],
          [165, 92],
          [92, 39],
          [39, 165],
          [245, 193],
          [193, 244],
          [244, 245],
          [27, 159],
          [159, 28],
          [28, 27],
          [30, 247],
          [247, 161],
          [161, 30],
          [174, 236],
          [236, 196],
          [196, 174],
          [103, 54],
          [54, 104],
          [104, 103],
          [55, 193],
          [193, 8],
          [8, 55],
          [111, 117],
          [117, 31],
          [31, 111],
          [221, 189],
          [189, 55],
          [55, 221],
          [240, 98],
          [98, 99],
          [99, 240],
          [142, 126],
          [126, 100],
          [100, 142],
          [219, 166],
          [166, 218],
          [218, 219],
          [112, 155],
          [155, 26],
          [26, 112],
          [198, 209],
          [209, 131],
          [131, 198],
          [169, 135],
          [135, 150],
          [150, 169],
          [114, 47],
          [47, 217],
          [217, 114],
          [224, 223],
          [223, 53],
          [53, 224],
          [220, 45],
          [45, 134],
          [134, 220],
          [32, 211],
          [211, 140],
          [140, 32],
          [109, 67],
          [67, 108],
          [108, 109],
          [146, 43],
          [43, 91],
          [91, 146],
          [231, 230],
          [230, 120],
          [120, 231],
          [113, 226],
          [226, 247],
          [247, 113],
          [105, 63],
          [63, 52],
          [52, 105],
          [241, 238],
          [238, 242],
          [242, 241],
          [124, 46],
          [46, 156],
          [156, 124],
          [95, 78],
          [78, 96],
          [96, 95],
          [70, 46],
          [46, 63],
          [63, 70],
          [116, 143],
          [143, 227],
          [227, 116],
          [116, 123],
          [123, 111],
          [111, 116],
          [1, 44],
          [44, 19],
          [19, 1],
          [3, 236],
          [236, 51],
          [51, 3],
          [207, 216],
          [216, 205],
          [205, 207],
          [26, 154],
          [154, 22],
          [22, 26],
          [165, 39],
          [39, 167],
          [167, 165],
          [199, 200],
          [200, 208],
          [208, 199],
          [101, 36],
          [36, 100],
          [100, 101],
          [43, 57],
          [57, 202],
          [202, 43],
          [242, 20],
          [20, 99],
          [99, 242],
          [56, 28],
          [28, 157],
          [157, 56],
          [124, 35],
          [35, 113],
          [113, 124],
          [29, 160],
          [160, 27],
          [27, 29],
          [211, 204],
          [204, 210],
          [210, 211],
          [124, 113],
          [113, 46],
          [46, 124],
          [106, 43],
          [43, 204],
          [204, 106],
          [96, 62],
          [62, 77],
          [77, 96],
          [227, 137],
          [137, 116],
          [116, 227],
          [73, 41],
          [41, 72],
          [72, 73],
          [36, 203],
          [203, 142],
          [142, 36],
          [235, 64],
          [64, 240],
          [240, 235],
          [48, 49],
          [49, 64],
          [64, 48],
          [42, 41],
          [41, 74],
          [74, 42],
          [214, 212],
          [212, 207],
          [207, 214],
          [183, 42],
          [42, 184],
          [184, 183],
          [210, 169],
          [169, 211],
          [211, 210],
          [140, 170],
          [170, 176],
          [176, 140],
          [104, 105],
          [105, 69],
          [69, 104],
          [193, 122],
          [122, 168],
          [168, 193],
          [50, 123],
          [123, 187],
          [187, 50],
          [89, 96],
          [96, 90],
          [90, 89],
          [66, 65],
          [65, 107],
          [107, 66],
          [179, 89],
          [89, 180],
          [180, 179],
          [119, 101],
          [101, 120],
          [120, 119],
          [68, 63],
          [63, 104],
          [104, 68],
          [234, 93],
          [93, 227],
          [227, 234],
          [16, 15],
          [15, 85],
          [85, 16],
          [209, 129],
          [129, 49],
          [49, 209],
          [15, 14],
          [14, 86],
          [86, 15],
          [107, 55],
          [55, 9],
          [9, 107],
          [120, 100],
          [100, 121],
          [121, 120],
          [153, 145],
          [145, 22],
          [22, 153],
          [178, 88],
          [88, 179],
          [179, 178],
          [197, 6],
          [6, 196],
          [196, 197],
          [89, 88],
          [88, 96],
          [96, 89],
          [135, 138],
          [138, 136],
          [136, 135],
          [138, 215],
          [215, 172],
          [172, 138],
          [218, 115],
          [115, 219],
          [219, 218],
          [41, 42],
          [42, 81],
          [81, 41],
          [5, 195],
          [195, 51],
          [51, 5],
          [57, 43],
          [43, 61],
          [61, 57],
          [208, 171],
          [171, 199],
          [199, 208],
          [41, 81],
          [81, 38],
          [38, 41],
          [224, 53],
          [53, 225],
          [225, 224],
          [24, 144],
          [144, 110],
          [110, 24],
          [105, 52],
          [52, 66],
          [66, 105],
          [118, 229],
          [229, 117],
          [117, 118],
          [227, 34],
          [34, 234],
          [234, 227],
          [66, 107],
          [107, 69],
          [69, 66],
          [10, 109],
          [109, 151],
          [151, 10],
          [219, 48],
          [48, 235],
          [235, 219],
          [183, 62],
          [62, 191],
          [191, 183],
          [142, 129],
          [129, 126],
          [126, 142],
          [116, 111],
          [111, 143],
          [143, 116],
          [118, 117],
          [117, 50],
          [50, 118],
          [223, 222],
          [222, 52],
          [52, 223],
          [94, 19],
          [19, 141],
          [141, 94],
          [222, 221],
          [221, 65],
          [65, 222],
          [196, 3],
          [3, 197],
          [197, 196],
          [45, 220],
          [220, 44],
          [44, 45],
          [156, 70],
          [70, 139],
          [139, 156],
          [188, 122],
          [122, 245],
          [245, 188],
          [139, 71],
          [71, 162],
          [162, 139],
          [149, 170],
          [170, 150],
          [150, 149],
          [122, 188],
          [188, 196],
          [196, 122],
          [206, 216],
          [216, 92],
          [92, 206],
          [164, 2],
          [2, 167],
          [167, 164],
          [242, 141],
          [141, 241],
          [241, 242],
          [0, 164],
          [164, 37],
          [37, 0],
          [11, 72],
          [72, 12],
          [12, 11],
          [12, 38],
          [38, 13],
          [13, 12],
          [70, 63],
          [63, 71],
          [71, 70],
          [31, 226],
          [226, 111],
          [111, 31],
          [36, 101],
          [101, 205],
          [205, 36],
          [203, 206],
          [206, 165],
          [165, 203],
          [126, 209],
          [209, 217],
          [217, 126],
          [98, 165],
          [165, 97],
          [97, 98],
          [237, 220],
          [220, 218],
          [218, 237],
          [237, 239],
          [239, 241],
          [241, 237],
          [210, 214],
          [214, 169],
          [169, 210],
          [140, 171],
          [171, 32],
          [32, 140],
          [241, 125],
          [125, 237],
          [237, 241],
          [179, 86],
          [86, 178],
          [178, 179],
          [180, 85],
          [85, 179],
          [179, 180],
          [181, 84],
          [84, 180],
          [180, 181],
          [182, 83],
          [83, 181],
          [181, 182],
          [194, 201],
          [201, 182],
          [182, 194],
          [177, 137],
          [137, 132],
          [132, 177],
          [184, 76],
          [76, 183],
          [183, 184],
          [185, 61],
          [61, 184],
          [184, 185],
          [186, 57],
          [57, 185],
          [185, 186],
          [216, 212],
          [212, 186],
          [186, 216],
          [192, 214],
          [214, 187],
          [187, 192],
          [139, 34],
          [34, 156],
          [156, 139],
          [218, 79],
          [79, 237],
          [237, 218],
          [147, 123],
          [123, 177],
          [177, 147],
          [45, 44],
          [44, 4],
          [4, 45],
          [208, 201],
          [201, 32],
          [32, 208],
          [98, 64],
          [64, 129],
          [129, 98],
          [192, 213],
          [213, 138],
          [138, 192],
          [235, 59],
          [59, 219],
          [219, 235],
          [141, 242],
          [242, 97],
          [97, 141],
          [97, 2],
          [2, 141],
          [141, 97],
          [240, 75],
          [75, 235],
          [235, 240],
          [229, 24],
          [24, 228],
          [228, 229],
          [31, 25],
          [25, 226],
          [226, 31],
          [230, 23],
          [23, 229],
          [229, 230],
          [231, 22],
          [22, 230],
          [230, 231],
          [232, 26],
          [26, 231],
          [231, 232],
          [233, 112],
          [112, 232],
          [232, 233],
          [244, 189],
          [189, 243],
          [243, 244],
          [189, 221],
          [221, 190],
          [190, 189],
          [222, 28],
          [28, 221],
          [221, 222],
          [223, 27],
          [27, 222],
          [222, 223],
          [224, 29],
          [29, 223],
          [223, 224],
          [225, 30],
          [30, 224],
          [224, 225],
          [113, 247],
          [247, 225],
          [225, 113],
          [99, 60],
          [60, 240],
          [240, 99],
          [213, 147],
          [147, 215],
          [215, 213],
          [60, 20],
          [20, 166],
          [166, 60],
          [192, 187],
          [187, 213],
          [213, 192],
          [243, 112],
          [112, 244],
          [244, 243],
          [244, 233],
          [233, 245],
          [245, 244],
          [245, 128],
          [128, 188],
          [188, 245],
          [188, 114],
          [114, 174],
          [174, 188],
          [134, 131],
          [131, 220],
          [220, 134],
          [174, 217],
          [217, 236],
          [236, 174],
          [236, 198],
          [198, 134],
          [134, 236],
          [215, 177],
          [177, 58],
          [58, 215],
          [156, 143],
          [143, 124],
          [124, 156],
          [25, 110],
          [110, 7],
          [7, 25],
          [31, 228],
          [228, 25],
          [25, 31],
          [264, 356],
          [356, 368],
          [368, 264],
          [0, 11],
          [11, 267],
          [267, 0],
          [451, 452],
          [452, 349],
          [349, 451],
          [267, 302],
          [302, 269],
          [269, 267],
          [350, 357],
          [357, 277],
          [277, 350],
          [350, 452],
          [452, 357],
          [357, 350],
          [299, 333],
          [333, 297],
          [297, 299],
          [396, 175],
          [175, 377],
          [377, 396],
          [280, 347],
          [347, 330],
          [330, 280],
          [269, 303],
          [303, 270],
          [270, 269],
          [151, 9],
          [9, 337],
          [337, 151],
          [344, 278],
          [278, 360],
          [360, 344],
          [424, 418],
          [418, 431],
          [431, 424],
          [270, 304],
          [304, 409],
          [409, 270],
          [272, 310],
          [310, 407],
          [407, 272],
          [322, 270],
          [270, 410],
          [410, 322],
          [449, 450],
          [450, 347],
          [347, 449],
          [432, 422],
          [422, 434],
          [434, 432],
          [18, 313],
          [313, 17],
          [17, 18],
          [291, 306],
          [306, 375],
          [375, 291],
          [259, 387],
          [387, 260],
          [260, 259],
          [424, 335],
          [335, 418],
          [418, 424],
          [434, 364],
          [364, 416],
          [416, 434],
          [391, 423],
          [423, 327],
          [327, 391],
          [301, 251],
          [251, 298],
          [298, 301],
          [275, 281],
          [281, 4],
          [4, 275],
          [254, 373],
          [373, 253],
          [253, 254],
          [375, 307],
          [307, 321],
          [321, 375],
          [280, 425],
          [425, 411],
          [411, 280],
          [200, 421],
          [421, 18],
          [18, 200],
          [335, 321],
          [321, 406],
          [406, 335],
          [321, 320],
          [320, 405],
          [405, 321],
          [314, 315],
          [315, 17],
          [17, 314],
          [423, 426],
          [426, 266],
          [266, 423],
          [396, 377],
          [377, 369],
          [369, 396],
          [270, 322],
          [322, 269],
          [269, 270],
          [413, 417],
          [417, 464],
          [464, 413],
          [385, 386],
          [386, 258],
          [258, 385],
          [248, 456],
          [456, 419],
          [419, 248],
          [298, 284],
          [284, 333],
          [333, 298],
          [168, 417],
          [417, 8],
          [8, 168],
          [448, 346],
          [346, 261],
          [261, 448],
          [417, 413],
          [413, 285],
          [285, 417],
          [326, 327],
          [327, 328],
          [328, 326],
          [277, 355],
          [355, 329],
          [329, 277],
          [309, 392],
          [392, 438],
          [438, 309],
          [381, 382],
          [382, 256],
          [256, 381],
          [279, 429],
          [429, 360],
          [360, 279],
          [365, 364],
          [364, 379],
          [379, 365],
          [355, 277],
          [277, 437],
          [437, 355],
          [282, 443],
          [443, 283],
          [283, 282],
          [281, 275],
          [275, 363],
          [363, 281],
          [395, 431],
          [431, 369],
          [369, 395],
          [299, 297],
          [297, 337],
          [337, 299],
          [335, 273],
          [273, 321],
          [321, 335],
          [348, 450],
          [450, 349],
          [349, 348],
          [359, 446],
          [446, 467],
          [467, 359],
          [283, 293],
          [293, 282],
          [282, 283],
          [250, 458],
          [458, 462],
          [462, 250],
          [300, 276],
          [276, 383],
          [383, 300],
          [292, 308],
          [308, 325],
          [325, 292],
          [283, 276],
          [276, 293],
          [293, 283],
          [264, 372],
          [372, 447],
          [447, 264],
          [346, 352],
          [352, 340],
          [340, 346],
          [354, 274],
          [274, 19],
          [19, 354],
          [363, 456],
          [456, 281],
          [281, 363],
          [426, 436],
          [436, 425],
          [425, 426],
          [380, 381],
          [381, 252],
          [252, 380],
          [267, 269],
          [269, 393],
          [393, 267],
          [421, 200],
          [200, 428],
          [428, 421],
          [371, 266],
          [266, 329],
          [329, 371],
          [432, 287],
          [287, 422],
          [422, 432],
          [290, 250],
          [250, 328],
          [328, 290],
          [385, 258],
          [258, 384],
          [384, 385],
          [446, 265],
          [265, 342],
          [342, 446],
          [386, 387],
          [387, 257],
          [257, 386],
          [422, 424],
          [424, 430],
          [430, 422],
          [445, 342],
          [342, 276],
          [276, 445],
          [422, 273],
          [273, 424],
          [424, 422],
          [306, 292],
          [292, 307],
          [307, 306],
          [352, 366],
          [366, 345],
          [345, 352],
          [268, 271],
          [271, 302],
          [302, 268],
          [358, 423],
          [423, 371],
          [371, 358],
          [327, 294],
          [294, 460],
          [460, 327],
          [331, 279],
          [279, 294],
          [294, 331],
          [303, 271],
          [271, 304],
          [304, 303],
          [436, 432],
          [432, 427],
          [427, 436],
          [304, 272],
          [272, 408],
          [408, 304],
          [395, 394],
          [394, 431],
          [431, 395],
          [378, 395],
          [395, 400],
          [400, 378],
          [296, 334],
          [334, 299],
          [299, 296],
          [6, 351],
          [351, 168],
          [168, 6],
          [376, 352],
          [352, 411],
          [411, 376],
          [307, 325],
          [325, 320],
          [320, 307],
          [285, 295],
          [295, 336],
          [336, 285],
          [320, 319],
          [319, 404],
          [404, 320],
          [329, 330],
          [330, 349],
          [349, 329],
          [334, 293],
          [293, 333],
          [333, 334],
          [366, 323],
          [323, 447],
          [447, 366],
          [316, 15],
          [15, 315],
          [315, 316],
          [331, 358],
          [358, 279],
          [279, 331],
          [317, 14],
          [14, 316],
          [316, 317],
          [8, 285],
          [285, 9],
          [9, 8],
          [277, 329],
          [329, 350],
          [350, 277],
          [253, 374],
          [374, 252],
          [252, 253],
          [319, 318],
          [318, 403],
          [403, 319],
          [351, 6],
          [6, 419],
          [419, 351],
          [324, 318],
          [318, 325],
          [325, 324],
          [397, 367],
          [367, 365],
          [365, 397],
          [288, 435],
          [435, 397],
          [397, 288],
          [278, 344],
          [344, 439],
          [439, 278],
          [310, 272],
          [272, 311],
          [311, 310],
          [248, 195],
          [195, 281],
          [281, 248],
          [375, 273],
          [273, 291],
          [291, 375],
          [175, 396],
          [396, 199],
          [199, 175],
          [312, 311],
          [311, 268],
          [268, 312],
          [276, 283],
          [283, 445],
          [445, 276],
          [390, 373],
          [373, 339],
          [339, 390],
          [295, 282],
          [282, 296],
          [296, 295],
          [448, 449],
          [449, 346],
          [346, 448],
          [356, 264],
          [264, 454],
          [454, 356],
          [337, 336],
          [336, 299],
          [299, 337],
          [337, 338],
          [338, 151],
          [151, 337],
          [294, 278],
          [278, 455],
          [455, 294],
          [308, 292],
          [292, 415],
          [415, 308],
          [429, 358],
          [358, 355],
          [355, 429],
          [265, 340],
          [340, 372],
          [372, 265],
          [352, 346],
          [346, 280],
          [280, 352],
          [295, 442],
          [442, 282],
          [282, 295],
          [354, 19],
          [19, 370],
          [370, 354],
          [285, 441],
          [441, 295],
          [295, 285],
          [195, 248],
          [248, 197],
          [197, 195],
          [457, 440],
          [440, 274],
          [274, 457],
          [301, 300],
          [300, 368],
          [368, 301],
          [417, 351],
          [351, 465],
          [465, 417],
          [251, 301],
          [301, 389],
          [389, 251],
          [394, 395],
          [395, 379],
          [379, 394],
          [399, 412],
          [412, 419],
          [419, 399],
          [410, 436],
          [436, 322],
          [322, 410],
          [326, 2],
          [2, 393],
          [393, 326],
          [354, 370],
          [370, 461],
          [461, 354],
          [393, 164],
          [164, 267],
          [267, 393],
          [268, 302],
          [302, 12],
          [12, 268],
          [312, 268],
          [268, 13],
          [13, 312],
          [298, 293],
          [293, 301],
          [301, 298],
          [265, 446],
          [446, 340],
          [340, 265],
          [280, 330],
          [330, 425],
          [425, 280],
          [322, 426],
          [426, 391],
          [391, 322],
          [420, 429],
          [429, 437],
          [437, 420],
          [393, 391],
          [391, 326],
          [326, 393],
          [344, 440],
          [440, 438],
          [438, 344],
          [458, 459],
          [459, 461],
          [461, 458],
          [364, 434],
          [434, 394],
          [394, 364],
          [428, 396],
          [396, 262],
          [262, 428],
          [274, 354],
          [354, 457],
          [457, 274],
          [317, 316],
          [316, 402],
          [402, 317],
          [316, 315],
          [315, 403],
          [403, 316],
          [315, 314],
          [314, 404],
          [404, 315],
          [314, 313],
          [313, 405],
          [405, 314],
          [313, 421],
          [421, 406],
          [406, 313],
          [323, 366],
          [366, 361],
          [361, 323],
          [292, 306],
          [306, 407],
          [407, 292],
          [306, 291],
          [291, 408],
          [408, 306],
          [291, 287],
          [287, 409],
          [409, 291],
          [287, 432],
          [432, 410],
          [410, 287],
          [427, 434],
          [434, 411],
          [411, 427],
          [372, 264],
          [264, 383],
          [383, 372],
          [459, 309],
          [309, 457],
          [457, 459],
          [366, 352],
          [352, 401],
          [401, 366],
          [1, 274],
          [274, 4],
          [4, 1],
          [418, 421],
          [421, 262],
          [262, 418],
          [331, 294],
          [294, 358],
          [358, 331],
          [435, 433],
          [433, 367],
          [367, 435],
          [392, 289],
          [289, 439],
          [439, 392],
          [328, 462],
          [462, 326],
          [326, 328],
          [94, 2],
          [2, 370],
          [370, 94],
          [289, 305],
          [305, 455],
          [455, 289],
          [339, 254],
          [254, 448],
          [448, 339],
          [359, 255],
          [255, 446],
          [446, 359],
          [254, 253],
          [253, 449],
          [449, 254],
          [253, 252],
          [252, 450],
          [450, 253],
          [252, 256],
          [256, 451],
          [451, 252],
          [256, 341],
          [341, 452],
          [452, 256],
          [414, 413],
          [413, 463],
          [463, 414],
          [286, 441],
          [441, 414],
          [414, 286],
          [286, 258],
          [258, 441],
          [441, 286],
          [258, 257],
          [257, 442],
          [442, 258],
          [257, 259],
          [259, 443],
          [443, 257],
          [259, 260],
          [260, 444],
          [444, 259],
          [260, 467],
          [467, 445],
          [445, 260],
          [309, 459],
          [459, 250],
          [250, 309],
          [305, 289],
          [289, 290],
          [290, 305],
          [305, 290],
          [290, 460],
          [460, 305],
          [401, 376],
          [376, 435],
          [435, 401],
          [309, 250],
          [250, 392],
          [392, 309],
          [376, 411],
          [411, 433],
          [433, 376],
          [453, 341],
          [341, 464],
          [464, 453],
          [357, 453],
          [453, 465],
          [465, 357],
          [343, 357],
          [357, 412],
          [412, 343],
          [437, 343],
          [343, 399],
          [399, 437],
          [344, 360],
          [360, 440],
          [440, 344],
          [420, 437],
          [437, 456],
          [456, 420],
          [360, 420],
          [420, 363],
          [363, 360],
          [361, 401],
          [401, 288],
          [288, 361],
          [265, 372],
          [372, 353],
          [353, 265],
          [390, 339],
          [339, 249],
          [249, 390],
          [339, 448],
          [448, 255],
          [255, 339]
        );
      function rf(n) {
        n.j = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] };
      }
      var Ct = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "image_in", "norm_rect", !1),
            (this.j = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] }),
            (this.outputFacialTransformationMatrixes = this.outputFaceBlendshapes = !1),
            De((n = this.h = new Am()), 0, 1, (e = new Tt())),
            (this.v = new rm()),
            De(this.h, 0, 3, this.v),
            (this.s = new ha()),
            De(this.h, 0, 2, this.s),
            ui(this.s, 4, 1),
            Pe(this.s, 2, 0.5),
            Pe(this.v, 2, 0.5),
            Pe(this.h, 4, 0.5);
        }
        get baseOptions() {
          return Je(this.h, Tt, 1);
        }
        set baseOptions(n) {
          De(this.h, 0, 1, n);
        }
        o(n) {
          return (
            "numFaces" in n && ui(this.s, 4, n.numFaces ?? 1),
            "minFaceDetectionConfidence" in n && Pe(this.s, 2, n.minFaceDetectionConfidence ?? 0.5),
            "minTrackingConfidence" in n && Pe(this.h, 4, n.minTrackingConfidence ?? 0.5),
            "minFacePresenceConfidence" in n && Pe(this.v, 2, n.minFacePresenceConfidence ?? 0.5),
            "outputFaceBlendshapes" in n && (this.outputFaceBlendshapes = !!n.outputFaceBlendshapes),
            "outputFacialTransformationMatrixes" in n && (this.outputFacialTransformationMatrixes = !!n.outputFacialTransformationMatrixes),
            this.l(n)
          );
        }
        D(n, e) {
          return rf(this), Hn(this, n, e), this.j;
        }
        F(n, e, t) {
          return rf(this), di(this, n, t, e), this.j;
        }
        m() {
          var n = new pn();
          wt(n, "image_in"), wt(n, "norm_rect"), et(n, "face_landmarks");
          const e = new Mn();
          Zn(e, kP, this.h);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"),
            gt(t, "IMAGE:image_in"),
            gt(t, "NORM_RECT:norm_rect"),
            Ye(t, "NORM_LANDMARKS:face_landmarks"),
            t.o(e),
            In(n, t),
            this.g.attachProtoVectorListener("face_landmarks", (i, s) => {
              for (const r of i) (i = zA(r)), this.j.faceLandmarks.push(fa(i));
              ce(this, s);
            }),
            this.g.attachEmptyPacketListener("face_landmarks", (i) => {
              ce(this, i);
            }),
            this.outputFaceBlendshapes &&
              (et(n, "blendshapes"),
              Ye(t, "BLENDSHAPES:blendshapes"),
              this.g.attachProtoVectorListener("blendshapes", (i, s) => {
                if (this.outputFaceBlendshapes) for (const r of i) (i = ua(r)), this.j.faceBlendshapes.push(Tu(i.g() ?? []));
                ce(this, s);
              }),
              this.g.attachEmptyPacketListener("blendshapes", (i) => {
                ce(this, i);
              })),
            this.outputFacialTransformationMatrixes &&
              (et(n, "face_geometry"),
              Ye(t, "FACE_GEOMETRY:face_geometry"),
              this.g.attachProtoVectorListener("face_geometry", (i, s) => {
                if (this.outputFacialTransformationMatrixes)
                  for (const r of i)
                    (i = Je(NP(r), IP, 2)) &&
                      this.j.facialTransformationMatrixes.push({
                        rows: Nn(i, 1) ?? 0 ?? 0,
                        columns: Nn(i, 2) ?? 0 ?? 0,
                        data: Is(i, 3, us, Ss()).slice() ?? [],
                      });
                ce(this, s);
              }),
              this.g.attachEmptyPacketListener("face_geometry", (i) => {
                ce(this, i);
              })),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (Ct.prototype.detectForVideo = Ct.prototype.F),
        (Ct.prototype.detect = Ct.prototype.D),
        (Ct.prototype.setOptions = Ct.prototype.o),
        (Ct.createFromModelPath = function (n, e) {
          return Ke(Ct, n, { baseOptions: { modelAssetPath: e } });
        }),
        (Ct.createFromModelBuffer = function (n, e) {
          return Ke(Ct, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (Ct.createFromOptions = function (n, e) {
          return Ke(Ct, n, e);
        }),
        (Ct.FACE_LANDMARKS_LIPS = Iu),
        (Ct.FACE_LANDMARKS_LEFT_EYE = bu),
        (Ct.FACE_LANDMARKS_LEFT_EYEBROW = zu),
        (Ct.FACE_LANDMARKS_LEFT_IRIS = Rm),
        (Ct.FACE_LANDMARKS_RIGHT_EYE = Ru),
        (Ct.FACE_LANDMARKS_RIGHT_EYEBROW = Bu),
        (Ct.FACE_LANDMARKS_RIGHT_IRIS = Bm),
        (Ct.FACE_LANDMARKS_FACE_OVAL = Ou),
        (Ct.FACE_LANDMARKS_CONTOURS = Om),
        (Ct.FACE_LANDMARKS_TESSELATION = Lm);
      var si = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "image_in", "norm_rect", !0), De((n = this.j = new am()), 0, 1, (e = new Tt()));
        }
        get baseOptions() {
          return Je(this.j, Tt, 1);
        }
        set baseOptions(n) {
          De(this.j, 0, 1, n);
        }
        o(n) {
          return super.l(n);
        }
        Ka(n, e, t) {
          const i = typeof e != "function" ? e : {};
          if (((this.h = typeof e == "function" ? e : t), Hn(this, n, i ?? {}), !this.h)) return this.s;
        }
        m() {
          var n = new pn();
          wt(n, "image_in"), wt(n, "norm_rect"), et(n, "stylized_image");
          const e = new Mn();
          Zn(e, GP, this.j);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"),
            gt(t, "IMAGE:image_in"),
            gt(t, "NORM_RECT:norm_rect"),
            Ye(t, "STYLIZED_IMAGE:stylized_image"),
            t.o(e),
            In(n, t),
            this.g.V("stylized_image", (i, s) => {
              var r = !this.h,
                A = i.data,
                o = i.width;
              const a = o * (i = i.height);
              if (A instanceof Uint8Array)
                if (A.length === 3 * a) {
                  const c = new Uint8ClampedArray(4 * a);
                  for (let l = 0; l < a; ++l) (c[4 * l] = A[3 * l]), (c[4 * l + 1] = A[3 * l + 1]), (c[4 * l + 2] = A[3 * l + 2]), (c[4 * l + 3] = 255);
                  A = new ImageData(c, o, i);
                } else {
                  if (A.length !== 4 * a) throw Error("Unsupported channel count: " + A.length / a);
                  A = new ImageData(new Uint8ClampedArray(A.buffer, A.byteOffset, A.length), o, i);
                }
              else if (!(A instanceof WebGLTexture)) throw Error(`Unsupported format: ${A.constructor.name}`);
              (o = new Wt([A], !1, !1, this.g.i.canvas, this.P, o, i)), (this.s = r = r ? o.clone() : o), this.h && this.h(r), ce(this, s);
            }),
            this.g.attachEmptyPacketListener("stylized_image", (i) => {
              (this.s = null), this.h && this.h(null), ce(this, i);
            }),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (si.prototype.stylize = si.prototype.Ka),
        (si.prototype.setOptions = si.prototype.o),
        (si.createFromModelPath = function (n, e) {
          return Ke(si, n, { baseOptions: { modelAssetPath: e } });
        }),
        (si.createFromModelBuffer = function (n, e) {
          return Ke(si, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (si.createFromOptions = function (n, e) {
          return Ke(si, n, e);
        });
      var Lu = ti(
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 4],
        [0, 5],
        [5, 6],
        [6, 7],
        [7, 8],
        [5, 9],
        [9, 10],
        [10, 11],
        [11, 12],
        [9, 13],
        [13, 14],
        [14, 15],
        [15, 16],
        [13, 17],
        [0, 17],
        [17, 18],
        [18, 19],
        [19, 20]
      );
      function Af(n) {
        (n.gestures = []), (n.landmarks = []), (n.worldLandmarks = []), (n.handedness = []);
      }
      function of(n) {
        return n.gestures.length === 0
          ? { gestures: [], landmarks: [], worldLandmarks: [], handedness: [], handednesses: [] }
          : { gestures: n.gestures, landmarks: n.landmarks, worldLandmarks: n.worldLandmarks, handedness: n.handedness, handednesses: n.handedness };
      }
      function af(n, e = !0) {
        const t = [];
        for (const s of n) {
          var i = ua(s);
          n = [];
          for (const r of i.g())
            (i = e && Nn(r, 1) != null ? Nn(r, 1) ?? 0 : -1),
              n.push({ score: Bt(r, 2) ?? 0, index: i, categoryName: Gn(r, 3) ?? "" ?? "", displayName: Gn(r, 4) ?? "" ?? "" });
          t.push(n);
        }
        return t;
      }
      var Pn = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "image_in", "norm_rect", !1),
            (this.gestures = []),
            (this.landmarks = []),
            (this.worldLandmarks = []),
            (this.handedness = []),
            De((n = this.j = new um()), 0, 1, (e = new Tt())),
            (this.s = new wu()),
            De(this.j, 0, 2, this.s),
            (this.C = new vu()),
            De(this.s, 0, 3, this.C),
            (this.v = new lm()),
            De(this.s, 0, 2, this.v),
            (this.h = new jP()),
            De(this.j, 0, 3, this.h),
            Pe(this.v, 2, 0.5),
            Pe(this.s, 4, 0.5),
            Pe(this.C, 2, 0.5);
        }
        get baseOptions() {
          return Je(this.j, Tt, 1);
        }
        set baseOptions(n) {
          De(this.j, 0, 1, n);
        }
        o(n) {
          if (
            (ui(this.v, 3, n.numHands ?? 1),
            "minHandDetectionConfidence" in n && Pe(this.v, 2, n.minHandDetectionConfidence ?? 0.5),
            "minTrackingConfidence" in n && Pe(this.s, 4, n.minTrackingConfidence ?? 0.5),
            "minHandPresenceConfidence" in n && Pe(this.C, 2, n.minHandPresenceConfidence ?? 0.5),
            n.cannedGesturesClassifierOptions)
          ) {
            var e = new Gs(),
              t = e,
              i = Uc(n.cannedGesturesClassifierOptions, Je(this.h, Gs, 3)?.h());
            De(t, 0, 2, i), De(this.h, 0, 3, e);
          } else n.cannedGesturesClassifierOptions === void 0 && Je(this.h, Gs, 3)?.g();
          return (
            n.customGesturesClassifierOptions
              ? (De((t = e = new Gs()), 0, 2, (i = Uc(n.customGesturesClassifierOptions, Je(this.h, Gs, 4)?.h()))), De(this.h, 0, 4, e))
              : n.customGesturesClassifierOptions === void 0 && Je(this.h, Gs, 4)?.g(),
            this.l(n)
          );
        }
        Fa(n, e) {
          return Af(this), Hn(this, n, e), of(this);
        }
        Ga(n, e, t) {
          return Af(this), di(this, n, t, e), of(this);
        }
        m() {
          var n = new pn();
          wt(n, "image_in"), wt(n, "norm_rect"), et(n, "hand_gestures"), et(n, "hand_landmarks"), et(n, "world_hand_landmarks"), et(n, "handedness");
          const e = new Mn();
          Zn(e, HP, this.j);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"),
            gt(t, "IMAGE:image_in"),
            gt(t, "NORM_RECT:norm_rect"),
            Ye(t, "HAND_GESTURES:hand_gestures"),
            Ye(t, "LANDMARKS:hand_landmarks"),
            Ye(t, "WORLD_LANDMARKS:world_hand_landmarks"),
            Ye(t, "HANDEDNESS:handedness"),
            t.o(e),
            In(n, t),
            this.g.attachProtoVectorListener("hand_landmarks", (i, s) => {
              for (const r of i) {
                i = zA(r);
                const A = [];
                for (const o of Fi(i, em, 1)) A.push({ x: Bt(o, 1) ?? 0, y: Bt(o, 2) ?? 0, z: Bt(o, 3) ?? 0, visibility: Bt(o, 4) ?? 0 });
                this.landmarks.push(A);
              }
              ce(this, s);
            }),
            this.g.attachEmptyPacketListener("hand_landmarks", (i) => {
              ce(this, i);
            }),
            this.g.attachProtoVectorListener("world_hand_landmarks", (i, s) => {
              for (const r of i) {
                i = cr(r);
                const A = [];
                for (const o of Fi(i, $p, 1)) A.push({ x: Bt(o, 1) ?? 0, y: Bt(o, 2) ?? 0, z: Bt(o, 3) ?? 0, visibility: Bt(o, 4) ?? 0 });
                this.worldLandmarks.push(A);
              }
              ce(this, s);
            }),
            this.g.attachEmptyPacketListener("world_hand_landmarks", (i) => {
              ce(this, i);
            }),
            this.g.attachProtoVectorListener("hand_gestures", (i, s) => {
              this.gestures.push(...af(i, !1)), ce(this, s);
            }),
            this.g.attachEmptyPacketListener("hand_gestures", (i) => {
              ce(this, i);
            }),
            this.g.attachProtoVectorListener("handedness", (i, s) => {
              this.handedness.push(...af(i)), ce(this, s);
            }),
            this.g.attachEmptyPacketListener("handedness", (i) => {
              ce(this, i);
            }),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      function cf(n) {
        return { landmarks: n.landmarks, worldLandmarks: n.worldLandmarks, handednesses: n.handedness, handedness: n.handedness };
      }
      (Pn.prototype.recognizeForVideo = Pn.prototype.Ga),
        (Pn.prototype.recognize = Pn.prototype.Fa),
        (Pn.prototype.setOptions = Pn.prototype.o),
        (Pn.createFromModelPath = function (n, e) {
          return Ke(Pn, n, { baseOptions: { modelAssetPath: e } });
        }),
        (Pn.createFromModelBuffer = function (n, e) {
          return Ke(Pn, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (Pn.createFromOptions = function (n, e) {
          return Ke(Pn, n, e);
        }),
        (Pn.HAND_CONNECTIONS = Lu);
      var vn = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "image_in", "norm_rect", !1),
            (this.landmarks = []),
            (this.worldLandmarks = []),
            (this.handedness = []),
            De((n = this.h = new wu()), 0, 1, (e = new Tt())),
            (this.s = new vu()),
            De(this.h, 0, 3, this.s),
            (this.j = new lm()),
            De(this.h, 0, 2, this.j),
            ui(this.j, 3, 1),
            Pe(this.j, 2, 0.5),
            Pe(this.s, 2, 0.5),
            Pe(this.h, 4, 0.5);
        }
        get baseOptions() {
          return Je(this.h, Tt, 1);
        }
        set baseOptions(n) {
          De(this.h, 0, 1, n);
        }
        o(n) {
          return (
            "numHands" in n && ui(this.j, 3, n.numHands ?? 1),
            "minHandDetectionConfidence" in n && Pe(this.j, 2, n.minHandDetectionConfidence ?? 0.5),
            "minTrackingConfidence" in n && Pe(this.h, 4, n.minTrackingConfidence ?? 0.5),
            "minHandPresenceConfidence" in n && Pe(this.s, 2, n.minHandPresenceConfidence ?? 0.5),
            this.l(n)
          );
        }
        D(n, e) {
          return (this.landmarks = []), (this.worldLandmarks = []), (this.handedness = []), Hn(this, n, e), cf(this);
        }
        F(n, e, t) {
          return (this.landmarks = []), (this.worldLandmarks = []), (this.handedness = []), di(this, n, t, e), cf(this);
        }
        m() {
          var n = new pn();
          wt(n, "image_in"), wt(n, "norm_rect"), et(n, "hand_landmarks"), et(n, "world_hand_landmarks"), et(n, "handedness");
          const e = new Mn();
          Zn(e, QP, this.h);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"),
            gt(t, "IMAGE:image_in"),
            gt(t, "NORM_RECT:norm_rect"),
            Ye(t, "LANDMARKS:hand_landmarks"),
            Ye(t, "WORLD_LANDMARKS:world_hand_landmarks"),
            Ye(t, "HANDEDNESS:handedness"),
            t.o(e),
            In(n, t),
            this.g.attachProtoVectorListener("hand_landmarks", (i, s) => {
              for (const r of i) (i = zA(r)), this.landmarks.push(fa(i));
              ce(this, s);
            }),
            this.g.attachEmptyPacketListener("hand_landmarks", (i) => {
              ce(this, i);
            }),
            this.g.attachProtoVectorListener("world_hand_landmarks", (i, s) => {
              for (const r of i) (i = cr(r)), this.worldLandmarks.push(hA(i));
              ce(this, s);
            }),
            this.g.attachEmptyPacketListener("world_hand_landmarks", (i) => {
              ce(this, i);
            }),
            this.g.attachProtoVectorListener("handedness", (i, s) => {
              var r = this.handedness,
                A = r.push;
              const o = [];
              for (const a of i) {
                i = ua(a);
                const c = [];
                for (const l of i.g())
                  c.push({ score: Bt(l, 2) ?? 0, index: Nn(l, 1) ?? 0 ?? -1, categoryName: Gn(l, 3) ?? "" ?? "", displayName: Gn(l, 4) ?? "" ?? "" });
                o.push(c);
              }
              A.call(r, ...o), ce(this, s);
            }),
            this.g.attachEmptyPacketListener("handedness", (i) => {
              ce(this, i);
            }),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (vn.prototype.detectForVideo = vn.prototype.F),
        (vn.prototype.detect = vn.prototype.D),
        (vn.prototype.setOptions = vn.prototype.o),
        (vn.createFromModelPath = function (n, e) {
          return Ke(vn, n, { baseOptions: { modelAssetPath: e } });
        }),
        (vn.createFromModelBuffer = function (n, e) {
          return Ke(vn, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (vn.createFromOptions = function (n, e) {
          return Ke(vn, n, e);
        }),
        (vn.HAND_CONNECTIONS = Lu);
      var Um = ti(
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 7],
        [0, 4],
        [4, 5],
        [5, 6],
        [6, 8],
        [9, 10],
        [11, 12],
        [11, 13],
        [13, 15],
        [15, 17],
        [15, 19],
        [15, 21],
        [17, 19],
        [12, 14],
        [14, 16],
        [16, 18],
        [16, 20],
        [16, 22],
        [18, 20],
        [11, 23],
        [12, 24],
        [23, 24],
        [23, 25],
        [24, 26],
        [25, 27],
        [26, 28],
        [27, 29],
        [28, 30],
        [29, 31],
        [30, 32],
        [27, 31],
        [28, 32]
      );
      function lf(n) {
        n.h = {
          faceLandmarks: [],
          faceBlendshapes: [],
          poseLandmarks: [],
          poseWorldLandmarks: [],
          poseSegmentationMasks: [],
          leftHandLandmarks: [],
          leftHandWorldLandmarks: [],
          rightHandLandmarks: [],
          rightHandWorldLandmarks: [],
        };
      }
      function uf(n) {
        try {
          if (!n.C) return n.h;
          n.C(n.h);
        } finally {
          pa(n);
        }
      }
      function jA(n, e) {
        (n = zA(n)), e.push(fa(n));
      }
      var xt = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "input_frames_image", null, !1),
            (this.h = {
              faceLandmarks: [],
              faceBlendshapes: [],
              poseLandmarks: [],
              poseWorldLandmarks: [],
              poseSegmentationMasks: [],
              leftHandLandmarks: [],
              leftHandWorldLandmarks: [],
              rightHandLandmarks: [],
              rightHandWorldLandmarks: [],
            }),
            (this.outputPoseSegmentationMasks = this.outputFaceBlendshapes = !1),
            De((n = this.j = new mm()), 0, 1, (e = new Tt())),
            (this.K = new vu()),
            De(this.j, 0, 2, this.K),
            (this.Y = new VP()),
            De(this.j, 0, 3, this.Y),
            (this.s = new ha()),
            De(this.j, 0, 4, this.s),
            (this.H = new rm()),
            De(this.j, 0, 5, this.H),
            (this.v = new dm()),
            De(this.j, 0, 6, this.v),
            (this.L = new pm()),
            De(this.j, 0, 7, this.L),
            Pe(this.s, 2, 0.5),
            Pe(this.s, 3, 0.3),
            Pe(this.H, 2, 0.5),
            Pe(this.v, 2, 0.5),
            Pe(this.v, 3, 0.3),
            Pe(this.L, 2, 0.5),
            Pe(this.K, 2, 0.5);
        }
        get baseOptions() {
          return Je(this.j, Tt, 1);
        }
        set baseOptions(n) {
          De(this.j, 0, 1, n);
        }
        o(n) {
          return (
            "minFaceDetectionConfidence" in n && Pe(this.s, 2, n.minFaceDetectionConfidence ?? 0.5),
            "minFaceSuppressionThreshold" in n && Pe(this.s, 3, n.minFaceSuppressionThreshold ?? 0.3),
            "minFacePresenceConfidence" in n && Pe(this.H, 2, n.minFacePresenceConfidence ?? 0.5),
            "outputFaceBlendshapes" in n && (this.outputFaceBlendshapes = !!n.outputFaceBlendshapes),
            "minPoseDetectionConfidence" in n && Pe(this.v, 2, n.minPoseDetectionConfidence ?? 0.5),
            "minPoseSuppressionThreshold" in n && Pe(this.v, 3, n.minPoseSuppressionThreshold ?? 0.3),
            "minPosePresenceConfidence" in n && Pe(this.L, 2, n.minPosePresenceConfidence ?? 0.5),
            "outputPoseSegmentationMasks" in n && (this.outputPoseSegmentationMasks = !!n.outputPoseSegmentationMasks),
            "minHandLandmarksConfidence" in n && Pe(this.K, 2, n.minHandLandmarksConfidence ?? 0.5),
            this.l(n)
          );
        }
        D(n, e, t) {
          const i = typeof e != "function" ? e : {};
          return (this.C = typeof e == "function" ? e : t), lf(this), Hn(this, n, i), uf(this);
        }
        F(n, e, t, i) {
          const s = typeof t != "function" ? t : {};
          return (this.C = typeof t == "function" ? t : i), lf(this), di(this, n, s, e), uf(this);
        }
        m() {
          var n = new pn();
          wt(n, "input_frames_image"),
            et(n, "pose_landmarks"),
            et(n, "pose_world_landmarks"),
            et(n, "face_landmarks"),
            et(n, "left_hand_landmarks"),
            et(n, "left_hand_world_landmarks"),
            et(n, "right_hand_landmarks"),
            et(n, "right_hand_world_landmarks");
          const e = new Mn(),
            t = new Rh();
          bc(t, 1, Ur("type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"), ""),
            (function (s, r) {
              if (r != null)
                if (Array.isArray(r)) mt(s, 2, Zo(r, Yl, void 0, void 0, !1));
                else {
                  if (!(typeof r == "string" || r instanceof Ri || Bs(r)))
                    throw Error("invalid value in Any.value field: " + r + " expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");
                  bc(s, 2, kl(r, !1), Os());
                }
            })(t, this.j.g());
          const i = new An();
          Sn(i, "mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"),
            zo(i, 8, Rh, t),
            gt(i, "IMAGE:input_frames_image"),
            Ye(i, "POSE_LANDMARKS:pose_landmarks"),
            Ye(i, "POSE_WORLD_LANDMARKS:pose_world_landmarks"),
            Ye(i, "FACE_LANDMARKS:face_landmarks"),
            Ye(i, "LEFT_HAND_LANDMARKS:left_hand_landmarks"),
            Ye(i, "LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"),
            Ye(i, "RIGHT_HAND_LANDMARKS:right_hand_landmarks"),
            Ye(i, "RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"),
            i.o(e),
            In(n, i),
            da(this, n),
            this.g.attachProtoListener("pose_landmarks", (s, r) => {
              jA(s, this.h.poseLandmarks), ce(this, r);
            }),
            this.g.attachEmptyPacketListener("pose_landmarks", (s) => {
              ce(this, s);
            }),
            this.g.attachProtoListener("pose_world_landmarks", (s, r) => {
              var A = this.h.poseWorldLandmarks;
              (s = cr(s)), A.push(hA(s)), ce(this, r);
            }),
            this.g.attachEmptyPacketListener("pose_world_landmarks", (s) => {
              ce(this, s);
            }),
            this.outputPoseSegmentationMasks &&
              (Ye(i, "POSE_SEGMENTATION_MASK:pose_segmentation_mask"),
              _r(this, "pose_segmentation_mask"),
              this.g.V("pose_segmentation_mask", (s, r) => {
                (this.h.poseSegmentationMasks = [Tr(this, s, !0, !this.C)]), ce(this, r);
              }),
              this.g.attachEmptyPacketListener("pose_segmentation_mask", (s) => {
                (this.h.poseSegmentationMasks = []), ce(this, s);
              })),
            this.g.attachProtoListener("face_landmarks", (s, r) => {
              jA(s, this.h.faceLandmarks), ce(this, r);
            }),
            this.g.attachEmptyPacketListener("face_landmarks", (s) => {
              ce(this, s);
            }),
            this.outputFaceBlendshapes &&
              (et(n, "extra_blendshapes"),
              Ye(i, "FACE_BLENDSHAPES:extra_blendshapes"),
              this.g.attachProtoListener("extra_blendshapes", (s, r) => {
                var A = this.h.faceBlendshapes;
                this.outputFaceBlendshapes && ((s = ua(s)), A.push(Tu(s.g() ?? []))), ce(this, r);
              }),
              this.g.attachEmptyPacketListener("extra_blendshapes", (s) => {
                ce(this, s);
              })),
            this.g.attachProtoListener("left_hand_landmarks", (s, r) => {
              jA(s, this.h.leftHandLandmarks), ce(this, r);
            }),
            this.g.attachEmptyPacketListener("left_hand_landmarks", (s) => {
              ce(this, s);
            }),
            this.g.attachProtoListener("left_hand_world_landmarks", (s, r) => {
              var A = this.h.leftHandWorldLandmarks;
              (s = cr(s)), A.push(hA(s)), ce(this, r);
            }),
            this.g.attachEmptyPacketListener("left_hand_world_landmarks", (s) => {
              ce(this, s);
            }),
            this.g.attachProtoListener("right_hand_landmarks", (s, r) => {
              jA(s, this.h.rightHandLandmarks), ce(this, r);
            }),
            this.g.attachEmptyPacketListener("right_hand_landmarks", (s) => {
              ce(this, s);
            }),
            this.g.attachProtoListener("right_hand_world_landmarks", (s, r) => {
              var A = this.h.rightHandWorldLandmarks;
              (s = cr(s)), A.push(hA(s)), ce(this, r);
            }),
            this.g.attachEmptyPacketListener("right_hand_world_landmarks", (s) => {
              ce(this, s);
            }),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (xt.prototype.detectForVideo = xt.prototype.F),
        (xt.prototype.detect = xt.prototype.D),
        (xt.prototype.setOptions = xt.prototype.o),
        (xt.createFromModelPath = function (n, e) {
          return Ke(xt, n, { baseOptions: { modelAssetPath: e } });
        }),
        (xt.createFromModelBuffer = function (n, e) {
          return Ke(xt, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (xt.createFromOptions = function (n, e) {
          return Ke(xt, n, e);
        }),
        (xt.HAND_CONNECTIONS = Lu),
        (xt.POSE_CONNECTIONS = Um),
        (xt.FACE_LANDMARKS_LIPS = Iu),
        (xt.FACE_LANDMARKS_LEFT_EYE = bu),
        (xt.FACE_LANDMARKS_LEFT_EYEBROW = zu),
        (xt.FACE_LANDMARKS_LEFT_IRIS = Rm),
        (xt.FACE_LANDMARKS_RIGHT_EYE = Ru),
        (xt.FACE_LANDMARKS_RIGHT_EYEBROW = Bu),
        (xt.FACE_LANDMARKS_RIGHT_IRIS = Bm),
        (xt.FACE_LANDMARKS_FACE_OVAL = Ou),
        (xt.FACE_LANDMARKS_CONTOURS = Om),
        (xt.FACE_LANDMARKS_TESSELATION = Lm);
      var Bn = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "input_image", "norm_rect", !0), (this.j = { classifications: [] }), De((n = this.h = new gm()), 0, 1, (e = new Tt()));
        }
        get baseOptions() {
          return Je(this.h, Tt, 1);
        }
        set baseOptions(n) {
          De(this.h, 0, 1, n);
        }
        o(n) {
          return De(this.h, 0, 2, Uc(n, Je(this.h, mu, 2))), this.l(n);
        }
        qa(n, e) {
          return (this.j = { classifications: [] }), Hn(this, n, e), this.j;
        }
        ra(n, e, t) {
          return (this.j = { classifications: [] }), di(this, n, t, e), this.j;
        }
        m() {
          var n = new pn();
          wt(n, "input_image"), wt(n, "norm_rect"), et(n, "classifications");
          const e = new Mn();
          Zn(e, WP, this.h);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"),
            gt(t, "IMAGE:input_image"),
            gt(t, "NORM_RECT:norm_rect"),
            Ye(t, "CLASSIFICATIONS:classifications"),
            t.o(e),
            In(n, t),
            this.g.attachProtoListener("classifications", (i, s) => {
              (this.j = (function (r) {
                const A = { classifications: Fi(r, zP, 1).map((o) => Tu(Je(o, Xp, 4)?.g() ?? [], Nn(o, 2) ?? 0, Gn(o, 3) ?? "")) };
                return Cc(vr(r, 2)) != null && (A.timestampMs = Cc(vr(r, 2)) ?? 0), A;
              })(RP(i))),
                ce(this, s);
            }),
            this.g.attachEmptyPacketListener("classifications", (i) => {
              ce(this, i);
            }),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (Bn.prototype.classifyForVideo = Bn.prototype.ra),
        (Bn.prototype.classify = Bn.prototype.qa),
        (Bn.prototype.setOptions = Bn.prototype.o),
        (Bn.createFromModelPath = function (n, e) {
          return Ke(Bn, n, { baseOptions: { modelAssetPath: e } });
        }),
        (Bn.createFromModelBuffer = function (n, e) {
          return Ke(Bn, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (Bn.createFromOptions = function (n, e) {
          return Ke(Bn, n, e);
        });
      var wn = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "image_in", "norm_rect", !0), (this.h = new Pm()), (this.embeddings = { embeddings: [] }), De((n = this.h), 0, 1, (e = new Tt()));
        }
        get baseOptions() {
          return Je(this.h, Tt, 1);
        }
        set baseOptions(n) {
          De(this.h, 0, 1, n);
        }
        o(n) {
          var e = this.h,
            t = Je(this.h, jh, 2);
          return (
            (t = t ? t.clone() : new jh()),
            n.l2Normalize !== void 0 ? _A(t, 1, n.l2Normalize) : "l2Normalize" in n && mt(t, 1),
            n.quantize !== void 0 ? _A(t, 2, n.quantize) : "quantize" in n && mt(t, 2),
            De(e, 0, 2, t),
            this.l(n)
          );
        }
        xa(n, e) {
          return Hn(this, n, e), this.embeddings;
        }
        ya(n, e, t) {
          return di(this, n, t, e), this.embeddings;
        }
        m() {
          var n = new pn();
          wt(n, "image_in"), wt(n, "norm_rect"), et(n, "embeddings_out");
          const e = new Mn();
          Zn(e, KP, this.h);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"),
            gt(t, "IMAGE:image_in"),
            gt(t, "NORM_RECT:norm_rect"),
            Ye(t, "EMBEDDINGS:embeddings_out"),
            t.o(e),
            In(n, t),
            this.g.attachProtoListener("embeddings_out", (i, s) => {
              (i = LP(i)),
                (this.embeddings = (function (r) {
                  return {
                    embeddings: Fi(r, OP, 1).map((A) => {
                      const o = { headIndex: Nn(A, 3) ?? 0 ?? -1, headName: Gn(A, 4) ?? "" ?? "" };
                      if (mp(A, Gh, za(A, 1)) !== void 0) (A = Is((A = Je(A, Gh, za(A, 1))), 1, us, Ss())), (o.floatEmbedding = A.slice());
                      else {
                        const a = new Uint8Array(0);
                        o.quantizedEmbedding = Je(A, BP, za(A, 2))?.ma()?.h() ?? a;
                      }
                      return o;
                    }),
                    timestampMs: Cc(vr(r, 2)) ?? 0,
                  };
                })(i)),
                ce(this, s);
            }),
            this.g.attachEmptyPacketListener("embeddings_out", (i) => {
              ce(this, i);
            }),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (wn.cosineSimilarity = function (n, e) {
        if (n.floatEmbedding && e.floatEmbedding) n = Kh(n.floatEmbedding, e.floatEmbedding);
        else {
          if (!n.quantizedEmbedding || !e.quantizedEmbedding) throw Error("Cannot compute cosine similarity between quantized and float embeddings.");
          n = Kh(Wh(n.quantizedEmbedding), Wh(e.quantizedEmbedding));
        }
        return n;
      }),
        (wn.prototype.embedForVideo = wn.prototype.ya),
        (wn.prototype.embed = wn.prototype.xa),
        (wn.prototype.setOptions = wn.prototype.o),
        (wn.createFromModelPath = function (n, e) {
          return Ke(wn, n, { baseOptions: { modelAssetPath: e } });
        }),
        (wn.createFromModelBuffer = function (n, e) {
          return Ke(wn, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (wn.createFromOptions = function (n, e) {
          return Ke(wn, n, e);
        });
      var Gc = class {
        constructor(n, e, t) {
          (this.confidenceMasks = n), (this.categoryMask = e), (this.qualityScores = t);
        }
        close() {
          this.confidenceMasks?.forEach((n) => {
            n.close();
          }),
            this.categoryMask?.close();
        }
      };
      function hf(n) {
        (n.categoryMask = void 0), (n.confidenceMasks = void 0), (n.qualityScores = void 0);
      }
      function ff(n) {
        try {
          const e = new Gc(n.confidenceMasks, n.categoryMask, n.qualityScores);
          if (!n.j) return e;
          n.j(e);
        } finally {
          pa(n);
        }
      }
      Gc.prototype.close = Gc.prototype.close;
      var un = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "image_in", "norm_rect", !1),
            (this.s = []),
            (this.outputCategoryMask = !1),
            (this.outputConfidenceMasks = !0),
            (this.h = new yu()),
            (this.v = new vm()),
            De(this.h, 0, 3, this.v),
            De((n = this.h), 0, 1, (e = new Tt()));
        }
        get baseOptions() {
          return Je(this.h, Tt, 1);
        }
        set baseOptions(n) {
          De(this.h, 0, 1, n);
        }
        o(n) {
          return (
            n.displayNamesLocale !== void 0 ? mt(this.h, 2, Ur(n.displayNamesLocale)) : "displayNamesLocale" in n && mt(this.h, 2),
            "outputCategoryMask" in n && (this.outputCategoryMask = n.outputCategoryMask ?? !1),
            "outputConfidenceMasks" in n && (this.outputConfidenceMasks = n.outputConfidenceMasks ?? !0),
            super.l(n)
          );
        }
        J() {
          (function (n) {
            const e = Fi(n.ca(), An, 1).filter((t) => (Gn(t, 1) ?? "").includes("mediapipe.tasks.TensorsToSegmentationCalculator"));
            if (((n.s = []), e.length > 1)) throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");
            e.length === 1 &&
              (Je(e[0], Mn, 7)?.l()?.g() ?? new Map()).forEach((t, i) => {
                n.s[Number(i)] = Gn(t, 1) ?? "";
              });
          })(this);
        }
        segment(n, e, t) {
          const i = typeof e != "function" ? e : {};
          return (this.j = typeof e == "function" ? e : t), hf(this), Hn(this, n, i), ff(this);
        }
        Ia(n, e, t, i) {
          const s = typeof t != "function" ? t : {};
          return (this.j = typeof t == "function" ? t : i), hf(this), di(this, n, s, e), ff(this);
        }
        Ba() {
          return this.s;
        }
        m() {
          var n = new pn();
          wt(n, "image_in"), wt(n, "norm_rect");
          const e = new Mn();
          Zn(e, _m, this.h);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"),
            gt(t, "IMAGE:image_in"),
            gt(t, "NORM_RECT:norm_rect"),
            t.o(e),
            In(n, t),
            da(this, n),
            this.outputConfidenceMasks &&
              (et(n, "confidence_masks"),
              Ye(t, "CONFIDENCE_MASKS:confidence_masks"),
              _r(this, "confidence_masks"),
              this.g.ba("confidence_masks", (i, s) => {
                (this.confidenceMasks = i.map((r) => Tr(this, r, !0, !this.j))), ce(this, s);
              }),
              this.g.attachEmptyPacketListener("confidence_masks", (i) => {
                (this.confidenceMasks = []), ce(this, i);
              })),
            this.outputCategoryMask &&
              (et(n, "category_mask"),
              Ye(t, "CATEGORY_MASK:category_mask"),
              _r(this, "category_mask"),
              this.g.V("category_mask", (i, s) => {
                (this.categoryMask = Tr(this, i, !1, !this.j)), ce(this, s);
              }),
              this.g.attachEmptyPacketListener("category_mask", (i) => {
                (this.categoryMask = void 0), ce(this, i);
              })),
            et(n, "quality_scores"),
            Ye(t, "QUALITY_SCORES:quality_scores"),
            this.g.attachFloatVectorListener("quality_scores", (i, s) => {
              (this.qualityScores = i), ce(this, s);
            }),
            this.g.attachEmptyPacketListener("quality_scores", (i) => {
              (this.categoryMask = void 0), ce(this, i);
            }),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (un.prototype.getLabels = un.prototype.Ba),
        (un.prototype.segmentForVideo = un.prototype.Ia),
        (un.prototype.segment = un.prototype.segment),
        (un.prototype.setOptions = un.prototype.o),
        (un.createFromModelPath = function (n, e) {
          return Ke(un, n, { baseOptions: { modelAssetPath: e } });
        }),
        (un.createFromModelBuffer = function (n, e) {
          return Ke(un, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (un.createFromOptions = function (n, e) {
          return Ke(un, n, e);
        });
      var jc = class {
        constructor(n, e, t) {
          (this.confidenceMasks = n), (this.categoryMask = e), (this.qualityScores = t);
        }
        close() {
          this.confidenceMasks?.forEach((n) => {
            n.close();
          }),
            this.categoryMask?.close();
        }
      };
      jc.prototype.close = jc.prototype.close;
      var t0 = class extends me {
          constructor(n) {
            super(n);
          }
        },
        js = [0, Rt, -2],
        Lo = [0, Mi, -3, yt, Mi, -1],
        df = [0, Lo],
        pf = [0, Lo, Rt, -1],
        Fa = class extends me {
          constructor(n) {
            super(n);
          }
        },
        mf = [0, Mi, -1, yt],
        n0 = class extends me {
          constructor(n) {
            super(n);
          }
        },
        gf = class extends me {
          constructor(n) {
            super(n);
          }
        },
        Hc = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 15],
        Fm = class extends me {
          constructor(n) {
            super(n);
          }
        };
      Fm.prototype.g = la([
        0,
        Gt,
        [
          0,
          Hc,
          rt,
          Lo,
          rt,
          [0, Lo, js],
          rt,
          df,
          rt,
          [0, df, js],
          rt,
          mf,
          rt,
          [0, Mi, -3, yt, Dn],
          rt,
          [0, Mi, -3, yt],
          rt,
          [0, At, Mi, -2, yt, Rt, yt, -1, 2, Mi, js],
          rt,
          pf,
          rt,
          [0, pf, js],
          Mi,
          js,
          At,
          rt,
          [0, Mi, -3, yt, js, -1],
          rt,
          [0, Gt, mf],
        ],
        At,
        [0, At, Rt, -1, yt],
      ]);
      var ri = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "image_in", "norm_rect_in", !1),
            (this.outputCategoryMask = !1),
            (this.outputConfidenceMasks = !0),
            (this.h = new yu()),
            (this.s = new vm()),
            De(this.h, 0, 3, this.s),
            De((n = this.h), 0, 1, (e = new Tt()));
        }
        get baseOptions() {
          return Je(this.h, Tt, 1);
        }
        set baseOptions(n) {
          De(this.h, 0, 1, n);
        }
        o(n) {
          return (
            "outputCategoryMask" in n && (this.outputCategoryMask = n.outputCategoryMask ?? !1),
            "outputConfidenceMasks" in n && (this.outputConfidenceMasks = n.outputConfidenceMasks ?? !0),
            super.l(n)
          );
        }
        segment(n, e, t, i) {
          const s = typeof t != "function" ? t : {};
          (this.j = typeof t == "function" ? t : i), (this.qualityScores = this.categoryMask = this.confidenceMasks = void 0), (t = this.B + 1), (i = new Fm());
          const r = new gf();
          var A = new t0();
          if ((ui(A, 1, 255), De(r, 0, 12, A), e.keypoint && e.scribble)) throw Error("Cannot provide both keypoint and scribble.");
          if (e.keypoint) {
            var o = new Fa();
            _A(o, 3, !0), Pe(o, 1, e.keypoint.x), Pe(o, 2, e.keypoint.y), lA(r, 5, Hc, o);
          } else {
            if (!e.scribble) throw Error("Must provide either a keypoint or a scribble.");
            for (o of ((A = new n0()), e.scribble)) _A((e = new Fa()), 3, !0), Pe(e, 1, o.x), Pe(e, 2, o.y), zo(A, 1, Fa, e);
            lA(r, 15, Hc, A);
          }
          zo(i, 1, gf, r), this.g.addProtoToStream(i.g(), "drishti.RenderData", "roi_in", t), Hn(this, n, s);
          e: {
            try {
              const c = new jc(this.confidenceMasks, this.categoryMask, this.qualityScores);
              if (!this.j) {
                var a = c;
                break e;
              }
              this.j(c);
            } finally {
              pa(this);
            }
            a = void 0;
          }
          return a;
        }
        m() {
          var n = new pn();
          wt(n, "image_in"), wt(n, "roi_in"), wt(n, "norm_rect_in");
          const e = new Mn();
          Zn(e, _m, this.h);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"),
            gt(t, "IMAGE:image_in"),
            gt(t, "ROI:roi_in"),
            gt(t, "NORM_RECT:norm_rect_in"),
            t.o(e),
            In(n, t),
            da(this, n),
            this.outputConfidenceMasks &&
              (et(n, "confidence_masks"),
              Ye(t, "CONFIDENCE_MASKS:confidence_masks"),
              _r(this, "confidence_masks"),
              this.g.ba("confidence_masks", (i, s) => {
                (this.confidenceMasks = i.map((r) => Tr(this, r, !0, !this.j))), ce(this, s);
              }),
              this.g.attachEmptyPacketListener("confidence_masks", (i) => {
                (this.confidenceMasks = []), ce(this, i);
              })),
            this.outputCategoryMask &&
              (et(n, "category_mask"),
              Ye(t, "CATEGORY_MASK:category_mask"),
              _r(this, "category_mask"),
              this.g.V("category_mask", (i, s) => {
                (this.categoryMask = Tr(this, i, !1, !this.j)), ce(this, s);
              }),
              this.g.attachEmptyPacketListener("category_mask", (i) => {
                (this.categoryMask = void 0), ce(this, i);
              })),
            et(n, "quality_scores"),
            Ye(t, "QUALITY_SCORES:quality_scores"),
            this.g.attachFloatVectorListener("quality_scores", (i, s) => {
              (this.qualityScores = i), ce(this, s);
            }),
            this.g.attachEmptyPacketListener("quality_scores", (i) => {
              (this.categoryMask = void 0), ce(this, i);
            }),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (ri.prototype.segment = ri.prototype.segment),
        (ri.prototype.setOptions = ri.prototype.o),
        (ri.createFromModelPath = function (n, e) {
          return Ke(ri, n, { baseOptions: { modelAssetPath: e } });
        }),
        (ri.createFromModelBuffer = function (n, e) {
          return Ke(ri, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (ri.createFromOptions = function (n, e) {
          return Ke(ri, n, e);
        });
      var On = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "input_frame_gpu", "norm_rect", !1), (this.j = { detections: [] }), De((n = this.h = new xm()), 0, 1, (e = new Tt()));
        }
        get baseOptions() {
          return Je(this.h, Tt, 1);
        }
        set baseOptions(n) {
          De(this.h, 0, 1, n);
        }
        o(n) {
          return (
            n.displayNamesLocale !== void 0 ? mt(this.h, 2, Ur(n.displayNamesLocale)) : "displayNamesLocale" in n && mt(this.h, 2),
            n.maxResults !== void 0 ? ui(this.h, 3, n.maxResults) : "maxResults" in n && mt(this.h, 3),
            n.scoreThreshold !== void 0 ? Pe(this.h, 4, n.scoreThreshold) : "scoreThreshold" in n && mt(this.h, 4),
            n.categoryAllowlist !== void 0 ? Ro(this.h, 5, n.categoryAllowlist) : "categoryAllowlist" in n && mt(this.h, 5),
            n.categoryDenylist !== void 0 ? Ro(this.h, 6, n.categoryDenylist) : "categoryDenylist" in n && mt(this.h, 6),
            this.l(n)
          );
        }
        D(n, e) {
          return (this.j = { detections: [] }), Hn(this, n, e), this.j;
        }
        F(n, e, t) {
          return (this.j = { detections: [] }), di(this, n, t, e), this.j;
        }
        m() {
          var n = new pn();
          wt(n, "input_frame_gpu"), wt(n, "norm_rect"), et(n, "detections");
          const e = new Mn();
          Zn(e, qP, this.h);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.ObjectDetectorGraph"),
            gt(t, "IMAGE:input_frame_gpu"),
            gt(t, "NORM_RECT:norm_rect"),
            Ye(t, "DETECTIONS:detections"),
            t.o(e),
            In(n, t),
            this.g.attachProtoVectorListener("detections", (i, s) => {
              for (const r of i) (i = Zp(r)), this.j.detections.push(Tm(i));
              ce(this, s);
            }),
            this.g.attachEmptyPacketListener("detections", (i) => {
              ce(this, i);
            }),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (On.prototype.detectForVideo = On.prototype.F),
        (On.prototype.detect = On.prototype.D),
        (On.prototype.setOptions = On.prototype.o),
        (On.createFromModelPath = async function (n, e) {
          return Ke(On, n, { baseOptions: { modelAssetPath: e } });
        }),
        (On.createFromModelBuffer = function (n, e) {
          return Ke(On, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (On.createFromOptions = function (n, e) {
          return Ke(On, n, e);
        });
      var Qc = class {
        constructor(n, e, t) {
          (this.landmarks = n), (this.worldLandmarks = e), (this.segmentationMasks = t);
        }
        close() {
          this.segmentationMasks?.forEach((n) => {
            n.close();
          });
        }
      };
      function Pf(n) {
        (n.landmarks = []), (n.worldLandmarks = []), (n.segmentationMasks = void 0);
      }
      function vf(n) {
        try {
          const e = new Qc(n.landmarks, n.worldLandmarks, n.segmentationMasks);
          if (!n.s) return e;
          n.s(e);
        } finally {
          pa(n);
        }
      }
      Qc.prototype.close = Qc.prototype.close;
      var _n = class extends dn {
        constructor(n, e) {
          super(new jn(n, e), "image_in", "norm_rect", !1),
            (this.landmarks = []),
            (this.worldLandmarks = []),
            (this.outputSegmentationMasks = !1),
            De((n = this.h = new ym()), 0, 1, (e = new Tt())),
            (this.v = new pm()),
            De(this.h, 0, 3, this.v),
            (this.j = new dm()),
            De(this.h, 0, 2, this.j),
            ui(this.j, 4, 1),
            Pe(this.j, 2, 0.5),
            Pe(this.v, 2, 0.5),
            Pe(this.h, 4, 0.5);
        }
        get baseOptions() {
          return Je(this.h, Tt, 1);
        }
        set baseOptions(n) {
          De(this.h, 0, 1, n);
        }
        o(n) {
          return (
            "numPoses" in n && ui(this.j, 4, n.numPoses ?? 1),
            "minPoseDetectionConfidence" in n && Pe(this.j, 2, n.minPoseDetectionConfidence ?? 0.5),
            "minTrackingConfidence" in n && Pe(this.h, 4, n.minTrackingConfidence ?? 0.5),
            "minPosePresenceConfidence" in n && Pe(this.v, 2, n.minPosePresenceConfidence ?? 0.5),
            "outputSegmentationMasks" in n && (this.outputSegmentationMasks = n.outputSegmentationMasks ?? !1),
            this.l(n)
          );
        }
        D(n, e, t) {
          const i = typeof e != "function" ? e : {};
          return (this.s = typeof e == "function" ? e : t), Pf(this), Hn(this, n, i), vf(this);
        }
        F(n, e, t, i) {
          const s = typeof t != "function" ? t : {};
          return (this.s = typeof t == "function" ? t : i), Pf(this), di(this, n, s, e), vf(this);
        }
        m() {
          var n = new pn();
          wt(n, "image_in"), wt(n, "norm_rect"), et(n, "normalized_landmarks"), et(n, "world_landmarks"), et(n, "segmentation_masks");
          const e = new Mn();
          Zn(e, XP, this.h);
          const t = new An();
          Sn(t, "mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"),
            gt(t, "IMAGE:image_in"),
            gt(t, "NORM_RECT:norm_rect"),
            Ye(t, "NORM_LANDMARKS:normalized_landmarks"),
            Ye(t, "WORLD_LANDMARKS:world_landmarks"),
            t.o(e),
            In(n, t),
            da(this, n),
            this.g.attachProtoVectorListener("normalized_landmarks", (i, s) => {
              this.landmarks = [];
              for (const r of i) (i = zA(r)), this.landmarks.push(fa(i));
              ce(this, s);
            }),
            this.g.attachEmptyPacketListener("normalized_landmarks", (i) => {
              (this.landmarks = []), ce(this, i);
            }),
            this.g.attachProtoVectorListener("world_landmarks", (i, s) => {
              this.worldLandmarks = [];
              for (const r of i) (i = cr(r)), this.worldLandmarks.push(hA(i));
              ce(this, s);
            }),
            this.g.attachEmptyPacketListener("world_landmarks", (i) => {
              (this.worldLandmarks = []), ce(this, i);
            }),
            this.outputSegmentationMasks &&
              (Ye(t, "SEGMENTATION_MASK:segmentation_masks"),
              _r(this, "segmentation_masks"),
              this.g.ba("segmentation_masks", (i, s) => {
                (this.segmentationMasks = i.map((r) => Tr(this, r, !0, !this.s))), ce(this, s);
              }),
              this.g.attachEmptyPacketListener("segmentation_masks", (i) => {
                (this.segmentationMasks = []), ce(this, i);
              })),
            (n = n.g()),
            this.setGraph(new Uint8Array(n), !0);
        }
      };
      (_n.prototype.detectForVideo = _n.prototype.F),
        (_n.prototype.detect = _n.prototype.D),
        (_n.prototype.setOptions = _n.prototype.o),
        (_n.createFromModelPath = function (n, e) {
          return Ke(_n, n, { baseOptions: { modelAssetPath: e } });
        }),
        (_n.createFromModelBuffer = function (n, e) {
          return Ke(_n, n, { baseOptions: { modelAssetBuffer: e } });
        }),
        (_n.createFromOptions = function (n, e) {
          return Ke(_n, n, e);
        }),
        (_n.POSE_CONNECTIONS = Um);
      class i0 {
        alpha;
        last;
        constructor(e = 0.1) {
          this.alpha = e;
        }
        filter(e) {
          if (!this.last) return (this.last = { x: e.x, y: e.y }), e;
          const t = { x: this.alpha * e.x + (1 - this.alpha) * this.last.x, y: this.alpha * e.y + (1 - this.alpha) * this.last.y };
          return (this.last = t), t;
        }
        reset() {
          this.last = void 0;
        }
      }
      function s0(n) {
        if (n.length !== 3) throw new Error("Exactly three points are required");
        const [e, t, i] = n,
          s = { x: t.x - e.x, y: t.y - e.y, z: t.z - e.z },
          r = { x: i.x - e.x, y: i.y - e.y, z: i.z - e.z },
          A = Math.sqrt(s.x * s.x + s.y * s.y + s.z * s.z);
        if (A < 1e-9) throw new Error("Points p0 and p1 are coincident");
        const o = { x: s.x / A, y: s.y / A, z: s.z / A },
          a = { x: s.y * r.z - s.z * r.y, y: s.z * r.x - s.x * r.z, z: s.x * r.y - s.y * r.x },
          c = Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
        if (c < 1e-9) throw new Error("Points are collinear");
        const l = { x: a.x / c, y: a.y / c, z: a.z / c },
          u = { x: l.y * o.z - l.z * o.y, y: l.z * o.x - l.x * o.z, z: l.x * o.y - l.y * o.x },
          h = [
            [o.x, u.x, l.x],
            [o.y, u.y, l.y],
            [o.z, u.z, l.z],
          ],
          d = Math.asin(Math.max(-1, Math.min(1, h[0][2])));
        let m, g;
        return (
          Math.abs(Math.cos(d)) > 1e-6
            ? ((g = Math.atan2(h[1][2], h[2][2])), (m = Math.atan2(h[0][1], h[0][0])))
            : ((g = 0), (m = Math.atan2(-h[1][0], h[1][1]))),
          (g += (10 / 180) * Math.PI),
          (m += (70 / 180) * Math.PI),
          console.log(`yaw: ${(d * (180 / Math.PI)).toFixed(2)}, pitch: ${(g * (180 / Math.PI)).toFixed(2)}, roll: ${(m * (180 / Math.PI)).toFixed(2)}`),
          { roll: m, pitch: g, yaw: d }
        );
      }
      /**
       * @license
       * Copyright 2010-2025 Three.js Authors
       * SPDX-License-Identifier: MIT
       */ const Uu = "178",
        r0 = 0,
        wf = 1,
        A0 = 2,
        Nm = 1,
        o0 = 2,
        Ei = 3,
        ki = 0,
        fn = 1,
        ai = 2,
        rs = 0,
        lr = 1,
        _f = 2,
        xf = 3,
        yf = 4,
        a0 = 5,
        Ms = 100,
        c0 = 101,
        l0 = 102,
        u0 = 103,
        h0 = 104,
        f0 = 200,
        d0 = 201,
        p0 = 202,
        m0 = 203,
        Vc = 204,
        Wc = 205,
        g0 = 206,
        P0 = 207,
        v0 = 208,
        w0 = 209,
        _0 = 210,
        x0 = 211,
        y0 = 212,
        T0 = 213,
        E0 = 214,
        Kc = 0,
        Yc = 1,
        qc = 2,
        Er = 3,
        Xc = 4,
        Jc = 5,
        Zc = 6,
        $c = 7,
        km = 0,
        D0 = 1,
        M0 = 2,
        As = 0,
        C0 = 1,
        S0 = 2,
        I0 = 3,
        b0 = 4,
        z0 = 5,
        R0 = 6,
        B0 = 7,
        Tf = "attached",
        O0 = "detached",
        Gm = 300,
        Dr = 301,
        Mr = 302,
        el = 303,
        tl = 304,
        va = 306,
        Cr = 1e3,
        es = 1001,
        Uo = 1002,
        sn = 1003,
        jm = 1004,
        aA = 1005,
        Tn = 1006,
        xo = 1007,
        Ii = 1008,
        hi = 1009,
        Hm = 1010,
        Qm = 1011,
        yA = 1012,
        Fu = 1013,
        Us = 1014,
        Xn = 1015,
        RA = 1016,
        Nu = 1017,
        ku = 1018,
        TA = 1020,
        Vm = 35902,
        Wm = 1021,
        Km = 1022,
        kn = 1023,
        EA = 1026,
        DA = 1027,
        Gu = 1028,
        ju = 1029,
        Ym = 1030,
        Hu = 1031,
        Qu = 1033,
        yo = 33776,
        To = 33777,
        Eo = 33778,
        Do = 33779,
        nl = 35840,
        il = 35841,
        sl = 35842,
        rl = 35843,
        Al = 36196,
        ol = 37492,
        al = 37496,
        cl = 37808,
        ll = 37809,
        ul = 37810,
        hl = 37811,
        fl = 37812,
        dl = 37813,
        pl = 37814,
        ml = 37815,
        gl = 37816,
        Pl = 37817,
        vl = 37818,
        wl = 37819,
        _l = 37820,
        xl = 37821,
        Mo = 36492,
        yl = 36494,
        Tl = 36495,
        qm = 36283,
        El = 36284,
        Dl = 36285,
        Ml = 36286,
        MA = 2300,
        CA = 2301,
        Na = 2302,
        Ef = 2400,
        Df = 2401,
        Mf = 2402,
        L0 = 2500,
        U0 = 0,
        Xm = 1,
        Cl = 2,
        F0 = 3200,
        N0 = 3201,
        Jm = 0,
        k0 = 1,
        $i = "",
        Yt = "srgb",
        on = "srgb-linear",
        Fo = "linear",
        ut = "srgb",
        Hs = 7680,
        Cf = 519,
        G0 = 512,
        j0 = 513,
        H0 = 514,
        Zm = 515,
        Q0 = 516,
        V0 = 517,
        W0 = 518,
        K0 = 519,
        Sl = 35044,
        Sf = "300 es",
        bi = 2e3,
        No = 2001;
      class Hr {
        addEventListener(e, t) {
          this._listeners === void 0 && (this._listeners = {});
          const i = this._listeners;
          i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
        }
        hasEventListener(e, t) {
          const i = this._listeners;
          return i === void 0 ? !1 : i[e] !== void 0 && i[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          const i = this._listeners;
          if (i === void 0) return;
          const s = i[e];
          if (s !== void 0) {
            const r = s.indexOf(t);
            r !== -1 && s.splice(r, 1);
          }
        }
        dispatchEvent(e) {
          const t = this._listeners;
          if (t === void 0) return;
          const i = t[e.type];
          if (i !== void 0) {
            e.target = this;
            const s = i.slice(0);
            for (let r = 0, A = s.length; r < A; r++) s[r].call(this, e);
            e.target = null;
          }
        }
      }
      const qt = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff",
      ];
      let If = 1234567;
      const fA = Math.PI / 180,
        Sr = 180 / Math.PI;
      function Jn() {
        const n = (Math.random() * 4294967295) | 0,
          e = (Math.random() * 4294967295) | 0,
          t = (Math.random() * 4294967295) | 0,
          i = (Math.random() * 4294967295) | 0;
        return (
          qt[n & 255] +
          qt[(n >> 8) & 255] +
          qt[(n >> 16) & 255] +
          qt[(n >> 24) & 255] +
          "-" +
          qt[e & 255] +
          qt[(e >> 8) & 255] +
          "-" +
          qt[((e >> 16) & 15) | 64] +
          qt[(e >> 24) & 255] +
          "-" +
          qt[(t & 63) | 128] +
          qt[(t >> 8) & 255] +
          "-" +
          qt[(t >> 16) & 255] +
          qt[(t >> 24) & 255] +
          qt[i & 255] +
          qt[(i >> 8) & 255] +
          qt[(i >> 16) & 255] +
          qt[(i >> 24) & 255]
        ).toLowerCase();
      }
      function Qe(n, e, t) {
        return Math.max(e, Math.min(t, n));
      }
      function Vu(n, e) {
        return ((n % e) + e) % e;
      }
      function Y0(n, e, t, i, s) {
        return i + ((n - e) * (s - i)) / (t - e);
      }
      function q0(n, e, t) {
        return n !== e ? (t - n) / (e - n) : 0;
      }
      function dA(n, e, t) {
        return (1 - t) * n + t * e;
      }
      function X0(n, e, t, i) {
        return dA(n, e, 1 - Math.exp(-t * i));
      }
      function J0(n, e = 1) {
        return e - Math.abs(Vu(n, e * 2) - e);
      }
      function Z0(n, e, t) {
        return n <= e ? 0 : n >= t ? 1 : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
      }
      function $0(n, e, t) {
        return n <= e ? 0 : n >= t ? 1 : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
      }
      function ev(n, e) {
        return n + Math.floor(Math.random() * (e - n + 1));
      }
      function tv(n, e) {
        return n + Math.random() * (e - n);
      }
      function nv(n) {
        return n * (0.5 - Math.random());
      }
      function iv(n) {
        n !== void 0 && (If = n);
        let e = (If += 1831565813);
        return (e = Math.imul(e ^ (e >>> 15), e | 1)), (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)), ((e ^ (e >>> 14)) >>> 0) / 4294967296;
      }
      function sv(n) {
        return n * fA;
      }
      function rv(n) {
        return n * Sr;
      }
      function Av(n) {
        return (n & (n - 1)) === 0 && n !== 0;
      }
      function ov(n) {
        return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
      }
      function av(n) {
        return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
      }
      function cv(n, e, t, i, s) {
        const r = Math.cos,
          A = Math.sin,
          o = r(t / 2),
          a = A(t / 2),
          c = r((e + i) / 2),
          l = A((e + i) / 2),
          u = r((e - i) / 2),
          h = A((e - i) / 2),
          d = r((i - e) / 2),
          m = A((i - e) / 2);
        switch (s) {
          case "XYX":
            n.set(o * l, a * u, a * h, o * c);
            break;
          case "YZY":
            n.set(a * h, o * l, a * u, o * c);
            break;
          case "ZXZ":
            n.set(a * u, a * h, o * l, o * c);
            break;
          case "XZX":
            n.set(o * l, a * m, a * d, o * c);
            break;
          case "YXY":
            n.set(a * d, o * l, a * m, o * c);
            break;
          case "ZYZ":
            n.set(a * m, a * d, o * l, o * c);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
        }
      }
      function Yn(n, e) {
        switch (e.constructor) {
          case Float32Array:
            return n;
          case Uint32Array:
            return n / 4294967295;
          case Uint16Array:
            return n / 65535;
          case Uint8Array:
            return n / 255;
          case Int32Array:
            return Math.max(n / 2147483647, -1);
          case Int16Array:
            return Math.max(n / 32767, -1);
          case Int8Array:
            return Math.max(n / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function at(n, e) {
        switch (e.constructor) {
          case Float32Array:
            return n;
          case Uint32Array:
            return Math.round(n * 4294967295);
          case Uint16Array:
            return Math.round(n * 65535);
          case Uint8Array:
            return Math.round(n * 255);
          case Int32Array:
            return Math.round(n * 2147483647);
          case Int16Array:
            return Math.round(n * 32767);
          case Int8Array:
            return Math.round(n * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const lv = {
        DEG2RAD: fA,
        RAD2DEG: Sr,
        generateUUID: Jn,
        clamp: Qe,
        euclideanModulo: Vu,
        mapLinear: Y0,
        inverseLerp: q0,
        lerp: dA,
        damp: X0,
        pingpong: J0,
        smoothstep: Z0,
        smootherstep: $0,
        randInt: ev,
        randFloat: tv,
        randFloatSpread: nv,
        seededRandom: iv,
        degToRad: sv,
        radToDeg: rv,
        isPowerOfTwo: Av,
        ceilPowerOfTwo: ov,
        floorPowerOfTwo: av,
        setQuaternionFromProperEuler: cv,
        normalize: at,
        denormalize: Yn,
      };
      class qe {
        constructor(e = 0, t = 0) {
          (qe.prototype.isVector2 = !0), (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            i = this.y,
            s = e.elements;
          return (this.x = s[0] * t + s[3] * i + s[6]), (this.y = s[1] * t + s[4] * i + s[7]), this;
        }
        min(e) {
          return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this;
        }
        max(e) {
          return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this;
        }
        clamp(e, t) {
          return (this.x = Qe(this.x, e.x, t.x)), (this.y = Qe(this.y, e.y, t.y)), this;
        }
        clampScalar(e, t) {
          return (this.x = Qe(this.x, e, t)), (this.y = Qe(this.y, e, t)), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Qe(i, e, t));
        }
        floor() {
          return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
        }
        ceil() {
          return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
        }
        round() {
          return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
        }
        roundToZero() {
          return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(Qe(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            i = this.y - e.y;
          return t * t + i * i;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
        }
        lerpVectors(e, t, i) {
          return (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t) {
          return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
        }
        rotateAround(e, t) {
          const i = Math.cos(t),
            s = Math.sin(t),
            r = this.x - e.x,
            A = this.y - e.y;
          return (this.x = r * i - A * s + e.x), (this.y = r * s + A * i + e.y), this;
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class fs {
        constructor(e = 0, t = 0, i = 0, s = 1) {
          (this.isQuaternion = !0), (this._x = e), (this._y = t), (this._z = i), (this._w = s);
        }
        static slerpFlat(e, t, i, s, r, A, o) {
          let a = i[s + 0],
            c = i[s + 1],
            l = i[s + 2],
            u = i[s + 3];
          const h = r[A + 0],
            d = r[A + 1],
            m = r[A + 2],
            g = r[A + 3];
          if (o === 0) {
            (e[t + 0] = a), (e[t + 1] = c), (e[t + 2] = l), (e[t + 3] = u);
            return;
          }
          if (o === 1) {
            (e[t + 0] = h), (e[t + 1] = d), (e[t + 2] = m), (e[t + 3] = g);
            return;
          }
          if (u !== g || a !== h || c !== d || l !== m) {
            let p = 1 - o;
            const f = a * h + c * d + l * m + u * g,
              E = f >= 0 ? 1 : -1,
              T = 1 - f * f;
            if (T > Number.EPSILON) {
              const b = Math.sqrt(T),
                S = Math.atan2(b, f * E);
              (p = Math.sin(p * S) / b), (o = Math.sin(o * S) / b);
            }
            const _ = o * E;
            if (((a = a * p + h * _), (c = c * p + d * _), (l = l * p + m * _), (u = u * p + g * _), p === 1 - o)) {
              const b = 1 / Math.sqrt(a * a + c * c + l * l + u * u);
              (a *= b), (c *= b), (l *= b), (u *= b);
            }
          }
          (e[t] = a), (e[t + 1] = c), (e[t + 2] = l), (e[t + 3] = u);
        }
        static multiplyQuaternionsFlat(e, t, i, s, r, A) {
          const o = i[s],
            a = i[s + 1],
            c = i[s + 2],
            l = i[s + 3],
            u = r[A],
            h = r[A + 1],
            d = r[A + 2],
            m = r[A + 3];
          return (
            (e[t] = o * m + l * u + a * d - c * h),
            (e[t + 1] = a * m + l * h + c * u - o * d),
            (e[t + 2] = c * m + l * d + o * h - a * u),
            (e[t + 3] = l * m - o * u - a * h - c * d),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, i, s) {
          return (this._x = e), (this._y = t), (this._z = i), (this._w = s), this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (this._x = e.x), (this._y = e.y), (this._z = e.z), (this._w = e.w), this._onChangeCallback(), this;
        }
        setFromEuler(e, t = !0) {
          const i = e._x,
            s = e._y,
            r = e._z,
            A = e._order,
            o = Math.cos,
            a = Math.sin,
            c = o(i / 2),
            l = o(s / 2),
            u = o(r / 2),
            h = a(i / 2),
            d = a(s / 2),
            m = a(r / 2);
          switch (A) {
            case "XYZ":
              (this._x = h * l * u + c * d * m), (this._y = c * d * u - h * l * m), (this._z = c * l * m + h * d * u), (this._w = c * l * u - h * d * m);
              break;
            case "YXZ":
              (this._x = h * l * u + c * d * m), (this._y = c * d * u - h * l * m), (this._z = c * l * m - h * d * u), (this._w = c * l * u + h * d * m);
              break;
            case "ZXY":
              (this._x = h * l * u - c * d * m), (this._y = c * d * u + h * l * m), (this._z = c * l * m + h * d * u), (this._w = c * l * u - h * d * m);
              break;
            case "ZYX":
              (this._x = h * l * u - c * d * m), (this._y = c * d * u + h * l * m), (this._z = c * l * m - h * d * u), (this._w = c * l * u + h * d * m);
              break;
            case "YZX":
              (this._x = h * l * u + c * d * m), (this._y = c * d * u + h * l * m), (this._z = c * l * m - h * d * u), (this._w = c * l * u - h * d * m);
              break;
            case "XZY":
              (this._x = h * l * u - c * d * m), (this._y = c * d * u - h * l * m), (this._z = c * l * m + h * d * u), (this._w = c * l * u + h * d * m);
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + A);
          }
          return t === !0 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const i = t / 2,
            s = Math.sin(i);
          return (this._x = e.x * s), (this._y = e.y * s), (this._z = e.z * s), (this._w = Math.cos(i)), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            i = t[0],
            s = t[4],
            r = t[8],
            A = t[1],
            o = t[5],
            a = t[9],
            c = t[2],
            l = t[6],
            u = t[10],
            h = i + o + u;
          if (h > 0) {
            const d = 0.5 / Math.sqrt(h + 1);
            (this._w = 0.25 / d), (this._x = (l - a) * d), (this._y = (r - c) * d), (this._z = (A - s) * d);
          } else if (i > o && i > u) {
            const d = 2 * Math.sqrt(1 + i - o - u);
            (this._w = (l - a) / d), (this._x = 0.25 * d), (this._y = (s + A) / d), (this._z = (r + c) / d);
          } else if (o > u) {
            const d = 2 * Math.sqrt(1 + o - i - u);
            (this._w = (r - c) / d), (this._x = (s + A) / d), (this._y = 0.25 * d), (this._z = (a + l) / d);
          } else {
            const d = 2 * Math.sqrt(1 + u - i - o);
            (this._w = (A - s) / d), (this._x = (r + c) / d), (this._y = (a + l) / d), (this._z = 0.25 * d);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let i = e.dot(t) + 1;
          return (
            i < 1e-8
              ? ((i = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
                  : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
              : ((this._x = e.y * t.z - e.z * t.y), (this._y = e.z * t.x - e.x * t.z), (this._z = e.x * t.y - e.y * t.x), (this._w = i)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(Qe(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const i = this.angleTo(e);
          if (i === 0) return this;
          const s = Math.min(1, t / i);
          return this.slerp(e, s), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
        }
        dot(e) {
          return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let e = this.length();
          return (
            e === 0
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e), (this._x = this._x * e), (this._y = this._y * e), (this._z = this._z * e), (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e) {
          return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const i = e._x,
            s = e._y,
            r = e._z,
            A = e._w,
            o = t._x,
            a = t._y,
            c = t._z,
            l = t._w;
          return (
            (this._x = i * l + A * o + s * c - r * a),
            (this._y = s * l + A * a + r * o - i * c),
            (this._z = r * l + A * c + i * a - s * o),
            (this._w = A * l - i * o - s * a - r * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (t === 0) return this;
          if (t === 1) return this.copy(e);
          const i = this._x,
            s = this._y,
            r = this._z,
            A = this._w;
          let o = A * e._w + i * e._x + s * e._y + r * e._z;
          if ((o < 0 ? ((this._w = -e._w), (this._x = -e._x), (this._y = -e._y), (this._z = -e._z), (o = -o)) : this.copy(e), o >= 1))
            return (this._w = A), (this._x = i), (this._y = s), (this._z = r), this;
          const a = 1 - o * o;
          if (a <= Number.EPSILON) {
            const d = 1 - t;
            return (
              (this._w = d * A + t * this._w),
              (this._x = d * i + t * this._x),
              (this._y = d * s + t * this._y),
              (this._z = d * r + t * this._z),
              this.normalize(),
              this
            );
          }
          const c = Math.sqrt(a),
            l = Math.atan2(c, o),
            u = Math.sin((1 - t) * l) / c,
            h = Math.sin(t * l) / c;
          return (
            (this._w = A * u + this._w * h),
            (this._x = i * u + this._x * h),
            (this._y = s * u + this._y * h),
            (this._z = r * u + this._z * h),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, i) {
          return this.copy(e).slerp(t, i);
        }
        random() {
          const e = 2 * Math.PI * Math.random(),
            t = 2 * Math.PI * Math.random(),
            i = Math.random(),
            s = Math.sqrt(1 - i),
            r = Math.sqrt(i);
          return this.set(s * Math.sin(e), s * Math.cos(e), r * Math.sin(t), r * Math.cos(t));
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
        }
        fromArray(e, t = 0) {
          return (this._x = e[t]), (this._y = e[t + 1]), (this._z = e[t + 2]), (this._w = e[t + 3]), this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._w), e;
        }
        fromBufferAttribute(e, t) {
          return (this._x = e.getX(t)), (this._y = e.getY(t)), (this._z = e.getZ(t)), (this._w = e.getW(t)), this._onChangeCallback(), this;
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class R {
        constructor(e = 0, t = 0, i = 0) {
          (R.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
        }
        set(e, t, i) {
          return i === void 0 && (i = this.z), (this.x = e), (this.y = t), (this.z = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this;
        }
        applyEuler(e) {
          return this.applyQuaternion(bf.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(bf.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            i = this.y,
            s = this.z,
            r = e.elements;
          return (this.x = r[0] * t + r[3] * i + r[6] * s), (this.y = r[1] * t + r[4] * i + r[7] * s), (this.z = r[2] * t + r[5] * i + r[8] * s), this;
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            i = this.y,
            s = this.z,
            r = e.elements,
            A = 1 / (r[3] * t + r[7] * i + r[11] * s + r[15]);
          return (
            (this.x = (r[0] * t + r[4] * i + r[8] * s + r[12]) * A),
            (this.y = (r[1] * t + r[5] * i + r[9] * s + r[13]) * A),
            (this.z = (r[2] * t + r[6] * i + r[10] * s + r[14]) * A),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            i = this.y,
            s = this.z,
            r = e.x,
            A = e.y,
            o = e.z,
            a = e.w,
            c = 2 * (A * s - o * i),
            l = 2 * (o * t - r * s),
            u = 2 * (r * i - A * t);
          return (this.x = t + a * c + A * u - o * l), (this.y = i + a * l + o * c - r * u), (this.z = s + a * u + r * l - A * c), this;
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
        }
        transformDirection(e) {
          const t = this.x,
            i = this.y,
            s = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[4] * i + r[8] * s), (this.y = r[1] * t + r[5] * i + r[9] * s), (this.z = r[2] * t + r[6] * i + r[10] * s), this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), (this.z = Math.min(this.z, e.z)), this;
        }
        max(e) {
          return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), (this.z = Math.max(this.z, e.z)), this;
        }
        clamp(e, t) {
          return (this.x = Qe(this.x, e.x, t.x)), (this.y = Qe(this.y, e.y, t.y)), (this.z = Qe(this.z, e.z, t.z)), this;
        }
        clampScalar(e, t) {
          return (this.x = Qe(this.x, e, t)), (this.y = Qe(this.y, e, t)), (this.z = Qe(this.z, e, t)), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Qe(i, e, t));
        }
        floor() {
          return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this;
        }
        ceil() {
          return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this;
        }
        round() {
          return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this;
        }
        roundToZero() {
          return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), (this.z = Math.trunc(this.z)), this;
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), this;
        }
        lerpVectors(e, t, i) {
          return (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), (this.z = e.z + (t.z - e.z) * i), this;
        }
        cross(e) {
          return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const i = e.x,
            s = e.y,
            r = e.z,
            A = t.x,
            o = t.y,
            a = t.z;
          return (this.x = s * a - r * o), (this.y = r * A - i * a), (this.z = i * o - s * A), this;
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) return this.set(0, 0, 0);
          const i = e.dot(this) / t;
          return this.copy(e).multiplyScalar(i);
        }
        projectOnPlane(e) {
          return ka.copy(this).projectOnVector(e), this.sub(ka);
        }
        reflect(e) {
          return this.sub(ka.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(Qe(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            i = this.y - e.y,
            s = this.z - e.z;
          return t * t + i * i + s * s;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, i) {
          const s = Math.sin(t) * e;
          return (this.x = s * Math.sin(i)), (this.y = Math.cos(t) * e), (this.z = s * Math.cos(i)), this;
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, i) {
          return (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this;
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            i = this.setFromMatrixColumn(e, 1).length(),
            s = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = i), (this.z = s), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
          return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
        }
        setFromColor(e) {
          return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t) {
          return (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this;
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this;
        }
        randomDirection() {
          const e = Math.random() * Math.PI * 2,
            t = Math.random() * 2 - 1,
            i = Math.sqrt(1 - t * t);
          return (this.x = i * Math.cos(e)), (this.y = t), (this.z = i * Math.sin(e)), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const ka = new R(),
        bf = new fs();
      class Ne {
        constructor(e, t, i, s, r, A, o, a, c) {
          (Ne.prototype.isMatrix3 = !0), (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]), e !== void 0 && this.set(e, t, i, s, r, A, o, a, c);
        }
        set(e, t, i, s, r, A, o, a, c) {
          const l = this.elements;
          return (l[0] = e), (l[1] = s), (l[2] = o), (l[3] = t), (l[4] = r), (l[5] = a), (l[6] = i), (l[7] = A), (l[8] = c), this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            i = e.elements;
          return (t[0] = i[0]), (t[1] = i[1]), (t[2] = i[2]), (t[3] = i[3]), (t[4] = i[4]), (t[5] = i[5]), (t[6] = i[6]), (t[7] = i[7]), (t[8] = i[8]), this;
        }
        extractBasis(e, t, i) {
          return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements,
            s = t.elements,
            r = this.elements,
            A = i[0],
            o = i[3],
            a = i[6],
            c = i[1],
            l = i[4],
            u = i[7],
            h = i[2],
            d = i[5],
            m = i[8],
            g = s[0],
            p = s[3],
            f = s[6],
            E = s[1],
            T = s[4],
            _ = s[7],
            b = s[2],
            S = s[5],
            D = s[8];
          return (
            (r[0] = A * g + o * E + a * b),
            (r[3] = A * p + o * T + a * S),
            (r[6] = A * f + o * _ + a * D),
            (r[1] = c * g + l * E + u * b),
            (r[4] = c * p + l * T + u * S),
            (r[7] = c * f + l * _ + u * D),
            (r[2] = h * g + d * E + m * b),
            (r[5] = h * p + d * T + m * S),
            (r[8] = h * f + d * _ + m * D),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (t[0] *= e), (t[3] *= e), (t[6] *= e), (t[1] *= e), (t[4] *= e), (t[7] *= e), (t[2] *= e), (t[5] *= e), (t[8] *= e), this;
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            i = e[1],
            s = e[2],
            r = e[3],
            A = e[4],
            o = e[5],
            a = e[6],
            c = e[7],
            l = e[8];
          return t * A * l - t * o * c - i * r * l + i * o * a + s * r * c - s * A * a;
        }
        invert() {
          const e = this.elements,
            t = e[0],
            i = e[1],
            s = e[2],
            r = e[3],
            A = e[4],
            o = e[5],
            a = e[6],
            c = e[7],
            l = e[8],
            u = l * A - o * c,
            h = o * a - l * r,
            d = c * r - A * a,
            m = t * u + i * h + s * d;
          if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const g = 1 / m;
          return (
            (e[0] = u * g),
            (e[1] = (s * c - l * i) * g),
            (e[2] = (o * i - s * A) * g),
            (e[3] = h * g),
            (e[4] = (l * t - s * a) * g),
            (e[5] = (s * r - o * t) * g),
            (e[6] = d * g),
            (e[7] = (i * a - c * t) * g),
            (e[8] = (A * t - i * r) * g),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (e = t[1]), (t[1] = t[3]), (t[3] = e), (e = t[2]), (t[2] = t[6]), (t[6] = e), (e = t[5]), (t[5] = t[7]), (t[7] = e), this;
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (e[0] = t[0]), (e[1] = t[3]), (e[2] = t[6]), (e[3] = t[1]), (e[4] = t[4]), (e[5] = t[7]), (e[6] = t[2]), (e[7] = t[5]), (e[8] = t[8]), this;
        }
        setUvTransform(e, t, i, s, r, A, o) {
          const a = Math.cos(r),
            c = Math.sin(r);
          return this.set(i * a, i * c, -i * (a * A + c * o) + A + e, -s * c, s * a, -s * (-c * A + a * o) + o + t, 0, 0, 1), this;
        }
        scale(e, t) {
          return this.premultiply(Ga.makeScale(e, t)), this;
        }
        rotate(e) {
          return this.premultiply(Ga.makeRotation(-e)), this;
        }
        translate(e, t) {
          return this.premultiply(Ga.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
          return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
        }
        makeRotation(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
          return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
          const t = this.elements,
            i = e.elements;
          for (let s = 0; s < 9; s++) if (t[s] !== i[s]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return (
            (e[t] = i[0]),
            (e[t + 1] = i[1]),
            (e[t + 2] = i[2]),
            (e[t + 3] = i[3]),
            (e[t + 4] = i[4]),
            (e[t + 5] = i[5]),
            (e[t + 6] = i[6]),
            (e[t + 7] = i[7]),
            (e[t + 8] = i[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const Ga = new Ne();
      function $m(n) {
        for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
        return !1;
      }
      function SA(n) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", n);
      }
      function uv() {
        const n = SA("canvas");
        return (n.style.display = "block"), n;
      }
      const zf = {};
      function ur(n) {
        n in zf || ((zf[n] = !0), console.warn(n));
      }
      function hv(n, e, t) {
        return new Promise(function (i, s) {
          function r() {
            switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
              case n.WAIT_FAILED:
                s();
                break;
              case n.TIMEOUT_EXPIRED:
                setTimeout(r, t);
                break;
              default:
                i();
            }
          }
          setTimeout(r, t);
        });
      }
      function fv(n) {
        const e = n.elements;
        (e[2] = 0.5 * e[2] + 0.5 * e[3]), (e[6] = 0.5 * e[6] + 0.5 * e[7]), (e[10] = 0.5 * e[10] + 0.5 * e[11]), (e[14] = 0.5 * e[14] + 0.5 * e[15]);
      }
      function dv(n) {
        const e = n.elements;
        e[11] === -1 ? ((e[10] = -e[10] - 1), (e[14] = -e[14])) : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
      }
      const Rf = new Ne().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322),
        Bf = new Ne().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
      function pv() {
        const n = {
            enabled: !0,
            workingColorSpace: on,
            spaces: {},
            convert: function (s, r, A) {
              return (
                this.enabled === !1 ||
                  r === A ||
                  !r ||
                  !A ||
                  (this.spaces[r].transfer === ut && ((s.r = Li(s.r)), (s.g = Li(s.g)), (s.b = Li(s.b))),
                  this.spaces[r].primaries !== this.spaces[A].primaries && (s.applyMatrix3(this.spaces[r].toXYZ), s.applyMatrix3(this.spaces[A].fromXYZ)),
                  this.spaces[A].transfer === ut && ((s.r = hr(s.r)), (s.g = hr(s.g)), (s.b = hr(s.b)))),
                s
              );
            },
            workingToColorSpace: function (s, r) {
              return this.convert(s, this.workingColorSpace, r);
            },
            colorSpaceToWorking: function (s, r) {
              return this.convert(s, r, this.workingColorSpace);
            },
            getPrimaries: function (s) {
              return this.spaces[s].primaries;
            },
            getTransfer: function (s) {
              return s === $i ? Fo : this.spaces[s].transfer;
            },
            getLuminanceCoefficients: function (s, r = this.workingColorSpace) {
              return s.fromArray(this.spaces[r].luminanceCoefficients);
            },
            define: function (s) {
              Object.assign(this.spaces, s);
            },
            _getMatrix: function (s, r, A) {
              return s.copy(this.spaces[r].toXYZ).multiply(this.spaces[A].fromXYZ);
            },
            _getDrawingBufferColorSpace: function (s) {
              return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
            },
            _getUnpackColorSpace: function (s = this.workingColorSpace) {
              return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
            },
            fromWorkingColorSpace: function (s, r) {
              return ur("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), n.workingToColorSpace(s, r);
            },
            toWorkingColorSpace: function (s, r) {
              return ur("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), n.colorSpaceToWorking(s, r);
            },
          },
          e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
          t = [0.2126, 0.7152, 0.0722],
          i = [0.3127, 0.329];
        return (
          n.define({
            [on]: {
              primaries: e,
              whitePoint: i,
              transfer: Fo,
              toXYZ: Rf,
              fromXYZ: Bf,
              luminanceCoefficients: t,
              workingColorSpaceConfig: { unpackColorSpace: Yt },
              outputColorSpaceConfig: { drawingBufferColorSpace: Yt },
            },
            [Yt]: {
              primaries: e,
              whitePoint: i,
              transfer: ut,
              toXYZ: Rf,
              fromXYZ: Bf,
              luminanceCoefficients: t,
              outputColorSpaceConfig: { drawingBufferColorSpace: Yt },
            },
          }),
          n
        );
      }
      const Xe = pv();
      function Li(n) {
        return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
      }
      function hr(n) {
        return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
      }
      let Qs;
      class mv {
        static getDataURL(e, t = "image/png") {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
          let i;
          if (e instanceof HTMLCanvasElement) i = e;
          else {
            Qs === void 0 && (Qs = SA("canvas")), (Qs.width = e.width), (Qs.height = e.height);
            const s = Qs.getContext("2d");
            e instanceof ImageData ? s.putImageData(e, 0, 0) : s.drawImage(e, 0, 0, e.width, e.height), (i = Qs);
          }
          return i.toDataURL(t);
        }
        static sRGBToLinear(e) {
          if (
            (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
          ) {
            const t = SA("canvas");
            (t.width = e.width), (t.height = e.height);
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const s = i.getImageData(0, 0, e.width, e.height),
              r = s.data;
            for (let A = 0; A < r.length; A++) r[A] = Li(r[A] / 255) * 255;
            return i.putImageData(s, 0, 0), t;
          } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
              t instanceof Uint8Array || t instanceof Uint8ClampedArray ? (t[i] = Math.floor(Li(t[i] / 255) * 255)) : (t[i] = Li(t[i]));
            return { data: t, width: e.width, height: e.height };
          } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
        }
      }
      let gv = 0;
      class Wu {
        constructor(e = null) {
          (this.isSource = !0),
            Object.defineProperty(this, "id", { value: gv++ }),
            (this.uuid = Jn()),
            (this.data = e),
            (this.dataReady = !0),
            (this.version = 0);
        }
        getSize(e) {
          const t = this.data;
          return t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0), e;
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
          const i = { uuid: this.uuid, url: "" },
            s = this.data;
          if (s !== null) {
            let r;
            if (Array.isArray(s)) {
              r = [];
              for (let A = 0, o = s.length; A < o; A++) s[A].isDataTexture ? r.push(ja(s[A].image)) : r.push(ja(s[A]));
            } else r = ja(s);
            i.url = r;
          }
          return t || (e.images[this.uuid] = i), i;
        }
      }
      function ja(n) {
        return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
          ? mv.getDataURL(n)
          : n.data
          ? { data: Array.from(n.data), width: n.width, height: n.height, type: n.data.constructor.name }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let Pv = 0;
      const Ha = new R();
      class Kt extends Hr {
        constructor(e = Kt.DEFAULT_IMAGE, t = Kt.DEFAULT_MAPPING, i = es, s = es, r = Tn, A = Ii, o = kn, a = hi, c = Kt.DEFAULT_ANISOTROPY, l = $i) {
          super(),
            (this.isTexture = !0),
            Object.defineProperty(this, "id", { value: Pv++ }),
            (this.uuid = Jn()),
            (this.name = ""),
            (this.source = new Wu(e)),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.channel = 0),
            (this.wrapS = i),
            (this.wrapT = s),
            (this.magFilter = r),
            (this.minFilter = A),
            (this.anisotropy = c),
            (this.format = o),
            (this.internalFormat = null),
            (this.type = a),
            (this.offset = new qe(0, 0)),
            (this.repeat = new qe(1, 1)),
            (this.center = new qe(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Ne()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.colorSpace = l),
            (this.userData = {}),
            (this.updateRanges = []),
            (this.version = 0),
            (this.onUpdate = null),
            (this.renderTarget = null),
            (this.isRenderTargetTexture = !1),
            (this.isArrayTexture = !!(e && e.depth && e.depth > 1)),
            (this.pmremVersion = 0);
        }
        get width() {
          return this.source.getSize(Ha).x;
        }
        get height() {
          return this.source.getSize(Ha).y;
        }
        get depth() {
          return this.source.getSize(Ha).z;
        }
        get image() {
          return this.source.data;
        }
        set image(e = null) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({ start: e, count: t });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.source = e.source),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.channel = e.channel),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.colorSpace = e.colorSpace),
            (this.renderTarget = e.renderTarget),
            (this.isRenderTargetTexture = e.isRenderTargetTexture),
            (this.isArrayTexture = e.isArrayTexture),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            (this.needsUpdate = !0),
            this
          );
        }
        setValues(e) {
          for (const t in e) {
            const i = e[t];
            if (i === void 0) {
              console.warn(`THREE.Texture.setValues(): parameter '${t}' has value of undefined.`);
              continue;
            }
            const s = this[t];
            if (s === void 0) {
              console.warn(`THREE.Texture.setValues(): property '${t}' does not exist.`);
              continue;
            }
            (s && i && s.isVector2 && i.isVector2) || (s && i && s.isVector3 && i.isVector3) || (s && i && s.isMatrix3 && i.isMatrix3)
              ? s.copy(i)
              : (this[t] = i);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
          const i = {
            metadata: { version: 4.7, type: "Texture", generator: "Texture.toJSON" },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
          if (this.mapping !== Gm) return e;
          if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
              case Cr:
                e.x = e.x - Math.floor(e.x);
                break;
              case es:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case Uo:
                Math.abs(Math.floor(e.x) % 2) === 1 ? (e.x = Math.ceil(e.x) - e.x) : (e.x = e.x - Math.floor(e.x));
                break;
            }
          if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
              case Cr:
                e.y = e.y - Math.floor(e.y);
                break;
              case es:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case Uo:
                Math.abs(Math.floor(e.y) % 2) === 1 ? (e.y = Math.ceil(e.y) - e.y) : (e.y = e.y - Math.floor(e.y));
                break;
            }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          e === !0 && (this.version++, (this.source.needsUpdate = !0));
        }
        set needsPMREMUpdate(e) {
          e === !0 && this.pmremVersion++;
        }
      }
      Kt.DEFAULT_IMAGE = null;
      Kt.DEFAULT_MAPPING = Gm;
      Kt.DEFAULT_ANISOTROPY = 1;
      class st {
        constructor(e = 0, t = 0, i = 0, s = 1) {
          (st.prototype.isVector4 = !0), (this.x = e), (this.y = t), (this.z = i), (this.w = s);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, i, s) {
          return (this.x = e), (this.y = t), (this.z = i), (this.w = s), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), (this.w = e.w !== void 0 ? e.w : 1), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), (this.w = e.w + t.w), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), (this.w += e.w * t), this;
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), (this.w = e.w - t.w), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
        }
        applyMatrix4(e) {
          const t = this.x,
            i = this.y,
            s = this.z,
            r = this.w,
            A = e.elements;
          return (
            (this.x = A[0] * t + A[4] * i + A[8] * s + A[12] * r),
            (this.y = A[1] * t + A[5] * i + A[9] * s + A[13] * r),
            (this.z = A[2] * t + A[6] * i + A[10] * s + A[14] * r),
            (this.w = A[3] * t + A[7] * i + A[11] * s + A[15] * r),
            this
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return t < 1e-4 ? ((this.x = 1), (this.y = 0), (this.z = 0)) : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)), this;
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, i, s, r;
          const a = e.elements,
            c = a[0],
            l = a[4],
            u = a[8],
            h = a[1],
            d = a[5],
            m = a[9],
            g = a[2],
            p = a[6],
            f = a[10];
          if (Math.abs(l - h) < 0.01 && Math.abs(u - g) < 0.01 && Math.abs(m - p) < 0.01) {
            if (Math.abs(l + h) < 0.1 && Math.abs(u + g) < 0.1 && Math.abs(m + p) < 0.1 && Math.abs(c + d + f - 3) < 0.1) return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const T = (c + 1) / 2,
              _ = (d + 1) / 2,
              b = (f + 1) / 2,
              S = (l + h) / 4,
              D = (u + g) / 4,
              O = (m + p) / 4;
            return (
              T > _ && T > b
                ? T < 0.01
                  ? ((i = 0), (s = 0.707106781), (r = 0.707106781))
                  : ((i = Math.sqrt(T)), (s = S / i), (r = D / i))
                : _ > b
                ? _ < 0.01
                  ? ((i = 0.707106781), (s = 0), (r = 0.707106781))
                  : ((s = Math.sqrt(_)), (i = S / s), (r = O / s))
                : b < 0.01
                ? ((i = 0.707106781), (s = 0.707106781), (r = 0))
                : ((r = Math.sqrt(b)), (i = D / r), (s = O / r)),
              this.set(i, s, r, t),
              this
            );
          }
          let E = Math.sqrt((p - m) * (p - m) + (u - g) * (u - g) + (h - l) * (h - l));
          return (
            Math.abs(E) < 0.001 && (E = 1),
            (this.x = (p - m) / E),
            (this.y = (u - g) / E),
            (this.z = (h - l) / E),
            (this.w = Math.acos((c + d + f - 1) / 2)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), (this.w = t[15]), this;
        }
        min(e) {
          return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), (this.z = Math.min(this.z, e.z)), (this.w = Math.min(this.w, e.w)), this;
        }
        max(e) {
          return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), (this.z = Math.max(this.z, e.z)), (this.w = Math.max(this.w, e.w)), this;
        }
        clamp(e, t) {
          return (this.x = Qe(this.x, e.x, t.x)), (this.y = Qe(this.y, e.y, t.y)), (this.z = Qe(this.z, e.z, t.z)), (this.w = Qe(this.w, e.w, t.w)), this;
        }
        clampScalar(e, t) {
          return (this.x = Qe(this.x, e, t)), (this.y = Qe(this.y, e, t)), (this.z = Qe(this.z, e, t)), (this.w = Qe(this.w, e, t)), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Qe(i, e, t));
        }
        floor() {
          return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), (this.w = Math.floor(this.w)), this;
        }
        ceil() {
          return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), (this.w = Math.ceil(this.w)), this;
        }
        round() {
          return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), (this.w = Math.round(this.w)), this;
        }
        roundToZero() {
          return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), (this.z = Math.trunc(this.z)), (this.w = Math.trunc(this.w)), this;
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), (this.w += (e.w - this.w) * t), this;
        }
        lerpVectors(e, t, i) {
          return (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), (this.z = e.z + (t.z - e.z) * i), (this.w = e.w + (t.w - e.w) * i), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), (this.w = e[t + 3]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), (e[t + 3] = this.w), e;
        }
        fromBufferAttribute(e, t) {
          return (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), (this.w = e.getW(t)), this;
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), (this.w = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class vv extends Hr {
        constructor(e = 1, t = 1, i = {}) {
          super(),
            (i = Object.assign(
              {
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: Tn,
                depthBuffer: !0,
                stencilBuffer: !1,
                resolveDepthBuffer: !0,
                resolveStencilBuffer: !0,
                depthTexture: null,
                samples: 0,
                count: 1,
                depth: 1,
                multiview: !1,
              },
              i
            )),
            (this.isRenderTarget = !0),
            (this.width = e),
            (this.height = t),
            (this.depth = i.depth),
            (this.scissor = new st(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new st(0, 0, e, t));
          const s = { width: e, height: t, depth: i.depth },
            r = new Kt(s);
          this.textures = [];
          const A = i.count;
          for (let o = 0; o < A; o++) (this.textures[o] = r.clone()), (this.textures[o].isRenderTargetTexture = !0), (this.textures[o].renderTarget = this);
          this._setTextureOptions(i),
            (this.depthBuffer = i.depthBuffer),
            (this.stencilBuffer = i.stencilBuffer),
            (this.resolveDepthBuffer = i.resolveDepthBuffer),
            (this.resolveStencilBuffer = i.resolveStencilBuffer),
            (this._depthTexture = null),
            (this.depthTexture = i.depthTexture),
            (this.samples = i.samples),
            (this.multiview = i.multiview);
        }
        _setTextureOptions(e = {}) {
          const t = { minFilter: Tn, generateMipmaps: !1, flipY: !1, internalFormat: null };
          e.mapping !== void 0 && (t.mapping = e.mapping),
            e.wrapS !== void 0 && (t.wrapS = e.wrapS),
            e.wrapT !== void 0 && (t.wrapT = e.wrapT),
            e.wrapR !== void 0 && (t.wrapR = e.wrapR),
            e.magFilter !== void 0 && (t.magFilter = e.magFilter),
            e.minFilter !== void 0 && (t.minFilter = e.minFilter),
            e.format !== void 0 && (t.format = e.format),
            e.type !== void 0 && (t.type = e.type),
            e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy),
            e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace),
            e.flipY !== void 0 && (t.flipY = e.flipY),
            e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps),
            e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
          for (let i = 0; i < this.textures.length; i++) this.textures[i].setValues(t);
        }
        get texture() {
          return this.textures[0];
        }
        set texture(e) {
          this.textures[0] = e;
        }
        set depthTexture(e) {
          this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), (this._depthTexture = e);
        }
        get depthTexture() {
          return this._depthTexture;
        }
        setSize(e, t, i = 1) {
          if (this.width !== e || this.height !== t || this.depth !== i) {
            (this.width = e), (this.height = t), (this.depth = i);
            for (let s = 0, r = this.textures.length; s < r; s++)
              (this.textures[s].image.width = e),
                (this.textures[s].image.height = t),
                (this.textures[s].image.depth = i),
                (this.textures[s].isArrayTexture = this.textures[s].image.depth > 1);
            this.dispose();
          }
          this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.scissor.copy(e.scissor),
            (this.scissorTest = e.scissorTest),
            this.viewport.copy(e.viewport),
            (this.textures.length = 0);
          for (let t = 0, i = e.textures.length; t < i; t++) {
            (this.textures[t] = e.textures[t].clone()), (this.textures[t].isRenderTargetTexture = !0), (this.textures[t].renderTarget = this);
            const s = Object.assign({}, e.textures[t].image);
            this.textures[t].source = new Wu(s);
          }
          return (
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.resolveDepthBuffer = e.resolveDepthBuffer),
            (this.resolveStencilBuffer = e.resolveStencilBuffer),
            e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class Fs extends vv {
        constructor(e = 1, t = 1, i = {}) {
          super(e, t, i), (this.isWebGLRenderTarget = !0);
        }
      }
      class eg extends Kt {
        constructor(e = null, t = 1, i = 1, s = 1) {
          super(null),
            (this.isDataArrayTexture = !0),
            (this.image = { data: e, width: t, height: i, depth: s }),
            (this.magFilter = sn),
            (this.minFilter = sn),
            (this.wrapR = es),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.layerUpdates = new Set());
        }
        addLayerUpdate(e) {
          this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class wv extends Kt {
        constructor(e = null, t = 1, i = 1, s = 1) {
          super(null),
            (this.isData3DTexture = !0),
            (this.image = { data: e, width: t, height: i, depth: s }),
            (this.magFilter = sn),
            (this.minFilter = sn),
            (this.wrapR = es),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class ji {
        constructor(e = new R(1 / 0, 1 / 0, 1 / 0), t = new R(-1 / 0, -1 / 0, -1 / 0)) {
          (this.isBox3 = !0), (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(Vn.fromArray(e, t));
          return this;
        }
        setFromBufferAttribute(e) {
          this.makeEmpty();
          for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(Vn.fromBufferAttribute(e, t));
          return this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const i = Vn.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
        }
        setFromObject(e, t = !1) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
          e.updateWorldMatrix(!1, !1);
          const i = e.geometry;
          if (i !== void 0) {
            const r = i.getAttribute("position");
            if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
              for (let A = 0, o = r.count; A < o; A++)
                e.isMesh === !0 ? e.getVertexPosition(A, Vn) : Vn.fromBufferAttribute(r, A), Vn.applyMatrix4(e.matrixWorld), this.expandByPoint(Vn);
            else
              e.boundingBox !== void 0
                ? (e.boundingBox === null && e.computeBoundingBox(), HA.copy(e.boundingBox))
                : (i.boundingBox === null && i.computeBoundingBox(), HA.copy(i.boundingBox)),
                HA.applyMatrix4(e.matrixWorld),
                this.union(HA);
          }
          const s = e.children;
          for (let r = 0, A = s.length; r < A; r++) this.expandByObject(s[r], t);
          return this;
        }
        containsPoint(e) {
          return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(e) {
          return (
            e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
          );
        }
        intersectsSphere(e) {
          return this.clampPoint(e.center, Vn), Vn.distanceToSquared(e.center) <= e.radius * e.radius;
        }
        intersectsPlane(e) {
          let t, i;
          return (
            e.normal.x > 0 ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x)) : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
            t <= -e.constant && i >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(Jr),
            QA.subVectors(this.max, Jr),
            Vs.subVectors(e.a, Jr),
            Ws.subVectors(e.b, Jr),
            Ks.subVectors(e.c, Jr),
            Qi.subVectors(Ws, Vs),
            Vi.subVectors(Ks, Ws),
            gs.subVectors(Vs, Ks);
          let t = [
            0,
            -Qi.z,
            Qi.y,
            0,
            -Vi.z,
            Vi.y,
            0,
            -gs.z,
            gs.y,
            Qi.z,
            0,
            -Qi.x,
            Vi.z,
            0,
            -Vi.x,
            gs.z,
            0,
            -gs.x,
            -Qi.y,
            Qi.x,
            0,
            -Vi.y,
            Vi.x,
            0,
            -gs.y,
            gs.x,
            0,
          ];
          return !Qa(t, Vs, Ws, Ks, QA) || ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Qa(t, Vs, Ws, Ks, QA))
            ? !1
            : (VA.crossVectors(Qi, Vi), (t = [VA.x, VA.y, VA.z]), Qa(t, Vs, Ws, Ks, QA));
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return this.clampPoint(e, Vn).distanceTo(e);
        }
        getBoundingSphere(e) {
          return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), (e.radius = this.getSize(Vn).length() * 0.5)), e;
        }
        intersect(e) {
          return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty()
            ? this
            : (vi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              vi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              vi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              vi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              vi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              vi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              vi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              vi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(vi),
              this);
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
        toJSON() {
          return { min: this.min.toArray(), max: this.max.toArray() };
        }
        fromJSON(e) {
          return this.min.fromArray(e.min), this.max.fromArray(e.max), this;
        }
      }
      const vi = [new R(), new R(), new R(), new R(), new R(), new R(), new R(), new R()],
        Vn = new R(),
        HA = new ji(),
        Vs = new R(),
        Ws = new R(),
        Ks = new R(),
        Qi = new R(),
        Vi = new R(),
        gs = new R(),
        Jr = new R(),
        QA = new R(),
        VA = new R(),
        Ps = new R();
      function Qa(n, e, t, i, s) {
        for (let r = 0, A = n.length - 3; r <= A; r += 3) {
          Ps.fromArray(n, r);
          const o = s.x * Math.abs(Ps.x) + s.y * Math.abs(Ps.y) + s.z * Math.abs(Ps.z),
            a = e.dot(Ps),
            c = t.dot(Ps),
            l = i.dot(Ps);
          if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > o) return !1;
        }
        return !0;
      }
      const _v = new ji(),
        Zr = new R(),
        Va = new R();
      class pi {
        constructor(e = new R(), t = -1) {
          (this.isSphere = !0), (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const i = this.center;
          t !== void 0 ? i.copy(t) : _v.setFromPoints(e).getCenter(i);
          let s = 0;
          for (let r = 0, A = e.length; r < A; r++) s = Math.max(s, i.distanceToSquared(e[r]));
          return (this.radius = Math.sqrt(s)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const i = this.center.distanceToSquared(e);
          return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
        }
        getBoundingBox(e) {
          return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
        }
        applyMatrix4(e) {
          return this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this;
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
          Zr.subVectors(e, this.center);
          const t = Zr.lengthSq();
          if (t > this.radius * this.radius) {
            const i = Math.sqrt(t),
              s = (i - this.radius) * 0.5;
            this.center.addScaledVector(Zr, s / i), (this.radius += s);
          }
          return this;
        }
        union(e) {
          return e.isEmpty()
            ? this
            : this.isEmpty()
            ? (this.copy(e), this)
            : (this.center.equals(e.center) === !0
                ? (this.radius = Math.max(this.radius, e.radius))
                : (Va.subVectors(e.center, this.center).setLength(e.radius),
                  this.expandByPoint(Zr.copy(e.center).add(Va)),
                  this.expandByPoint(Zr.copy(e.center).sub(Va))),
              this);
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          return { radius: this.radius, center: this.center.toArray() };
        }
        fromJSON(e) {
          return (this.radius = e.radius), this.center.fromArray(e.center), this;
        }
      }
      const wi = new R(),
        Wa = new R(),
        WA = new R(),
        Wi = new R(),
        Ka = new R(),
        KA = new R(),
        Ya = new R();
      class wa {
        constructor(e = new R(), t = new R(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
        }
        at(e, t) {
          return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, wi)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const i = t.dot(this.direction);
          return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = wi.subVectors(e, this.origin).dot(this.direction);
          return t < 0 ? this.origin.distanceToSquared(e) : (wi.copy(this.origin).addScaledVector(this.direction, t), wi.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, i, s) {
          Wa.copy(e).add(t).multiplyScalar(0.5), WA.copy(t).sub(e).normalize(), Wi.copy(this.origin).sub(Wa);
          const r = e.distanceTo(t) * 0.5,
            A = -this.direction.dot(WA),
            o = Wi.dot(this.direction),
            a = -Wi.dot(WA),
            c = Wi.lengthSq(),
            l = Math.abs(1 - A * A);
          let u, h, d, m;
          if (l > 0)
            if (((u = A * a - o), (h = A * o - a), (m = r * l), u >= 0))
              if (h >= -m)
                if (h <= m) {
                  const g = 1 / l;
                  (u *= g), (h *= g), (d = u * (u + A * h + 2 * o) + h * (A * u + h + 2 * a) + c);
                } else (h = r), (u = Math.max(0, -(A * h + o))), (d = -u * u + h * (h + 2 * a) + c);
              else (h = -r), (u = Math.max(0, -(A * h + o))), (d = -u * u + h * (h + 2 * a) + c);
            else
              h <= -m
                ? ((u = Math.max(0, -(-A * r + o))), (h = u > 0 ? -r : Math.min(Math.max(-r, -a), r)), (d = -u * u + h * (h + 2 * a) + c))
                : h <= m
                ? ((u = 0), (h = Math.min(Math.max(-r, -a), r)), (d = h * (h + 2 * a) + c))
                : ((u = Math.max(0, -(A * r + o))), (h = u > 0 ? r : Math.min(Math.max(-r, -a), r)), (d = -u * u + h * (h + 2 * a) + c));
          else (h = A > 0 ? -r : r), (u = Math.max(0, -(A * h + o))), (d = -u * u + h * (h + 2 * a) + c);
          return i && i.copy(this.origin).addScaledVector(this.direction, u), s && s.copy(Wa).addScaledVector(WA, h), d;
        }
        intersectSphere(e, t) {
          wi.subVectors(e.center, this.origin);
          const i = wi.dot(this.direction),
            s = wi.dot(wi) - i * i,
            r = e.radius * e.radius;
          if (s > r) return null;
          const A = Math.sqrt(r - s),
            o = i - A,
            a = i + A;
          return a < 0 ? null : o < 0 ? this.at(a, t) : this.at(o, t);
        }
        intersectsSphere(e) {
          return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
          const i = -(this.origin.dot(e.normal) + e.constant) / t;
          return i >= 0 ? i : null;
        }
        intersectPlane(e, t) {
          const i = this.distanceToPlane(e);
          return i === null ? null : this.at(i, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let i, s, r, A, o, a;
          const c = 1 / this.direction.x,
            l = 1 / this.direction.y,
            u = 1 / this.direction.z,
            h = this.origin;
          return (
            c >= 0 ? ((i = (e.min.x - h.x) * c), (s = (e.max.x - h.x) * c)) : ((i = (e.max.x - h.x) * c), (s = (e.min.x - h.x) * c)),
            l >= 0 ? ((r = (e.min.y - h.y) * l), (A = (e.max.y - h.y) * l)) : ((r = (e.max.y - h.y) * l), (A = (e.min.y - h.y) * l)),
            i > A ||
            r > s ||
            ((r > i || isNaN(i)) && (i = r),
            (A < s || isNaN(s)) && (s = A),
            u >= 0 ? ((o = (e.min.z - h.z) * u), (a = (e.max.z - h.z) * u)) : ((o = (e.max.z - h.z) * u), (a = (e.min.z - h.z) * u)),
            i > a || o > s) ||
            ((o > i || i !== i) && (i = o), (a < s || s !== s) && (s = a), s < 0)
              ? null
              : this.at(i >= 0 ? i : s, t)
          );
        }
        intersectsBox(e) {
          return this.intersectBox(e, wi) !== null;
        }
        intersectTriangle(e, t, i, s, r) {
          Ka.subVectors(t, e), KA.subVectors(i, e), Ya.crossVectors(Ka, KA);
          let A = this.direction.dot(Ya),
            o;
          if (A > 0) {
            if (s) return null;
            o = 1;
          } else if (A < 0) (o = -1), (A = -A);
          else return null;
          Wi.subVectors(this.origin, e);
          const a = o * this.direction.dot(KA.crossVectors(Wi, KA));
          if (a < 0) return null;
          const c = o * this.direction.dot(Ka.cross(Wi));
          if (c < 0 || a + c > A) return null;
          const l = -o * Wi.dot(Ya);
          return l < 0 ? null : this.at(l / A, r);
        }
        applyMatrix4(e) {
          return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
        }
        equals(e) {
          return e.origin.equals(this.origin) && e.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class ke {
        constructor(e, t, i, s, r, A, o, a, c, l, u, h, d, m, g, p) {
          (ke.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            e !== void 0 && this.set(e, t, i, s, r, A, o, a, c, l, u, h, d, m, g, p);
        }
        set(e, t, i, s, r, A, o, a, c, l, u, h, d, m, g, p) {
          const f = this.elements;
          return (
            (f[0] = e),
            (f[4] = t),
            (f[8] = i),
            (f[12] = s),
            (f[1] = r),
            (f[5] = A),
            (f[9] = o),
            (f[13] = a),
            (f[2] = c),
            (f[6] = l),
            (f[10] = u),
            (f[14] = h),
            (f[3] = d),
            (f[7] = m),
            (f[11] = g),
            (f[15] = p),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new ke().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            i = e.elements;
          return (
            (t[0] = i[0]),
            (t[1] = i[1]),
            (t[2] = i[2]),
            (t[3] = i[3]),
            (t[4] = i[4]),
            (t[5] = i[5]),
            (t[6] = i[6]),
            (t[7] = i[7]),
            (t[8] = i[8]),
            (t[9] = i[9]),
            (t[10] = i[10]),
            (t[11] = i[11]),
            (t[12] = i[12]),
            (t[13] = i[13]),
            (t[14] = i[14]),
            (t[15] = i[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            i = e.elements;
          return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(e, t, i) {
          return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(e, t, i) {
          return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(e) {
          const t = this.elements,
            i = e.elements,
            s = 1 / Ys.setFromMatrixColumn(e, 0).length(),
            r = 1 / Ys.setFromMatrixColumn(e, 1).length(),
            A = 1 / Ys.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = i[0] * s),
            (t[1] = i[1] * s),
            (t[2] = i[2] * s),
            (t[3] = 0),
            (t[4] = i[4] * r),
            (t[5] = i[5] * r),
            (t[6] = i[6] * r),
            (t[7] = 0),
            (t[8] = i[8] * A),
            (t[9] = i[9] * A),
            (t[10] = i[10] * A),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          const t = this.elements,
            i = e.x,
            s = e.y,
            r = e.z,
            A = Math.cos(i),
            o = Math.sin(i),
            a = Math.cos(s),
            c = Math.sin(s),
            l = Math.cos(r),
            u = Math.sin(r);
          if (e.order === "XYZ") {
            const h = A * l,
              d = A * u,
              m = o * l,
              g = o * u;
            (t[0] = a * l),
              (t[4] = -a * u),
              (t[8] = c),
              (t[1] = d + m * c),
              (t[5] = h - g * c),
              (t[9] = -o * a),
              (t[2] = g - h * c),
              (t[6] = m + d * c),
              (t[10] = A * a);
          } else if (e.order === "YXZ") {
            const h = a * l,
              d = a * u,
              m = c * l,
              g = c * u;
            (t[0] = h + g * o),
              (t[4] = m * o - d),
              (t[8] = A * c),
              (t[1] = A * u),
              (t[5] = A * l),
              (t[9] = -o),
              (t[2] = d * o - m),
              (t[6] = g + h * o),
              (t[10] = A * a);
          } else if (e.order === "ZXY") {
            const h = a * l,
              d = a * u,
              m = c * l,
              g = c * u;
            (t[0] = h - g * o),
              (t[4] = -A * u),
              (t[8] = m + d * o),
              (t[1] = d + m * o),
              (t[5] = A * l),
              (t[9] = g - h * o),
              (t[2] = -A * c),
              (t[6] = o),
              (t[10] = A * a);
          } else if (e.order === "ZYX") {
            const h = A * l,
              d = A * u,
              m = o * l,
              g = o * u;
            (t[0] = a * l),
              (t[4] = m * c - d),
              (t[8] = h * c + g),
              (t[1] = a * u),
              (t[5] = g * c + h),
              (t[9] = d * c - m),
              (t[2] = -c),
              (t[6] = o * a),
              (t[10] = A * a);
          } else if (e.order === "YZX") {
            const h = A * a,
              d = A * c,
              m = o * a,
              g = o * c;
            (t[0] = a * l),
              (t[4] = g - h * u),
              (t[8] = m * u + d),
              (t[1] = u),
              (t[5] = A * l),
              (t[9] = -o * l),
              (t[2] = -c * l),
              (t[6] = d * u + m),
              (t[10] = h - g * u);
          } else if (e.order === "XZY") {
            const h = A * a,
              d = A * c,
              m = o * a,
              g = o * c;
            (t[0] = a * l),
              (t[4] = -u),
              (t[8] = c * l),
              (t[1] = h * u + g),
              (t[5] = A * l),
              (t[9] = d * u - m),
              (t[2] = m * u - d),
              (t[6] = o * l),
              (t[10] = g * u + h);
          }
          return (t[3] = 0), (t[7] = 0), (t[11] = 0), (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1), this;
        }
        makeRotationFromQuaternion(e) {
          return this.compose(xv, e, yv);
        }
        lookAt(e, t, i) {
          const s = this.elements;
          return (
            xn.subVectors(e, t),
            xn.lengthSq() === 0 && (xn.z = 1),
            xn.normalize(),
            Ki.crossVectors(i, xn),
            Ki.lengthSq() === 0 && (Math.abs(i.z) === 1 ? (xn.x += 1e-4) : (xn.z += 1e-4), xn.normalize(), Ki.crossVectors(i, xn)),
            Ki.normalize(),
            YA.crossVectors(xn, Ki),
            (s[0] = Ki.x),
            (s[4] = YA.x),
            (s[8] = xn.x),
            (s[1] = Ki.y),
            (s[5] = YA.y),
            (s[9] = xn.y),
            (s[2] = Ki.z),
            (s[6] = YA.z),
            (s[10] = xn.z),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements,
            s = t.elements,
            r = this.elements,
            A = i[0],
            o = i[4],
            a = i[8],
            c = i[12],
            l = i[1],
            u = i[5],
            h = i[9],
            d = i[13],
            m = i[2],
            g = i[6],
            p = i[10],
            f = i[14],
            E = i[3],
            T = i[7],
            _ = i[11],
            b = i[15],
            S = s[0],
            D = s[4],
            O = s[8],
            x = s[12],
            w = s[1],
            I = s[5],
            H = s[9],
            N = s[13],
            Y = s[2],
            q = s[6],
            V = s[10],
            J = s[14],
            k = s[3],
            oe = s[7],
            he = s[11],
            Me = s[15];
          return (
            (r[0] = A * S + o * w + a * Y + c * k),
            (r[4] = A * D + o * I + a * q + c * oe),
            (r[8] = A * O + o * H + a * V + c * he),
            (r[12] = A * x + o * N + a * J + c * Me),
            (r[1] = l * S + u * w + h * Y + d * k),
            (r[5] = l * D + u * I + h * q + d * oe),
            (r[9] = l * O + u * H + h * V + d * he),
            (r[13] = l * x + u * N + h * J + d * Me),
            (r[2] = m * S + g * w + p * Y + f * k),
            (r[6] = m * D + g * I + p * q + f * oe),
            (r[10] = m * O + g * H + p * V + f * he),
            (r[14] = m * x + g * N + p * J + f * Me),
            (r[3] = E * S + T * w + _ * Y + b * k),
            (r[7] = E * D + T * I + _ * q + b * oe),
            (r[11] = E * O + T * H + _ * V + b * he),
            (r[15] = E * x + T * N + _ * J + b * Me),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            i = e[4],
            s = e[8],
            r = e[12],
            A = e[1],
            o = e[5],
            a = e[9],
            c = e[13],
            l = e[2],
            u = e[6],
            h = e[10],
            d = e[14],
            m = e[3],
            g = e[7],
            p = e[11],
            f = e[15];
          return (
            m * (+r * a * u - s * c * u - r * o * h + i * c * h + s * o * d - i * a * d) +
            g * (+t * a * d - t * c * h + r * A * h - s * A * d + s * c * l - r * a * l) +
            p * (+t * c * u - t * o * d - r * A * u + i * A * d + r * o * l - i * c * l) +
            f * (-s * o * l - t * a * u + t * o * h + s * A * u - i * A * h + i * a * l)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, i) {
          const s = this.elements;
          return e.isVector3 ? ((s[12] = e.x), (s[13] = e.y), (s[14] = e.z)) : ((s[12] = e), (s[13] = t), (s[14] = i)), this;
        }
        invert() {
          const e = this.elements,
            t = e[0],
            i = e[1],
            s = e[2],
            r = e[3],
            A = e[4],
            o = e[5],
            a = e[6],
            c = e[7],
            l = e[8],
            u = e[9],
            h = e[10],
            d = e[11],
            m = e[12],
            g = e[13],
            p = e[14],
            f = e[15],
            E = u * p * c - g * h * c + g * a * d - o * p * d - u * a * f + o * h * f,
            T = m * h * c - l * p * c - m * a * d + A * p * d + l * a * f - A * h * f,
            _ = l * g * c - m * u * c + m * o * d - A * g * d - l * o * f + A * u * f,
            b = m * u * a - l * g * a - m * o * h + A * g * h + l * o * p - A * u * p,
            S = t * E + i * T + s * _ + r * b;
          if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const D = 1 / S;
          return (
            (e[0] = E * D),
            (e[1] = (g * h * r - u * p * r - g * s * d + i * p * d + u * s * f - i * h * f) * D),
            (e[2] = (o * p * r - g * a * r + g * s * c - i * p * c - o * s * f + i * a * f) * D),
            (e[3] = (u * a * r - o * h * r - u * s * c + i * h * c + o * s * d - i * a * d) * D),
            (e[4] = T * D),
            (e[5] = (l * p * r - m * h * r + m * s * d - t * p * d - l * s * f + t * h * f) * D),
            (e[6] = (m * a * r - A * p * r - m * s * c + t * p * c + A * s * f - t * a * f) * D),
            (e[7] = (A * h * r - l * a * r + l * s * c - t * h * c - A * s * d + t * a * d) * D),
            (e[8] = _ * D),
            (e[9] = (m * u * r - l * g * r - m * i * d + t * g * d + l * i * f - t * u * f) * D),
            (e[10] = (A * g * r - m * o * r + m * i * c - t * g * c - A * i * f + t * o * f) * D),
            (e[11] = (l * o * r - A * u * r - l * i * c + t * u * c + A * i * d - t * o * d) * D),
            (e[12] = b * D),
            (e[13] = (l * g * s - m * u * s + m * i * h - t * g * h - l * i * p + t * u * p) * D),
            (e[14] = (m * o * s - A * g * s - m * i * a + t * g * a + A * i * p - t * o * p) * D),
            (e[15] = (A * u * s - l * o * s + l * i * a - t * u * a - A * i * h + t * o * h) * D),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            i = e.x,
            s = e.y,
            r = e.z;
          return (
            (t[0] *= i),
            (t[4] *= s),
            (t[8] *= r),
            (t[1] *= i),
            (t[5] *= s),
            (t[9] *= r),
            (t[2] *= i),
            (t[6] *= s),
            (t[10] *= r),
            (t[3] *= i),
            (t[7] *= s),
            (t[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, i, s));
        }
        makeTranslation(e, t, i) {
          return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(e, t) {
          const i = Math.cos(t),
            s = Math.sin(t),
            r = 1 - i,
            A = e.x,
            o = e.y,
            a = e.z,
            c = r * A,
            l = r * o;
          return (
            this.set(
              c * A + i,
              c * o - s * a,
              c * a + s * o,
              0,
              c * o + s * a,
              l * o + i,
              l * a - s * A,
              0,
              c * a - s * o,
              l * a + s * A,
              r * a * a + i,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, i) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, i, s, r, A) {
          return this.set(1, i, r, 0, e, 1, A, 0, t, s, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, i) {
          const s = this.elements,
            r = t._x,
            A = t._y,
            o = t._z,
            a = t._w,
            c = r + r,
            l = A + A,
            u = o + o,
            h = r * c,
            d = r * l,
            m = r * u,
            g = A * l,
            p = A * u,
            f = o * u,
            E = a * c,
            T = a * l,
            _ = a * u,
            b = i.x,
            S = i.y,
            D = i.z;
          return (
            (s[0] = (1 - (g + f)) * b),
            (s[1] = (d + _) * b),
            (s[2] = (m - T) * b),
            (s[3] = 0),
            (s[4] = (d - _) * S),
            (s[5] = (1 - (h + f)) * S),
            (s[6] = (p + E) * S),
            (s[7] = 0),
            (s[8] = (m + T) * D),
            (s[9] = (p - E) * D),
            (s[10] = (1 - (h + g)) * D),
            (s[11] = 0),
            (s[12] = e.x),
            (s[13] = e.y),
            (s[14] = e.z),
            (s[15] = 1),
            this
          );
        }
        decompose(e, t, i) {
          const s = this.elements;
          let r = Ys.set(s[0], s[1], s[2]).length();
          const A = Ys.set(s[4], s[5], s[6]).length(),
            o = Ys.set(s[8], s[9], s[10]).length();
          this.determinant() < 0 && (r = -r), (e.x = s[12]), (e.y = s[13]), (e.z = s[14]), Wn.copy(this);
          const c = 1 / r,
            l = 1 / A,
            u = 1 / o;
          return (
            (Wn.elements[0] *= c),
            (Wn.elements[1] *= c),
            (Wn.elements[2] *= c),
            (Wn.elements[4] *= l),
            (Wn.elements[5] *= l),
            (Wn.elements[6] *= l),
            (Wn.elements[8] *= u),
            (Wn.elements[9] *= u),
            (Wn.elements[10] *= u),
            t.setFromRotationMatrix(Wn),
            (i.x = r),
            (i.y = A),
            (i.z = o),
            this
          );
        }
        makePerspective(e, t, i, s, r, A, o = bi) {
          const a = this.elements,
            c = (2 * r) / (t - e),
            l = (2 * r) / (i - s),
            u = (t + e) / (t - e),
            h = (i + s) / (i - s);
          let d, m;
          if (o === bi) (d = -(A + r) / (A - r)), (m = (-2 * A * r) / (A - r));
          else if (o === No) (d = -A / (A - r)), (m = (-A * r) / (A - r));
          else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
          return (
            (a[0] = c),
            (a[4] = 0),
            (a[8] = u),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = l),
            (a[9] = h),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = d),
            (a[14] = m),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, i, s, r, A, o = bi) {
          const a = this.elements,
            c = 1 / (t - e),
            l = 1 / (i - s),
            u = 1 / (A - r),
            h = (t + e) * c,
            d = (i + s) * l;
          let m, g;
          if (o === bi) (m = (A + r) * u), (g = -2 * u);
          else if (o === No) (m = r * u), (g = -1 * u);
          else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
          return (
            (a[0] = 2 * c),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -h),
            (a[1] = 0),
            (a[5] = 2 * l),
            (a[9] = 0),
            (a[13] = -d),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = g),
            (a[14] = -m),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            i = e.elements;
          for (let s = 0; s < 16; s++) if (t[s] !== i[s]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return (
            (e[t] = i[0]),
            (e[t + 1] = i[1]),
            (e[t + 2] = i[2]),
            (e[t + 3] = i[3]),
            (e[t + 4] = i[4]),
            (e[t + 5] = i[5]),
            (e[t + 6] = i[6]),
            (e[t + 7] = i[7]),
            (e[t + 8] = i[8]),
            (e[t + 9] = i[9]),
            (e[t + 10] = i[10]),
            (e[t + 11] = i[11]),
            (e[t + 12] = i[12]),
            (e[t + 13] = i[13]),
            (e[t + 14] = i[14]),
            (e[t + 15] = i[15]),
            e
          );
        }
      }
      const Ys = new R(),
        Wn = new ke(),
        xv = new R(0, 0, 0),
        yv = new R(1, 1, 1),
        Ki = new R(),
        YA = new R(),
        xn = new R(),
        Of = new ke(),
        Lf = new fs();
      class fi {
        constructor(e = 0, t = 0, i = 0, s = fi.DEFAULT_ORDER) {
          (this.isEuler = !0), (this._x = e), (this._y = t), (this._z = i), (this._order = s);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, i, s = this._order) {
          return (this._x = e), (this._y = t), (this._z = i), (this._order = s), this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (this._x = e._x), (this._y = e._y), (this._z = e._z), (this._order = e._order), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e, t = this._order, i = !0) {
          const s = e.elements,
            r = s[0],
            A = s[4],
            o = s[8],
            a = s[1],
            c = s[5],
            l = s[9],
            u = s[2],
            h = s[6],
            d = s[10];
          switch (t) {
            case "XYZ":
              (this._y = Math.asin(Qe(o, -1, 1))),
                Math.abs(o) < 0.9999999 ? ((this._x = Math.atan2(-l, d)), (this._z = Math.atan2(-A, r))) : ((this._x = Math.atan2(h, c)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-Qe(l, -1, 1))),
                Math.abs(l) < 0.9999999 ? ((this._y = Math.atan2(o, d)), (this._z = Math.atan2(a, c))) : ((this._y = Math.atan2(-u, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(Qe(h, -1, 1))),
                Math.abs(h) < 0.9999999 ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-A, c))) : ((this._y = 0), (this._z = Math.atan2(a, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-Qe(u, -1, 1))),
                Math.abs(u) < 0.9999999 ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(a, r))) : ((this._x = 0), (this._z = Math.atan2(-A, c)));
              break;
            case "YZX":
              (this._z = Math.asin(Qe(a, -1, 1))),
                Math.abs(a) < 0.9999999 ? ((this._x = Math.atan2(-l, c)), (this._y = Math.atan2(-u, r))) : ((this._x = 0), (this._y = Math.atan2(o, d)));
              break;
            case "XZY":
              (this._z = Math.asin(-Qe(A, -1, 1))),
                Math.abs(A) < 0.9999999 ? ((this._x = Math.atan2(h, c)), (this._y = Math.atan2(o, r))) : ((this._x = Math.atan2(-l, d)), (this._y = 0));
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
          }
          return (this._order = t), i === !0 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, i) {
          return Of.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Of, t, i);
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return Lf.setFromEuler(this), this.setFromQuaternion(Lf, e);
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
        }
        fromArray(e) {
          return (this._x = e[0]), (this._y = e[1]), (this._z = e[2]), e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._order), e;
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      fi.DEFAULT_ORDER = "XYZ";
      class tg {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = ((1 << e) | 0) >>> 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
          return (this.mask & ((1 << e) | 0)) !== 0;
        }
      }
      let Tv = 0;
      const Uf = new R(),
        qs = new fs(),
        _i = new ke(),
        qA = new R(),
        $r = new R(),
        Ev = new R(),
        Dv = new fs(),
        Ff = new R(1, 0, 0),
        Nf = new R(0, 1, 0),
        kf = new R(0, 0, 1),
        Gf = { type: "added" },
        Mv = { type: "removed" },
        Xs = { type: "childadded", child: null },
        qa = { type: "childremoved", child: null };
      class It extends Hr {
        constructor() {
          super(),
            (this.isObject3D = !0),
            Object.defineProperty(this, "id", { value: Tv++ }),
            (this.uuid = Jn()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = It.DEFAULT_UP.clone());
          const e = new R(),
            t = new fi(),
            i = new fs(),
            s = new R(1, 1, 1);
          function r() {
            i.setFromEuler(t, !1);
          }
          function A() {
            t.setFromQuaternion(i, void 0, !1);
          }
          t._onChange(r),
            i._onChange(A),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: e },
              rotation: { configurable: !0, enumerable: !0, value: t },
              quaternion: { configurable: !0, enumerable: !0, value: i },
              scale: { configurable: !0, enumerable: !0, value: s },
              modelViewMatrix: { value: new ke() },
              normalMatrix: { value: new Ne() },
            }),
            (this.matrix = new ke()),
            (this.matrixWorld = new ke()),
            (this.matrixAutoUpdate = It.DEFAULT_MATRIX_AUTO_UPDATE),
            (this.matrixWorldAutoUpdate = It.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new tg()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.customDepthMaterial = void 0),
            (this.customDistanceMaterial = void 0),
            (this.userData = {});
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return qs.setFromAxisAngle(e, t), this.quaternion.multiply(qs), this;
        }
        rotateOnWorldAxis(e, t) {
          return qs.setFromAxisAngle(e, t), this.quaternion.premultiply(qs), this;
        }
        rotateX(e) {
          return this.rotateOnAxis(Ff, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(Nf, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(kf, e);
        }
        translateOnAxis(e, t) {
          return Uf.copy(e).applyQuaternion(this.quaternion), this.position.add(Uf.multiplyScalar(t)), this;
        }
        translateX(e) {
          return this.translateOnAxis(Ff, e);
        }
        translateY(e) {
          return this.translateOnAxis(Nf, e);
        }
        translateZ(e) {
          return this.translateOnAxis(kf, e);
        }
        localToWorld(e) {
          return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return this.updateWorldMatrix(!0, !1), e.applyMatrix4(_i.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, i) {
          e.isVector3 ? qA.copy(e) : qA.set(e, t, i);
          const s = this.parent;
          this.updateWorldMatrix(!0, !1),
            $r.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? _i.lookAt($r, qA, this.up) : _i.lookAt(qA, $r, this.up),
            this.quaternion.setFromRotationMatrix(_i),
            s && (_i.extractRotation(s.matrixWorld), qs.setFromRotationMatrix(_i), this.quaternion.premultiply(qs.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return e === this
            ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this)
            : (e && e.isObject3D
                ? (e.removeFromParent(),
                  (e.parent = this),
                  this.children.push(e),
                  e.dispatchEvent(Gf),
                  (Xs.child = e),
                  this.dispatchEvent(Xs),
                  (Xs.child = null))
                : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
              this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this;
          }
          const t = this.children.indexOf(e);
          return (
            t !== -1 && ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(Mv), (qa.child = e), this.dispatchEvent(qa), (qa.child = null)), this
          );
        }
        removeFromParent() {
          const e = this.parent;
          return e !== null && e.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            _i.copy(this.matrixWorld).invert(),
            e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), _i.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(_i),
            e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.updateWorldMatrix(!1, !0),
            e.dispatchEvent(Gf),
            (Xs.child = e),
            this.dispatchEvent(Xs),
            (Xs.child = null),
            this
          );
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let i = 0, s = this.children.length; i < s; i++) {
            const A = this.children[i].getObjectByProperty(e, t);
            if (A !== void 0) return A;
          }
        }
        getObjectsByProperty(e, t, i = []) {
          this[e] === t && i.push(this);
          const s = this.children;
          for (let r = 0, A = s.length; r < A; r++) s[r].getObjectsByProperty(e, t, i);
          return i;
        }
        getWorldPosition(e) {
          return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(e) {
          return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose($r, e, Ev), e;
        }
        getWorldScale(e) {
          return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose($r, Dv, e), e;
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let i = 0, s = t.length; i < s; i++) t[i].traverse(e);
        }
        traverseVisible(e) {
          if (this.visible === !1) return;
          e(this);
          const t = this.children;
          for (let i = 0, s = t.length; i < s; i++) t[i].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
              (this.matrixWorldAutoUpdate === !0 &&
                (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
              (this.matrixWorldNeedsUpdate = !1),
              (e = !0));
          const t = this.children;
          for (let i = 0, s = t.length; i < s; i++) t[i].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const i = this.parent;
          if (
            (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrixWorldAutoUpdate === !0 &&
              (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
            t === !0)
          ) {
            const s = this.children;
            for (let r = 0, A = s.length; r < A; r++) s[r].updateWorldMatrix(!1, !0);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string",
            i = {};
          t &&
            ((e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }),
            (i.metadata = { version: 4.7, type: "Object", generator: "Object3D.toJSON" }));
          const s = {};
          (s.uuid = this.uuid),
            (s.type = this.type),
            this.name !== "" && (s.name = this.name),
            this.castShadow === !0 && (s.castShadow = !0),
            this.receiveShadow === !0 && (s.receiveShadow = !0),
            this.visible === !1 && (s.visible = !1),
            this.frustumCulled === !1 && (s.frustumCulled = !1),
            this.renderOrder !== 0 && (s.renderOrder = this.renderOrder),
            Object.keys(this.userData).length > 0 && (s.userData = this.userData),
            (s.layers = this.layers.mask),
            (s.matrix = this.matrix.toArray()),
            (s.up = this.up.toArray()),
            this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((s.type = "InstancedMesh"),
              (s.count = this.count),
              (s.instanceMatrix = this.instanceMatrix.toJSON()),
              this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())),
            this.isBatchedMesh &&
              ((s.type = "BatchedMesh"),
              (s.perObjectFrustumCulled = this.perObjectFrustumCulled),
              (s.sortObjects = this.sortObjects),
              (s.drawRanges = this._drawRanges),
              (s.reservedRanges = this._reservedRanges),
              (s.geometryInfo = this._geometryInfo.map((o) => ({
                ...o,
                boundingBox: o.boundingBox ? o.boundingBox.toJSON() : void 0,
                boundingSphere: o.boundingSphere ? o.boundingSphere.toJSON() : void 0,
              }))),
              (s.instanceInfo = this._instanceInfo.map((o) => ({ ...o }))),
              (s.availableInstanceIds = this._availableInstanceIds.slice()),
              (s.availableGeometryIds = this._availableGeometryIds.slice()),
              (s.nextIndexStart = this._nextIndexStart),
              (s.nextVertexStart = this._nextVertexStart),
              (s.geometryCount = this._geometryCount),
              (s.maxInstanceCount = this._maxInstanceCount),
              (s.maxVertexCount = this._maxVertexCount),
              (s.maxIndexCount = this._maxIndexCount),
              (s.geometryInitialized = this._geometryInitialized),
              (s.matricesTexture = this._matricesTexture.toJSON(e)),
              (s.indirectTexture = this._indirectTexture.toJSON(e)),
              this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)),
              this.boundingSphere !== null && (s.boundingSphere = this.boundingSphere.toJSON()),
              this.boundingBox !== null && (s.boundingBox = this.boundingBox.toJSON()));
          function r(o, a) {
            return o[a.uuid] === void 0 && (o[a.uuid] = a.toJSON(e)), a.uuid;
          }
          if (this.isScene)
            this.background &&
              (this.background.isColor
                ? (s.background = this.background.toJSON())
                : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)),
              this.environment &&
                this.environment.isTexture &&
                this.environment.isRenderTargetTexture !== !0 &&
                (s.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            s.geometry = r(e.geometries, this.geometry);
            const o = this.geometry.parameters;
            if (o !== void 0 && o.shapes !== void 0) {
              const a = o.shapes;
              if (Array.isArray(a))
                for (let c = 0, l = a.length; c < l; c++) {
                  const u = a[c];
                  r(e.shapes, u);
                }
              else r(e.shapes, a);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((s.bindMode = this.bindMode),
              (s.bindMatrix = this.bindMatrix.toArray()),
              this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), (s.skeleton = this.skeleton.uuid))),
            this.material !== void 0)
          )
            if (Array.isArray(this.material)) {
              const o = [];
              for (let a = 0, c = this.material.length; a < c; a++) o.push(r(e.materials, this.material[a]));
              s.material = o;
            } else s.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            s.children = [];
            for (let o = 0; o < this.children.length; o++) s.children.push(this.children[o].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            s.animations = [];
            for (let o = 0; o < this.animations.length; o++) {
              const a = this.animations[o];
              s.animations.push(r(e.animations, a));
            }
          }
          if (t) {
            const o = A(e.geometries),
              a = A(e.materials),
              c = A(e.textures),
              l = A(e.images),
              u = A(e.shapes),
              h = A(e.skeletons),
              d = A(e.animations),
              m = A(e.nodes);
            o.length > 0 && (i.geometries = o),
              a.length > 0 && (i.materials = a),
              c.length > 0 && (i.textures = c),
              l.length > 0 && (i.images = l),
              u.length > 0 && (i.shapes = u),
              h.length > 0 && (i.skeletons = h),
              d.length > 0 && (i.animations = d),
              m.length > 0 && (i.nodes = m);
          }
          return (i.object = s), i;
          function A(o) {
            const a = [];
            for (const c in o) {
              const l = o[c];
              delete l.metadata, a.push(l);
            }
            return a;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.animations = e.animations.slice()),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            t === !0)
          )
            for (let i = 0; i < e.children.length; i++) {
              const s = e.children[i];
              this.add(s.clone());
            }
          return this;
        }
      }
      It.DEFAULT_UP = new R(0, 1, 0);
      It.DEFAULT_MATRIX_AUTO_UPDATE = !0;
      It.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
      const Kn = new R(),
        xi = new R(),
        Xa = new R(),
        yi = new R(),
        Js = new R(),
        Zs = new R(),
        jf = new R(),
        Ja = new R(),
        Za = new R(),
        $a = new R(),
        ec = new st(),
        tc = new st(),
        nc = new st();
      class qn {
        constructor(e = new R(), t = new R(), i = new R()) {
          (this.a = e), (this.b = t), (this.c = i);
        }
        static getNormal(e, t, i, s) {
          s.subVectors(i, t), Kn.subVectors(e, t), s.cross(Kn);
          const r = s.lengthSq();
          return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0);
        }
        static getBarycoord(e, t, i, s, r) {
          Kn.subVectors(s, t), xi.subVectors(i, t), Xa.subVectors(e, t);
          const A = Kn.dot(Kn),
            o = Kn.dot(xi),
            a = Kn.dot(Xa),
            c = xi.dot(xi),
            l = xi.dot(Xa),
            u = A * c - o * o;
          if (u === 0) return r.set(0, 0, 0), null;
          const h = 1 / u,
            d = (c * a - o * l) * h,
            m = (A * l - o * a) * h;
          return r.set(1 - d - m, m, d);
        }
        static containsPoint(e, t, i, s) {
          return this.getBarycoord(e, t, i, s, yi) === null ? !1 : yi.x >= 0 && yi.y >= 0 && yi.x + yi.y <= 1;
        }
        static getInterpolation(e, t, i, s, r, A, o, a) {
          return this.getBarycoord(e, t, i, s, yi) === null
            ? ((a.x = 0), (a.y = 0), "z" in a && (a.z = 0), "w" in a && (a.w = 0), null)
            : (a.setScalar(0), a.addScaledVector(r, yi.x), a.addScaledVector(A, yi.y), a.addScaledVector(o, yi.z), a);
        }
        static getInterpolatedAttribute(e, t, i, s, r, A) {
          return (
            ec.setScalar(0),
            tc.setScalar(0),
            nc.setScalar(0),
            ec.fromBufferAttribute(e, t),
            tc.fromBufferAttribute(e, i),
            nc.fromBufferAttribute(e, s),
            A.setScalar(0),
            A.addScaledVector(ec, r.x),
            A.addScaledVector(tc, r.y),
            A.addScaledVector(nc, r.z),
            A
          );
        }
        static isFrontFacing(e, t, i, s) {
          return Kn.subVectors(i, t), xi.subVectors(e, t), Kn.cross(xi).dot(s) < 0;
        }
        set(e, t, i) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
        }
        setFromPointsAndIndices(e, t, i, s) {
          return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[s]), this;
        }
        setFromAttributeAndIndices(e, t, i, s) {
          return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, s), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return Kn.subVectors(this.c, this.b), xi.subVectors(this.a, this.b), Kn.cross(xi).length() * 0.5;
        }
        getMidpoint(e) {
          return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return qn.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return qn.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getInterpolation(e, t, i, s, r) {
          return qn.getInterpolation(e, this.a, this.b, this.c, t, i, s, r);
        }
        containsPoint(e) {
          return qn.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return qn.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const i = this.a,
            s = this.b,
            r = this.c;
          let A, o;
          Js.subVectors(s, i), Zs.subVectors(r, i), Ja.subVectors(e, i);
          const a = Js.dot(Ja),
            c = Zs.dot(Ja);
          if (a <= 0 && c <= 0) return t.copy(i);
          Za.subVectors(e, s);
          const l = Js.dot(Za),
            u = Zs.dot(Za);
          if (l >= 0 && u <= l) return t.copy(s);
          const h = a * u - l * c;
          if (h <= 0 && a >= 0 && l <= 0) return (A = a / (a - l)), t.copy(i).addScaledVector(Js, A);
          $a.subVectors(e, r);
          const d = Js.dot($a),
            m = Zs.dot($a);
          if (m >= 0 && d <= m) return t.copy(r);
          const g = d * c - a * m;
          if (g <= 0 && c >= 0 && m <= 0) return (o = c / (c - m)), t.copy(i).addScaledVector(Zs, o);
          const p = l * m - d * u;
          if (p <= 0 && u - l >= 0 && d - m >= 0) return jf.subVectors(r, s), (o = (u - l) / (u - l + (d - m))), t.copy(s).addScaledVector(jf, o);
          const f = 1 / (p + g + h);
          return (A = g * f), (o = h * f), t.copy(i).addScaledVector(Js, A).addScaledVector(Zs, o);
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      const ng = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        Yi = { h: 0, s: 0, l: 0 },
        XA = { h: 0, s: 0, l: 0 };
      function ic(n, e, t) {
        return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n;
      }
      class Ue {
        constructor(e, t, i) {
          return (this.isColor = !0), (this.r = 1), (this.g = 1), (this.b = 1), this.set(e, t, i);
        }
        set(e, t, i) {
          if (t === void 0 && i === void 0) {
            const s = e;
            s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
          } else this.setRGB(e, t, i);
          return this;
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e, t = Yt) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (e & 255) / 255),
            Xe.colorSpaceToWorking(this, t),
            this
          );
        }
        setRGB(e, t, i, s = Xe.workingColorSpace) {
          return (this.r = e), (this.g = t), (this.b = i), Xe.colorSpaceToWorking(this, s), this;
        }
        setHSL(e, t, i, s = Xe.workingColorSpace) {
          if (((e = Vu(e, 1)), (t = Qe(t, 0, 1)), (i = Qe(i, 0, 1)), t === 0)) this.r = this.g = this.b = i;
          else {
            const r = i <= 0.5 ? i * (1 + t) : i + t - i * t,
              A = 2 * i - r;
            (this.r = ic(A, r, e + 1 / 3)), (this.g = ic(A, r, e)), (this.b = ic(A, r, e - 1 / 3));
          }
          return Xe.colorSpaceToWorking(this, s), this;
        }
        setStyle(e, t = Yt) {
          function i(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
          }
          let s;
          if ((s = /^(\w+)\(([^\)]*)\)/.exec(e))) {
            let r;
            const A = s[1],
              o = s[2];
            switch (A) {
              case "rgb":
              case "rgba":
                if ((r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)))
                  return (
                    i(r[4]),
                    this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t)
                  );
                if ((r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)))
                  return (
                    i(r[4]),
                    this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t)
                  );
                break;
              case "hsl":
              case "hsla":
                if ((r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)))
                  return i(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + e);
            }
          } else if ((s = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const r = s[1],
              A = r.length;
            if (A === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
            if (A === 6) return this.setHex(parseInt(r, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e);
          } else if (e && e.length > 0) return this.setColorName(e, t);
          return this;
        }
        setColorName(e, t = Yt) {
          const i = ng[e.toLowerCase()];
          return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copySRGBToLinear(e) {
          return (this.r = Li(e.r)), (this.g = Li(e.g)), (this.b = Li(e.b)), this;
        }
        copyLinearToSRGB(e) {
          return (this.r = hr(e.r)), (this.g = hr(e.g)), (this.b = hr(e.b)), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = Yt) {
          return (
            Xe.workingToColorSpace(Xt.copy(this), e),
            Math.round(Qe(Xt.r * 255, 0, 255)) * 65536 + Math.round(Qe(Xt.g * 255, 0, 255)) * 256 + Math.round(Qe(Xt.b * 255, 0, 255))
          );
        }
        getHexString(e = Yt) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = Xe.workingColorSpace) {
          Xe.workingToColorSpace(Xt.copy(this), t);
          const i = Xt.r,
            s = Xt.g,
            r = Xt.b,
            A = Math.max(i, s, r),
            o = Math.min(i, s, r);
          let a, c;
          const l = (o + A) / 2;
          if (o === A) (a = 0), (c = 0);
          else {
            const u = A - o;
            switch (((c = l <= 0.5 ? u / (A + o) : u / (2 - A - o)), A)) {
              case i:
                a = (s - r) / u + (s < r ? 6 : 0);
                break;
              case s:
                a = (r - i) / u + 2;
                break;
              case r:
                a = (i - s) / u + 4;
                break;
            }
            a /= 6;
          }
          return (e.h = a), (e.s = c), (e.l = l), e;
        }
        getRGB(e, t = Xe.workingColorSpace) {
          return Xe.workingToColorSpace(Xt.copy(this), t), (e.r = Xt.r), (e.g = Xt.g), (e.b = Xt.b), e;
        }
        getStyle(e = Yt) {
          Xe.workingToColorSpace(Xt.copy(this), e);
          const t = Xt.r,
            i = Xt.g,
            s = Xt.b;
          return e !== Yt
            ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})`
            : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(s * 255)})`;
        }
        offsetHSL(e, t, i) {
          return this.getHSL(Yi), this.setHSL(Yi.h + e, Yi.s + t, Yi.l + i);
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this;
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (this.r = Math.max(0, this.r - e.r)), (this.g = Math.max(0, this.g - e.g)), (this.b = Math.max(0, this.b - e.b)), this;
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (this.r += (e.r - this.r) * t), (this.g += (e.g - this.g) * t), (this.b += (e.b - this.b) * t), this;
        }
        lerpColors(e, t, i) {
          return (this.r = e.r + (t.r - e.r) * i), (this.g = e.g + (t.g - e.g) * i), (this.b = e.b + (t.b - e.b) * i), this;
        }
        lerpHSL(e, t) {
          this.getHSL(Yi), e.getHSL(XA);
          const i = dA(Yi.h, XA.h, t),
            s = dA(Yi.s, XA.s, t),
            r = dA(Yi.l, XA.l, t);
          return this.setHSL(i, s, r), this;
        }
        setFromVector3(e) {
          return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
        }
        applyMatrix3(e) {
          const t = this.r,
            i = this.g,
            s = this.b,
            r = e.elements;
          return (this.r = r[0] * t + r[3] * i + r[6] * s), (this.g = r[1] * t + r[4] * i + r[7] * s), (this.b = r[2] * t + r[5] * i + r[8] * s), this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const Xt = new Ue();
      Ue.NAMES = ng;
      let Cv = 0;
      class ci extends Hr {
        constructor() {
          super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, "id", { value: Cv++ }),
            (this.uuid = Jn()),
            (this.name = ""),
            (this.type = "Material"),
            (this.blending = lr),
            (this.side = ki),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.alphaHash = !1),
            (this.blendSrc = Vc),
            (this.blendDst = Wc),
            (this.blendEquation = Ms),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.blendColor = new Ue(0, 0, 0)),
            (this.blendAlpha = 0),
            (this.depthFunc = Er),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = Cf),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = Hs),
            (this.stencilZFail = Hs),
            (this.stencilZPass = Hs),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.forceSinglePass = !1),
            (this.allowOverride = !0),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== void 0)
            for (const t in e) {
              const i = e[t];
              if (i === void 0) {
                console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                continue;
              }
              const s = this[t];
              if (s === void 0) {
                console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                continue;
              }
              s && s.isColor ? s.set(i) : s && s.isVector3 && i && i.isVector3 ? s.copy(i) : (this[t] = i);
            }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = { textures: {}, images: {} });
          const i = { metadata: { version: 4.7, type: "Material", generator: "Material.toJSON" } };
          (i.uuid = this.uuid),
            (i.type = this.type),
            this.name !== "" && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            this.roughness !== void 0 && (i.roughness = this.roughness),
            this.metalness !== void 0 && (i.metalness = this.metalness),
            this.sheen !== void 0 && (i.sheen = this.sheen),
            this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
            this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
            this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
            this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
            this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
            this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
            this.shininess !== void 0 && (i.shininess = this.shininess),
            this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid), (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            this.dispersion !== void 0 && (i.dispersion = this.dispersion),
            this.iridescence !== void 0 && (i.iridescence = this.iridescence),
            this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
            this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
            this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
            this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
            this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
            this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
            this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && ((i.lightMap = this.lightMap.toJSON(e).uuid), (i.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap && this.aoMap.isTexture && ((i.aoMap = this.aoMap.toJSON(e).uuid), (i.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap && this.bumpMap.isTexture && ((i.bumpMap = this.bumpMap.toJSON(e).uuid), (i.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((i.normalMap = this.normalMap.toJSON(e).uuid), (i.normalMapType = this.normalMapType), (i.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
              (i.displacementScale = this.displacementScale),
              (i.displacementBias = this.displacementBias)),
            this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap && this.envMap.isTexture && ((i.envMap = this.envMap.toJSON(e).uuid), this.combine !== void 0 && (i.combine = this.combine)),
            this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()),
            this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
            this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
            this.transmission !== void 0 && (i.transmission = this.transmission),
            this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            this.thickness !== void 0 && (i.thickness = this.thickness),
            this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (i.size = this.size),
            this.shadowSide !== null && (i.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
            this.blending !== lr && (i.blending = this.blending),
            this.side !== ki && (i.side = this.side),
            this.vertexColors === !0 && (i.vertexColors = !0),
            this.opacity < 1 && (i.opacity = this.opacity),
            this.transparent === !0 && (i.transparent = !0),
            this.blendSrc !== Vc && (i.blendSrc = this.blendSrc),
            this.blendDst !== Wc && (i.blendDst = this.blendDst),
            this.blendEquation !== Ms && (i.blendEquation = this.blendEquation),
            this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
            this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
            this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
            this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
            this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
            this.depthFunc !== Er && (i.depthFunc = this.depthFunc),
            this.depthTest === !1 && (i.depthTest = this.depthTest),
            this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
            this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
            this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
            this.stencilFunc !== Cf && (i.stencilFunc = this.stencilFunc),
            this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
            this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
            this.stencilFail !== Hs && (i.stencilFail = this.stencilFail),
            this.stencilZFail !== Hs && (i.stencilZFail = this.stencilZFail),
            this.stencilZPass !== Hs && (i.stencilZPass = this.stencilZPass),
            this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
            this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
            this.polygonOffset === !0 && (i.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
            this.dashSize !== void 0 && (i.dashSize = this.dashSize),
            this.gapSize !== void 0 && (i.gapSize = this.gapSize),
            this.scale !== void 0 && (i.scale = this.scale),
            this.dithering === !0 && (i.dithering = !0),
            this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
            this.alphaHash === !0 && (i.alphaHash = !0),
            this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
            this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
            this.forceSinglePass === !0 && (i.forceSinglePass = !0),
            this.wireframe === !0 && (i.wireframe = !0),
            this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
            this.flatShading === !0 && (i.flatShading = !0),
            this.visible === !1 && (i.visible = !1),
            this.toneMapped === !1 && (i.toneMapped = !1),
            this.fog === !1 && (i.fog = !1),
            Object.keys(this.userData).length > 0 && (i.userData = this.userData);
          function s(r) {
            const A = [];
            for (const o in r) {
              const a = r[o];
              delete a.metadata, A.push(a);
            }
            return A;
          }
          if (t) {
            const r = s(e.textures),
              A = s(e.images);
            r.length > 0 && (i.textures = r), A.length > 0 && (i.images = A);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            this.blendColor.copy(e.blendColor),
            (this.blendAlpha = e.blendAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let i = null;
          if (t !== null) {
            const s = t.length;
            i = new Array(s);
            for (let r = 0; r !== s; ++r) i[r] = t[r].clone();
          }
          return (
            (this.clippingPlanes = i),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaHash = e.alphaHash),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.forceSinglePass = e.forceSinglePass),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
      }
      class bs extends ci {
        constructor(e) {
          super(),
            (this.isMeshBasicMaterial = !0),
            (this.type = "MeshBasicMaterial"),
            (this.color = new Ue(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new fi()),
            (this.combine = km),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      const Lt = new R(),
        JA = new qe();
      let Sv = 0;
      class rn {
        constructor(e, t, i = !1) {
          if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          (this.isBufferAttribute = !0),
            Object.defineProperty(this, "id", { value: Sv++ }),
            (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.normalized = i),
            (this.usage = Sl),
            (this.updateRanges = []),
            (this.gpuType = Xn),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({ start: e, count: t });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            (this.gpuType = e.gpuType),
            this
          );
        }
        copyAt(e, t, i) {
          (e *= this.itemSize), (i *= t.itemSize);
          for (let s = 0, r = this.itemSize; s < r; s++) this.array[e + s] = t.array[i + s];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++) JA.fromBufferAttribute(this, t), JA.applyMatrix3(e), this.setXY(t, JA.x, JA.y);
          else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++) Lt.fromBufferAttribute(this, t), Lt.applyMatrix3(e), this.setXYZ(t, Lt.x, Lt.y, Lt.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.count; t < i; t++) Lt.fromBufferAttribute(this, t), Lt.applyMatrix4(e), this.setXYZ(t, Lt.x, Lt.y, Lt.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++) Lt.fromBufferAttribute(this, t), Lt.applyNormalMatrix(e), this.setXYZ(t, Lt.x, Lt.y, Lt.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++) Lt.fromBufferAttribute(this, t), Lt.transformDirection(e), this.setXYZ(t, Lt.x, Lt.y, Lt.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getComponent(e, t) {
          let i = this.array[e * this.itemSize + t];
          return this.normalized && (i = Yn(i, this.array)), i;
        }
        setComponent(e, t, i) {
          return this.normalized && (i = at(i, this.array)), (this.array[e * this.itemSize + t] = i), this;
        }
        getX(e) {
          let t = this.array[e * this.itemSize];
          return this.normalized && (t = Yn(t, this.array)), t;
        }
        setX(e, t) {
          return this.normalized && (t = at(t, this.array)), (this.array[e * this.itemSize] = t), this;
        }
        getY(e) {
          let t = this.array[e * this.itemSize + 1];
          return this.normalized && (t = Yn(t, this.array)), t;
        }
        setY(e, t) {
          return this.normalized && (t = at(t, this.array)), (this.array[e * this.itemSize + 1] = t), this;
        }
        getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          return this.normalized && (t = Yn(t, this.array)), t;
        }
        setZ(e, t) {
          return this.normalized && (t = at(t, this.array)), (this.array[e * this.itemSize + 2] = t), this;
        }
        getW(e) {
          let t = this.array[e * this.itemSize + 3];
          return this.normalized && (t = Yn(t, this.array)), t;
        }
        setW(e, t) {
          return this.normalized && (t = at(t, this.array)), (this.array[e * this.itemSize + 3] = t), this;
        }
        setXY(e, t, i) {
          return (
            (e *= this.itemSize), this.normalized && ((t = at(t, this.array)), (i = at(i, this.array))), (this.array[e + 0] = t), (this.array[e + 1] = i), this
          );
        }
        setXYZ(e, t, i, s) {
          return (
            (e *= this.itemSize),
            this.normalized && ((t = at(t, this.array)), (i = at(i, this.array)), (s = at(s, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            (this.array[e + 2] = s),
            this
          );
        }
        setXYZW(e, t, i, s, r) {
          return (
            (e *= this.itemSize),
            this.normalized && ((t = at(t, this.array)), (i = at(i, this.array)), (s = at(s, this.array)), (r = at(r, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            (this.array[e + 2] = s),
            (this.array[e + 3] = r),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
          return this.name !== "" && (e.name = this.name), this.usage !== Sl && (e.usage = this.usage), e;
        }
      }
      class ig extends rn {
        constructor(e, t, i) {
          super(new Uint16Array(e), t, i);
        }
      }
      class sg extends rn {
        constructor(e, t, i) {
          super(new Uint32Array(e), t, i);
        }
      }
      class Ui extends rn {
        constructor(e, t, i) {
          super(new Float32Array(e), t, i);
        }
      }
      let Iv = 0;
      const Ln = new ke(),
        sc = new It(),
        $s = new R(),
        yn = new ji(),
        eA = new ji(),
        Qt = new R();
      class mi extends Hr {
        constructor() {
          super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, "id", { value: Iv++ }),
            (this.uuid = Jn()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.indirect = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return Array.isArray(e) ? (this.index = new ($m(e) ? sg : ig)(e, 1)) : (this.index = e), this;
        }
        setIndirect(e) {
          return (this.indirect = e), this;
        }
        getIndirect() {
          return this.indirect;
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== void 0;
        }
        addGroup(e, t, i = 0) {
          this.groups.push({ start: e, count: t, materialIndex: i });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const i = this.attributes.normal;
          if (i !== void 0) {
            const r = new Ne().getNormalMatrix(e);
            i.applyNormalMatrix(r), (i.needsUpdate = !0);
          }
          const s = this.attributes.tangent;
          return (
            s !== void 0 && (s.transformDirection(e), (s.needsUpdate = !0)),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return Ln.makeRotationFromQuaternion(e), this.applyMatrix4(Ln), this;
        }
        rotateX(e) {
          return Ln.makeRotationX(e), this.applyMatrix4(Ln), this;
        }
        rotateY(e) {
          return Ln.makeRotationY(e), this.applyMatrix4(Ln), this;
        }
        rotateZ(e) {
          return Ln.makeRotationZ(e), this.applyMatrix4(Ln), this;
        }
        translate(e, t, i) {
          return Ln.makeTranslation(e, t, i), this.applyMatrix4(Ln), this;
        }
        scale(e, t, i) {
          return Ln.makeScale(e, t, i), this.applyMatrix4(Ln), this;
        }
        lookAt(e) {
          return sc.lookAt(e), sc.updateMatrix(), this.applyMatrix4(sc.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter($s).negate(), this.translate($s.x, $s.y, $s.z), this;
        }
        setFromPoints(e) {
          const t = this.getAttribute("position");
          if (t === void 0) {
            const i = [];
            for (let s = 0, r = e.length; s < r; s++) {
              const A = e[s];
              i.push(A.x, A.y, A.z || 0);
            }
            this.setAttribute("position", new Ui(i, 3));
          } else {
            const i = Math.min(e.length, t.count);
            for (let s = 0; s < i; s++) {
              const r = e[s];
              t.setXYZ(s, r.x, r.y, r.z || 0);
            }
            e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
              (t.needsUpdate = !0);
          }
          return this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new ji());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
              this.boundingBox.set(new R(-1 / 0, -1 / 0, -1 / 0), new R(1 / 0, 1 / 0, 1 / 0));
            return;
          }
          if (e !== void 0) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let i = 0, s = t.length; i < s; i++) {
                const r = t[i];
                yn.setFromBufferAttribute(r),
                  this.morphTargetsRelative
                    ? (Qt.addVectors(this.boundingBox.min, yn.min),
                      this.boundingBox.expandByPoint(Qt),
                      Qt.addVectors(this.boundingBox.max, yn.max),
                      this.boundingBox.expandByPoint(Qt))
                    : (this.boundingBox.expandByPoint(yn.min), this.boundingBox.expandByPoint(yn.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new pi());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
              this.boundingSphere.set(new R(), 1 / 0);
            return;
          }
          if (e) {
            const i = this.boundingSphere.center;
            if ((yn.setFromBufferAttribute(e), t))
              for (let r = 0, A = t.length; r < A; r++) {
                const o = t[r];
                eA.setFromBufferAttribute(o),
                  this.morphTargetsRelative
                    ? (Qt.addVectors(yn.min, eA.min), yn.expandByPoint(Qt), Qt.addVectors(yn.max, eA.max), yn.expandByPoint(Qt))
                    : (yn.expandByPoint(eA.min), yn.expandByPoint(eA.max));
              }
            yn.getCenter(i);
            let s = 0;
            for (let r = 0, A = e.count; r < A; r++) Qt.fromBufferAttribute(e, r), (s = Math.max(s, i.distanceToSquared(Qt)));
            if (t)
              for (let r = 0, A = t.length; r < A; r++) {
                const o = t[r],
                  a = this.morphTargetsRelative;
                for (let c = 0, l = o.count; c < l; c++)
                  Qt.fromBufferAttribute(o, c), a && ($s.fromBufferAttribute(e, c), Qt.add($s)), (s = Math.max(s, i.distanceToSquared(Qt)));
              }
            (this.boundingSphere.radius = Math.sqrt(s)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const i = t.position,
            s = t.normal,
            r = t.uv;
          this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new rn(new Float32Array(4 * i.count), 4));
          const A = this.getAttribute("tangent"),
            o = [],
            a = [];
          for (let O = 0; O < i.count; O++) (o[O] = new R()), (a[O] = new R());
          const c = new R(),
            l = new R(),
            u = new R(),
            h = new qe(),
            d = new qe(),
            m = new qe(),
            g = new R(),
            p = new R();
          function f(O, x, w) {
            c.fromBufferAttribute(i, O),
              l.fromBufferAttribute(i, x),
              u.fromBufferAttribute(i, w),
              h.fromBufferAttribute(r, O),
              d.fromBufferAttribute(r, x),
              m.fromBufferAttribute(r, w),
              l.sub(c),
              u.sub(c),
              d.sub(h),
              m.sub(h);
            const I = 1 / (d.x * m.y - m.x * d.y);
            isFinite(I) &&
              (g.copy(l).multiplyScalar(m.y).addScaledVector(u, -d.y).multiplyScalar(I),
              p.copy(u).multiplyScalar(d.x).addScaledVector(l, -m.x).multiplyScalar(I),
              o[O].add(g),
              o[x].add(g),
              o[w].add(g),
              a[O].add(p),
              a[x].add(p),
              a[w].add(p));
          }
          let E = this.groups;
          E.length === 0 && (E = [{ start: 0, count: e.count }]);
          for (let O = 0, x = E.length; O < x; ++O) {
            const w = E[O],
              I = w.start,
              H = w.count;
            for (let N = I, Y = I + H; N < Y; N += 3) f(e.getX(N + 0), e.getX(N + 1), e.getX(N + 2));
          }
          const T = new R(),
            _ = new R(),
            b = new R(),
            S = new R();
          function D(O) {
            b.fromBufferAttribute(s, O), S.copy(b);
            const x = o[O];
            T.copy(x), T.sub(b.multiplyScalar(b.dot(x))).normalize(), _.crossVectors(S, x);
            const I = _.dot(a[O]) < 0 ? -1 : 1;
            A.setXYZW(O, T.x, T.y, T.z, I);
          }
          for (let O = 0, x = E.length; O < x; ++O) {
            const w = E[O],
              I = w.start,
              H = w.count;
            for (let N = I, Y = I + H; N < Y; N += 3) D(e.getX(N + 0)), D(e.getX(N + 1)), D(e.getX(N + 2));
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0) (i = new rn(new Float32Array(t.count * 3), 3)), this.setAttribute("normal", i);
            else for (let h = 0, d = i.count; h < d; h++) i.setXYZ(h, 0, 0, 0);
            const s = new R(),
              r = new R(),
              A = new R(),
              o = new R(),
              a = new R(),
              c = new R(),
              l = new R(),
              u = new R();
            if (e)
              for (let h = 0, d = e.count; h < d; h += 3) {
                const m = e.getX(h + 0),
                  g = e.getX(h + 1),
                  p = e.getX(h + 2);
                s.fromBufferAttribute(t, m),
                  r.fromBufferAttribute(t, g),
                  A.fromBufferAttribute(t, p),
                  l.subVectors(A, r),
                  u.subVectors(s, r),
                  l.cross(u),
                  o.fromBufferAttribute(i, m),
                  a.fromBufferAttribute(i, g),
                  c.fromBufferAttribute(i, p),
                  o.add(l),
                  a.add(l),
                  c.add(l),
                  i.setXYZ(m, o.x, o.y, o.z),
                  i.setXYZ(g, a.x, a.y, a.z),
                  i.setXYZ(p, c.x, c.y, c.z);
              }
            else
              for (let h = 0, d = t.count; h < d; h += 3)
                s.fromBufferAttribute(t, h + 0),
                  r.fromBufferAttribute(t, h + 1),
                  A.fromBufferAttribute(t, h + 2),
                  l.subVectors(A, r),
                  u.subVectors(s, r),
                  l.cross(u),
                  i.setXYZ(h + 0, l.x, l.y, l.z),
                  i.setXYZ(h + 1, l.x, l.y, l.z),
                  i.setXYZ(h + 2, l.x, l.y, l.z);
            this.normalizeNormals(), (i.needsUpdate = !0);
          }
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, i = e.count; t < i; t++) Qt.fromBufferAttribute(e, t), Qt.normalize(), e.setXYZ(t, Qt.x, Qt.y, Qt.z);
        }
        toNonIndexed() {
          function e(o, a) {
            const c = o.array,
              l = o.itemSize,
              u = o.normalized,
              h = new c.constructor(a.length * l);
            let d = 0,
              m = 0;
            for (let g = 0, p = a.length; g < p; g++) {
              o.isInterleavedBufferAttribute ? (d = a[g] * o.data.stride + o.offset) : (d = a[g] * l);
              for (let f = 0; f < l; f++) h[m++] = c[d++];
            }
            return new rn(h, l, u);
          }
          if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const t = new mi(),
            i = this.index.array,
            s = this.attributes;
          for (const o in s) {
            const a = s[o],
              c = e(a, i);
            t.setAttribute(o, c);
          }
          const r = this.morphAttributes;
          for (const o in r) {
            const a = [],
              c = r[o];
            for (let l = 0, u = c.length; l < u; l++) {
              const h = c[l],
                d = e(h, i);
              a.push(d);
            }
            t.morphAttributes[o] = a;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const A = this.groups;
          for (let o = 0, a = A.length; o < a; o++) {
            const c = A[o];
            t.addGroup(c.start, c.count, c.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = { metadata: { version: 4.7, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            this.name !== "" && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            this.parameters !== void 0)
          ) {
            const a = this.parameters;
            for (const c in a) a[c] !== void 0 && (e[c] = a[c]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) });
          const i = this.attributes;
          for (const a in i) {
            const c = i[a];
            e.data.attributes[a] = c.toJSON(e.data);
          }
          const s = {};
          let r = !1;
          for (const a in this.morphAttributes) {
            const c = this.morphAttributes[a],
              l = [];
            for (let u = 0, h = c.length; u < h; u++) {
              const d = c[u];
              l.push(d.toJSON(e.data));
            }
            l.length > 0 && ((s[a] = l), (r = !0));
          }
          r && ((e.data.morphAttributes = s), (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const A = this.groups;
          A.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(A)));
          const o = this.boundingSphere;
          return o !== null && (e.data.boundingSphere = o.toJSON()), e;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.index = null), (this.attributes = {}), (this.morphAttributes = {}), (this.groups = []), (this.boundingBox = null), (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const i = e.index;
          i !== null && this.setIndex(i.clone());
          const s = e.attributes;
          for (const c in s) {
            const l = s[c];
            this.setAttribute(c, l.clone(t));
          }
          const r = e.morphAttributes;
          for (const c in r) {
            const l = [],
              u = r[c];
            for (let h = 0, d = u.length; h < d; h++) l.push(u[h].clone(t));
            this.morphAttributes[c] = l;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const A = e.groups;
          for (let c = 0, l = A.length; c < l; c++) {
            const u = A[c];
            this.addGroup(u.start, u.count, u.materialIndex);
          }
          const o = e.boundingBox;
          o !== null && (this.boundingBox = o.clone());
          const a = e.boundingSphere;
          return (
            a !== null && (this.boundingSphere = a.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      const Hf = new ke(),
        vs = new wa(),
        ZA = new pi(),
        Qf = new R(),
        $A = new R(),
        eo = new R(),
        to = new R(),
        rc = new R(),
        no = new R(),
        Vf = new R(),
        io = new R();
      class En extends It {
        constructor(e = new mi(), t = new bs()) {
          super(),
            (this.isMesh = !0),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            (this.morphTargetDictionary = void 0),
            (this.morphTargetInfluences = void 0),
            (this.count = 1),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
            (this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes,
            i = Object.keys(t);
          if (i.length > 0) {
            const s = t[i[0]];
            if (s !== void 0) {
              (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
              for (let r = 0, A = s.length; r < A; r++) {
                const o = s[r].name || String(r);
                this.morphTargetInfluences.push(0), (this.morphTargetDictionary[o] = r);
              }
            }
          }
        }
        getVertexPosition(e, t) {
          const i = this.geometry,
            s = i.attributes.position,
            r = i.morphAttributes.position,
            A = i.morphTargetsRelative;
          t.fromBufferAttribute(s, e);
          const o = this.morphTargetInfluences;
          if (r && o) {
            no.set(0, 0, 0);
            for (let a = 0, c = r.length; a < c; a++) {
              const l = o[a],
                u = r[a];
              l !== 0 && (rc.fromBufferAttribute(u, e), A ? no.addScaledVector(rc, l) : no.addScaledVector(rc.sub(t), l));
            }
            t.add(no);
          }
          return t;
        }
        raycast(e, t) {
          const i = this.geometry,
            s = this.material,
            r = this.matrixWorld;
          s !== void 0 &&
            (i.boundingSphere === null && i.computeBoundingSphere(),
            ZA.copy(i.boundingSphere),
            ZA.applyMatrix4(r),
            vs.copy(e.ray).recast(e.near),
            !(ZA.containsPoint(vs.origin) === !1 && (vs.intersectSphere(ZA, Qf) === null || vs.origin.distanceToSquared(Qf) > (e.far - e.near) ** 2)) &&
              (Hf.copy(r).invert(),
              vs.copy(e.ray).applyMatrix4(Hf),
              !(i.boundingBox !== null && vs.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, vs)));
        }
        _computeIntersections(e, t, i) {
          let s;
          const r = this.geometry,
            A = this.material,
            o = r.index,
            a = r.attributes.position,
            c = r.attributes.uv,
            l = r.attributes.uv1,
            u = r.attributes.normal,
            h = r.groups,
            d = r.drawRange;
          if (o !== null)
            if (Array.isArray(A))
              for (let m = 0, g = h.length; m < g; m++) {
                const p = h[m],
                  f = A[p.materialIndex],
                  E = Math.max(p.start, d.start),
                  T = Math.min(o.count, Math.min(p.start + p.count, d.start + d.count));
                for (let _ = E, b = T; _ < b; _ += 3) {
                  const S = o.getX(_),
                    D = o.getX(_ + 1),
                    O = o.getX(_ + 2);
                  (s = so(this, f, e, i, c, l, u, S, D, O)), s && ((s.faceIndex = Math.floor(_ / 3)), (s.face.materialIndex = p.materialIndex), t.push(s));
                }
              }
            else {
              const m = Math.max(0, d.start),
                g = Math.min(o.count, d.start + d.count);
              for (let p = m, f = g; p < f; p += 3) {
                const E = o.getX(p),
                  T = o.getX(p + 1),
                  _ = o.getX(p + 2);
                (s = so(this, A, e, i, c, l, u, E, T, _)), s && ((s.faceIndex = Math.floor(p / 3)), t.push(s));
              }
            }
          else if (a !== void 0)
            if (Array.isArray(A))
              for (let m = 0, g = h.length; m < g; m++) {
                const p = h[m],
                  f = A[p.materialIndex],
                  E = Math.max(p.start, d.start),
                  T = Math.min(a.count, Math.min(p.start + p.count, d.start + d.count));
                for (let _ = E, b = T; _ < b; _ += 3) {
                  const S = _,
                    D = _ + 1,
                    O = _ + 2;
                  (s = so(this, f, e, i, c, l, u, S, D, O)), s && ((s.faceIndex = Math.floor(_ / 3)), (s.face.materialIndex = p.materialIndex), t.push(s));
                }
              }
            else {
              const m = Math.max(0, d.start),
                g = Math.min(a.count, d.start + d.count);
              for (let p = m, f = g; p < f; p += 3) {
                const E = p,
                  T = p + 1,
                  _ = p + 2;
                (s = so(this, A, e, i, c, l, u, E, T, _)), s && ((s.faceIndex = Math.floor(p / 3)), t.push(s));
              }
            }
        }
      }
      function bv(n, e, t, i, s, r, A, o) {
        let a;
        if ((e.side === fn ? (a = i.intersectTriangle(A, r, s, !0, o)) : (a = i.intersectTriangle(s, r, A, e.side === ki, o)), a === null)) return null;
        io.copy(o), io.applyMatrix4(n.matrixWorld);
        const c = t.ray.origin.distanceTo(io);
        return c < t.near || c > t.far ? null : { distance: c, point: io.clone(), object: n };
      }
      function so(n, e, t, i, s, r, A, o, a, c) {
        n.getVertexPosition(o, $A), n.getVertexPosition(a, eo), n.getVertexPosition(c, to);
        const l = bv(n, e, t, i, $A, eo, to, Vf);
        if (l) {
          const u = new R();
          qn.getBarycoord(Vf, $A, eo, to, u),
            s && (l.uv = qn.getInterpolatedAttribute(s, o, a, c, u, new qe())),
            r && (l.uv1 = qn.getInterpolatedAttribute(r, o, a, c, u, new qe())),
            A && ((l.normal = qn.getInterpolatedAttribute(A, o, a, c, u, new R())), l.normal.dot(i.direction) > 0 && l.normal.multiplyScalar(-1));
          const h = { a: o, b: a, c, normal: new R(), materialIndex: 0 };
          qn.getNormal($A, eo, to, h.normal), (l.face = h), (l.barycoord = u);
        }
        return l;
      }
      class BA extends mi {
        constructor(e = 1, t = 1, i = 1, s = 1, r = 1, A = 1) {
          super(), (this.type = "BoxGeometry"), (this.parameters = { width: e, height: t, depth: i, widthSegments: s, heightSegments: r, depthSegments: A });
          const o = this;
          (s = Math.floor(s)), (r = Math.floor(r)), (A = Math.floor(A));
          const a = [],
            c = [],
            l = [],
            u = [];
          let h = 0,
            d = 0;
          m("z", "y", "x", -1, -1, i, t, e, A, r, 0),
            m("z", "y", "x", 1, -1, i, t, -e, A, r, 1),
            m("x", "z", "y", 1, 1, e, i, t, s, A, 2),
            m("x", "z", "y", 1, -1, e, i, -t, s, A, 3),
            m("x", "y", "z", 1, -1, e, t, i, s, r, 4),
            m("x", "y", "z", -1, -1, e, t, -i, s, r, 5),
            this.setIndex(a),
            this.setAttribute("position", new Ui(c, 3)),
            this.setAttribute("normal", new Ui(l, 3)),
            this.setAttribute("uv", new Ui(u, 2));
          function m(g, p, f, E, T, _, b, S, D, O, x) {
            const w = _ / D,
              I = b / O,
              H = _ / 2,
              N = b / 2,
              Y = S / 2,
              q = D + 1,
              V = O + 1;
            let J = 0,
              k = 0;
            const oe = new R();
            for (let he = 0; he < V; he++) {
              const Me = he * I - N;
              for (let He = 0; He < q; He++) {
                const ht = He * w - H;
                (oe[g] = ht * E),
                  (oe[p] = Me * T),
                  (oe[f] = Y),
                  c.push(oe.x, oe.y, oe.z),
                  (oe[g] = 0),
                  (oe[p] = 0),
                  (oe[f] = S > 0 ? 1 : -1),
                  l.push(oe.x, oe.y, oe.z),
                  u.push(He / D),
                  u.push(1 - he / O),
                  (J += 1);
              }
            }
            for (let he = 0; he < O; he++)
              for (let Me = 0; Me < D; Me++) {
                const He = h + Me + q * he,
                  ht = h + Me + q * (he + 1),
                  Q = h + (Me + 1) + q * (he + 1),
                  te = h + (Me + 1) + q * he;
                a.push(He, ht, te), a.push(ht, Q, te), (k += 6);
              }
            o.addGroup(d, k, x), (d += k), (h += J);
          }
        }
        copy(e) {
          return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
        }
        static fromJSON(e) {
          return new BA(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
        }
      }
      function Ir(n) {
        const e = {};
        for (const t in n) {
          e[t] = {};
          for (const i in n[t]) {
            const s = n[t][i];
            s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion)
              ? s.isRenderTargetTexture
                ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), (e[t][i] = null))
                : (e[t][i] = s.clone())
              : Array.isArray(s)
              ? (e[t][i] = s.slice())
              : (e[t][i] = s);
          }
        }
        return e;
      }
      function tn(n) {
        const e = {};
        for (let t = 0; t < n.length; t++) {
          const i = Ir(n[t]);
          for (const s in i) e[s] = i[s];
        }
        return e;
      }
      function zv(n) {
        const e = [];
        for (let t = 0; t < n.length; t++) e.push(n[t].clone());
        return e;
      }
      function rg(n) {
        const e = n.getRenderTarget();
        return e === null ? n.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Xe.workingColorSpace;
      }
      const Rv = { clone: Ir, merge: tn };
      var Bv = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
        Ov = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class cs extends ci {
        constructor(e) {
          super(),
            (this.isShaderMaterial = !0),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.uniformsGroups = []),
            (this.vertexShader = Bv),
            (this.fragmentShader = Ov),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.forceSinglePass = !0),
            (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
            (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            e !== void 0 && this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = Ir(e.uniforms)),
            (this.uniformsGroups = zv(e.uniformsGroups)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const s in this.uniforms) {
            const A = this.uniforms[s].value;
            A && A.isTexture
              ? (t.uniforms[s] = { type: "t", value: A.toJSON(e).uuid })
              : A && A.isColor
              ? (t.uniforms[s] = { type: "c", value: A.getHex() })
              : A && A.isVector2
              ? (t.uniforms[s] = { type: "v2", value: A.toArray() })
              : A && A.isVector3
              ? (t.uniforms[s] = { type: "v3", value: A.toArray() })
              : A && A.isVector4
              ? (t.uniforms[s] = { type: "v4", value: A.toArray() })
              : A && A.isMatrix3
              ? (t.uniforms[s] = { type: "m3", value: A.toArray() })
              : A && A.isMatrix4
              ? (t.uniforms[s] = { type: "m4", value: A.toArray() })
              : (t.uniforms[s] = { value: A });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader),
            (t.lights = this.lights),
            (t.clipping = this.clipping);
          const i = {};
          for (const s in this.extensions) this.extensions[s] === !0 && (i[s] = !0);
          return Object.keys(i).length > 0 && (t.extensions = i), t;
        }
      }
      class Ag extends It {
        constructor() {
          super(),
            (this.isCamera = !0),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new ke()),
            (this.projectionMatrix = new ke()),
            (this.projectionMatrixInverse = new ke()),
            (this.coordinateSystem = bi);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            (this.coordinateSystem = e.coordinateSystem),
            this
          );
        }
        getWorldDirection(e) {
          return super.getWorldDirection(e).negate();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const qi = new R(),
        Wf = new qe(),
        Kf = new qe();
      class nn extends Ag {
        constructor(e = 50, t = 1, i = 0.1, s = 2e3) {
          super(),
            (this.isPerspectiveCamera = !0),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = i),
            (this.far = s),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = Sr * 2 * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(fA * 0.5 * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return Sr * 2 * Math.atan(Math.tan(fA * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(e, t, i) {
          qi.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            t.set(qi.x, qi.y).multiplyScalar(-e / qi.z),
            qi.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            i.set(qi.x, qi.y).multiplyScalar(-e / qi.z);
        }
        getViewSize(e, t) {
          return this.getViewBounds(e, Wf, Kf), t.subVectors(Kf, Wf);
        }
        setViewOffset(e, t, i, s, r, A) {
          (this.aspect = e / t),
            this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = i),
            (this.view.offsetY = s),
            (this.view.width = r),
            (this.view.height = A),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(fA * 0.5 * this.fov)) / this.zoom,
            i = 2 * t,
            s = this.aspect * i,
            r = -0.5 * s;
          const A = this.view;
          if (this.view !== null && this.view.enabled) {
            const a = A.fullWidth,
              c = A.fullHeight;
            (r += (A.offsetX * s) / a), (t -= (A.offsetY * i) / c), (s *= A.width / a), (i *= A.height / c);
          }
          const o = this.filmOffset;
          o !== 0 && (r += (e * o) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(r, r + s, t, t - i, e, this.far, this.coordinateSystem),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            this.view !== null && (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      const er = -90,
        tr = 1;
      class Lv extends It {
        constructor(e, t, i) {
          super(), (this.type = "CubeCamera"), (this.renderTarget = i), (this.coordinateSystem = null), (this.activeMipmapLevel = 0);
          const s = new nn(er, tr, e, t);
          (s.layers = this.layers), this.add(s);
          const r = new nn(er, tr, e, t);
          (r.layers = this.layers), this.add(r);
          const A = new nn(er, tr, e, t);
          (A.layers = this.layers), this.add(A);
          const o = new nn(er, tr, e, t);
          (o.layers = this.layers), this.add(o);
          const a = new nn(er, tr, e, t);
          (a.layers = this.layers), this.add(a);
          const c = new nn(er, tr, e, t);
          (c.layers = this.layers), this.add(c);
        }
        updateCoordinateSystem() {
          const e = this.coordinateSystem,
            t = this.children.concat(),
            [i, s, r, A, o, a] = t;
          for (const c of t) this.remove(c);
          if (e === bi)
            i.up.set(0, 1, 0),
              i.lookAt(1, 0, 0),
              s.up.set(0, 1, 0),
              s.lookAt(-1, 0, 0),
              r.up.set(0, 0, -1),
              r.lookAt(0, 1, 0),
              A.up.set(0, 0, 1),
              A.lookAt(0, -1, 0),
              o.up.set(0, 1, 0),
              o.lookAt(0, 0, 1),
              a.up.set(0, 1, 0),
              a.lookAt(0, 0, -1);
          else if (e === No)
            i.up.set(0, -1, 0),
              i.lookAt(-1, 0, 0),
              s.up.set(0, -1, 0),
              s.lookAt(1, 0, 0),
              r.up.set(0, 0, 1),
              r.lookAt(0, 1, 0),
              A.up.set(0, 0, -1),
              A.lookAt(0, -1, 0),
              o.up.set(0, -1, 0),
              o.lookAt(0, 0, 1),
              a.up.set(0, -1, 0),
              a.lookAt(0, 0, -1);
          else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
          for (const c of t) this.add(c), c.updateMatrixWorld();
        }
        update(e, t) {
          this.parent === null && this.updateMatrixWorld();
          const { renderTarget: i, activeMipmapLevel: s } = this;
          this.coordinateSystem !== e.coordinateSystem && ((this.coordinateSystem = e.coordinateSystem), this.updateCoordinateSystem());
          const [r, A, o, a, c, l] = this.children,
            u = e.getRenderTarget(),
            h = e.getActiveCubeFace(),
            d = e.getActiveMipmapLevel(),
            m = e.xr.enabled;
          e.xr.enabled = !1;
          const g = i.texture.generateMipmaps;
          (i.texture.generateMipmaps = !1),
            e.setRenderTarget(i, 0, s),
            e.render(t, r),
            e.setRenderTarget(i, 1, s),
            e.render(t, A),
            e.setRenderTarget(i, 2, s),
            e.render(t, o),
            e.setRenderTarget(i, 3, s),
            e.render(t, a),
            e.setRenderTarget(i, 4, s),
            e.render(t, c),
            (i.texture.generateMipmaps = g),
            e.setRenderTarget(i, 5, s),
            e.render(t, l),
            e.setRenderTarget(u, h, d),
            (e.xr.enabled = m),
            (i.texture.needsPMREMUpdate = !0);
        }
      }
      class og extends Kt {
        constructor(e = [], t = Dr, i, s, r, A, o, a, c, l) {
          super(e, t, i, s, r, A, o, a, c, l), (this.isCubeTexture = !0), (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class Uv extends Fs {
        constructor(e = 1, t = {}) {
          super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
          const i = { width: e, height: e, depth: 1 },
            s = [i, i, i, i, i, i];
          (this.texture = new og(s)), this._setTextureOptions(t), (this.texture.isRenderTargetTexture = !0);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.colorSpace = t.colorSpace),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const i = {
              uniforms: { tEquirect: { value: null } },
              vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
              fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            s = new BA(5, 5, 5),
            r = new cs({
              name: "CubemapFromEquirect",
              uniforms: Ir(i.uniforms),
              vertexShader: i.vertexShader,
              fragmentShader: i.fragmentShader,
              side: fn,
              blending: rs,
            });
          r.uniforms.tEquirect.value = t;
          const A = new En(s, r),
            o = t.minFilter;
          return (
            t.minFilter === Ii && (t.minFilter = Tn), new Lv(1, 10, this).update(e, A), (t.minFilter = o), A.geometry.dispose(), A.material.dispose(), this
          );
        }
        clear(e, t = !0, i = !0, s = !0) {
          const r = e.getRenderTarget();
          for (let A = 0; A < 6; A++) e.setRenderTarget(this, A), e.clear(t, i, s);
          e.setRenderTarget(r);
        }
      }
      class zs extends It {
        constructor() {
          super(), (this.isGroup = !0), (this.type = "Group");
        }
      }
      const Fv = { type: "move" };
      class Ac {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            this._hand === null &&
              ((this._hand = new zs()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            this._targetRay === null &&
              ((this._targetRay = new zs()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new R()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new R())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            this._grip === null &&
              ((this._grip = new zs()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new R()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new R())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            this._targetRay !== null && this._targetRay.dispatchEvent(e),
            this._grip !== null && this._grip.dispatchEvent(e),
            this._hand !== null && this._hand.dispatchEvent(e),
            this
          );
        }
        connect(e) {
          if (e && e.hand) {
            const t = this._hand;
            if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
          }
          return this.dispatchEvent({ type: "connected", data: e }), this;
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, i) {
          let s = null,
            r = null,
            A = null;
          const o = this._targetRay,
            a = this._grip,
            c = this._hand;
          if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
              A = !0;
              for (const g of e.hand.values()) {
                const p = t.getJointPose(g, i),
                  f = this._getHandJoint(c, g);
                p !== null &&
                  (f.matrix.fromArray(p.transform.matrix),
                  f.matrix.decompose(f.position, f.rotation, f.scale),
                  (f.matrixWorldNeedsUpdate = !0),
                  (f.jointRadius = p.radius)),
                  (f.visible = p !== null);
              }
              const l = c.joints["index-finger-tip"],
                u = c.joints["thumb-tip"],
                h = l.position.distanceTo(u.position),
                d = 0.02,
                m = 0.005;
              c.inputState.pinching && h > d + m
                ? ((c.inputState.pinching = !1), this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this }))
                : !c.inputState.pinching &&
                  h <= d - m &&
                  ((c.inputState.pinching = !0), this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this }));
            } else
              a !== null &&
                e.gripSpace &&
                ((r = t.getPose(e.gripSpace, i)),
                r !== null &&
                  (a.matrix.fromArray(r.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  (a.matrixWorldNeedsUpdate = !0),
                  r.linearVelocity ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(r.linearVelocity)) : (a.hasLinearVelocity = !1),
                  r.angularVelocity ? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(r.angularVelocity)) : (a.hasAngularVelocity = !1)));
            o !== null &&
              ((s = t.getPose(e.targetRaySpace, i)),
              s === null && r !== null && (s = r),
              s !== null &&
                (o.matrix.fromArray(s.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                (o.matrixWorldNeedsUpdate = !0),
                s.linearVelocity ? ((o.hasLinearVelocity = !0), o.linearVelocity.copy(s.linearVelocity)) : (o.hasLinearVelocity = !1),
                s.angularVelocity ? ((o.hasAngularVelocity = !0), o.angularVelocity.copy(s.angularVelocity)) : (o.hasAngularVelocity = !1),
                this.dispatchEvent(Fv)));
          }
          return o !== null && (o.visible = s !== null), a !== null && (a.visible = r !== null), c !== null && (c.visible = A !== null), this;
        }
        _getHandJoint(e, t) {
          if (e.joints[t.jointName] === void 0) {
            const i = new zs();
            (i.matrixAutoUpdate = !1), (i.visible = !1), (e.joints[t.jointName] = i), e.add(i);
          }
          return e.joints[t.jointName];
        }
      }
      class Nv extends It {
        constructor() {
          super(),
            (this.isScene = !0),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.backgroundBlurriness = 0),
            (this.backgroundIntensity = 1),
            (this.backgroundRotation = new fi()),
            (this.environmentIntensity = 1),
            (this.environmentRotation = new fi()),
            (this.overrideMaterial = null),
            typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null && (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            (this.backgroundBlurriness = e.backgroundBlurriness),
            (this.backgroundIntensity = e.backgroundIntensity),
            this.backgroundRotation.copy(e.backgroundRotation),
            (this.environmentIntensity = e.environmentIntensity),
            this.environmentRotation.copy(e.environmentRotation),
            e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            this.fog !== null && (t.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
            this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
            (t.object.backgroundRotation = this.backgroundRotation.toArray()),
            this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
            (t.object.environmentRotation = this.environmentRotation.toArray()),
            t
          );
        }
      }
      class kv {
        constructor(e, t) {
          (this.isInterleavedBuffer = !0),
            (this.array = e),
            (this.stride = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.usage = Sl),
            (this.updateRanges = []),
            (this.version = 0),
            (this.uuid = Jn());
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          e === !0 && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({ start: e, count: t });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return (this.array = new e.array.constructor(e.array)), (this.count = e.count), (this.stride = e.stride), (this.usage = e.usage), this;
        }
        copyAt(e, t, i) {
          (e *= this.stride), (i *= t.stride);
          for (let s = 0, r = this.stride; s < r; s++) this.array[e + s] = t.array[i + s];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Jn()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
          const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
            i = new this.constructor(t, this.stride);
          return i.setUsage(this.usage), i;
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        toJSON(e) {
          return (
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Jn()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
            { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride }
          );
        }
      }
      const en = new R();
      class Ku {
        constructor(e, t, i, s = !1) {
          (this.isInterleavedBufferAttribute = !0), (this.name = ""), (this.data = e), (this.itemSize = t), (this.offset = i), (this.normalized = s);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.data.count; t < i; t++) en.fromBufferAttribute(this, t), en.applyMatrix4(e), this.setXYZ(t, en.x, en.y, en.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++) en.fromBufferAttribute(this, t), en.applyNormalMatrix(e), this.setXYZ(t, en.x, en.y, en.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++) en.fromBufferAttribute(this, t), en.transformDirection(e), this.setXYZ(t, en.x, en.y, en.z);
          return this;
        }
        getComponent(e, t) {
          let i = this.array[e * this.data.stride + this.offset + t];
          return this.normalized && (i = Yn(i, this.array)), i;
        }
        setComponent(e, t, i) {
          return this.normalized && (i = at(i, this.array)), (this.data.array[e * this.data.stride + this.offset + t] = i), this;
        }
        setX(e, t) {
          return this.normalized && (t = at(t, this.array)), (this.data.array[e * this.data.stride + this.offset] = t), this;
        }
        setY(e, t) {
          return this.normalized && (t = at(t, this.array)), (this.data.array[e * this.data.stride + this.offset + 1] = t), this;
        }
        setZ(e, t) {
          return this.normalized && (t = at(t, this.array)), (this.data.array[e * this.data.stride + this.offset + 2] = t), this;
        }
        setW(e, t) {
          return this.normalized && (t = at(t, this.array)), (this.data.array[e * this.data.stride + this.offset + 3] = t), this;
        }
        getX(e) {
          let t = this.data.array[e * this.data.stride + this.offset];
          return this.normalized && (t = Yn(t, this.array)), t;
        }
        getY(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 1];
          return this.normalized && (t = Yn(t, this.array)), t;
        }
        getZ(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 2];
          return this.normalized && (t = Yn(t, this.array)), t;
        }
        getW(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 3];
          return this.normalized && (t = Yn(t, this.array)), t;
        }
        setXY(e, t, i) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized && ((t = at(t, this.array)), (i = at(i, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = i),
            this
          );
        }
        setXYZ(e, t, i, s) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized && ((t = at(t, this.array)), (i = at(i, this.array)), (s = at(s, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = i),
            (this.data.array[e + 2] = s),
            this
          );
        }
        setXYZW(e, t, i, s, r) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized && ((t = at(t, this.array)), (i = at(i, this.array)), (s = at(s, this.array)), (r = at(r, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = i),
            (this.data.array[e + 2] = s),
            (this.data.array[e + 3] = r),
            this
          );
        }
        clone(e) {
          if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
              const s = i * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[s + r]);
            }
            return new rn(new this.array.constructor(t), this.itemSize, this.normalized);
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
              new Ku(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            );
        }
        toJSON(e) {
          if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
              const s = i * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[s + r]);
            }
            return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
          } else
            return (
              e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
              e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
              { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized }
            );
        }
      }
      const Yf = new R(),
        qf = new st(),
        Xf = new st(),
        Gv = new R(),
        Jf = new ke(),
        ro = new R(),
        oc = new pi(),
        Zf = new ke(),
        ac = new wa();
      class jv extends En {
        constructor(e, t) {
          super(e, t),
            (this.isSkinnedMesh = !0),
            (this.type = "SkinnedMesh"),
            (this.bindMode = Tf),
            (this.bindMatrix = new ke()),
            (this.bindMatrixInverse = new ke()),
            (this.boundingBox = null),
            (this.boundingSphere = null);
        }
        computeBoundingBox() {
          const e = this.geometry;
          this.boundingBox === null && (this.boundingBox = new ji()), this.boundingBox.makeEmpty();
          const t = e.getAttribute("position");
          for (let i = 0; i < t.count; i++) this.getVertexPosition(i, ro), this.boundingBox.expandByPoint(ro);
        }
        computeBoundingSphere() {
          const e = this.geometry;
          this.boundingSphere === null && (this.boundingSphere = new pi()), this.boundingSphere.makeEmpty();
          const t = e.getAttribute("position");
          for (let i = 0; i < t.count; i++) this.getVertexPosition(i, ro), this.boundingSphere.expandByPoint(ro);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
            e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
            this
          );
        }
        raycast(e, t) {
          const i = this.material,
            s = this.matrixWorld;
          i !== void 0 &&
            (this.boundingSphere === null && this.computeBoundingSphere(),
            oc.copy(this.boundingSphere),
            oc.applyMatrix4(s),
            e.ray.intersectsSphere(oc) !== !1 &&
              (Zf.copy(s).invert(),
              ac.copy(e.ray).applyMatrix4(Zf),
              !(this.boundingBox !== null && ac.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, ac)));
        }
        getVertexPosition(e, t) {
          return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
        }
        bind(e, t) {
          (this.skeleton = e),
            t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new st(),
            t = this.geometry.attributes.skinWeight;
          for (let i = 0, s = t.count; i < s; i++) {
            e.fromBufferAttribute(t, i);
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.bindMode === Tf
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : this.bindMode === O0
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        applyBoneTransform(e, t) {
          const i = this.skeleton,
            s = this.geometry;
          qf.fromBufferAttribute(s.attributes.skinIndex, e),
            Xf.fromBufferAttribute(s.attributes.skinWeight, e),
            Yf.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
          for (let r = 0; r < 4; r++) {
            const A = Xf.getComponent(r);
            if (A !== 0) {
              const o = qf.getComponent(r);
              Jf.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]), t.addScaledVector(Gv.copy(Yf).applyMatrix4(Jf), A);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      class ag extends It {
        constructor() {
          super(), (this.isBone = !0), (this.type = "Bone");
        }
      }
      class cg extends Kt {
        constructor(e = null, t = 1, i = 1, s, r, A, o, a, c = sn, l = sn, u, h) {
          super(null, A, o, a, c, l, s, r, u, h),
            (this.isDataTexture = !0),
            (this.image = { data: e, width: t, height: i }),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      const $f = new ke(),
        Hv = new ke();
      class Yu {
        constructor(e = [], t = []) {
          (this.uuid = Jn()), (this.bones = e.slice(0)), (this.boneInverses = t), (this.boneMatrices = null), (this.boneTexture = null), this.init();
        }
        init() {
          const e = this.bones,
            t = this.boneInverses;
          if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0)) this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), (this.boneInverses = []);
            for (let i = 0, s = this.bones.length; i < s; i++) this.boneInverses.push(new ke());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new ke();
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i &&
              (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
              i.matrix.decompose(i.position, i.quaternion, i.scale));
          }
        }
        update() {
          const e = this.bones,
            t = this.boneInverses,
            i = this.boneMatrices,
            s = this.boneTexture;
          for (let r = 0, A = e.length; r < A; r++) {
            const o = e[r] ? e[r].matrixWorld : Hv;
            $f.multiplyMatrices(o, t[r]), $f.toArray(i, r * 16);
          }
          s !== null && (s.needsUpdate = !0);
        }
        clone() {
          return new Yu(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(this.bones.length * 4);
          (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const i = new cg(t, e, e, kn, Xn);
          return (i.needsUpdate = !0), (this.boneMatrices = t), (this.boneTexture = i), this;
        }
        getBoneByName(e) {
          for (let t = 0, i = this.bones.length; t < i; t++) {
            const s = this.bones[t];
            if (s.name === e) return s;
          }
        }
        dispose() {
          this.boneTexture !== null && (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let i = 0, s = e.bones.length; i < s; i++) {
            const r = e.bones[i];
            let A = t[r];
            A === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), (A = new ag())),
              this.bones.push(A),
              this.boneInverses.push(new ke().fromArray(e.boneInverses[i]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = { metadata: { version: 4.7, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
          e.uuid = this.uuid;
          const t = this.bones,
            i = this.boneInverses;
          for (let s = 0, r = t.length; s < r; s++) {
            const A = t[s];
            e.bones.push(A.uuid);
            const o = i[s];
            e.boneInverses.push(o.toArray());
          }
          return e;
        }
      }
      class Il extends rn {
        constructor(e, t, i, s = 1) {
          super(e, t, i), (this.isInstancedBufferAttribute = !0), (this.meshPerAttribute = s);
        }
        copy(e) {
          return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
        }
        toJSON() {
          const e = super.toJSON();
          return (e.meshPerAttribute = this.meshPerAttribute), (e.isInstancedBufferAttribute = !0), e;
        }
      }
      const nr = new ke(),
        ed = new ke(),
        Ao = [],
        td = new ji(),
        Qv = new ke(),
        tA = new En(),
        nA = new pi();
      class Vv extends En {
        constructor(e, t, i) {
          super(e, t),
            (this.isInstancedMesh = !0),
            (this.instanceMatrix = new Il(new Float32Array(i * 16), 16)),
            (this.instanceColor = null),
            (this.morphTexture = null),
            (this.count = i),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          for (let s = 0; s < i; s++) this.setMatrixAt(s, Qv);
        }
        computeBoundingBox() {
          const e = this.geometry,
            t = this.count;
          this.boundingBox === null && (this.boundingBox = new ji()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
          for (let i = 0; i < t; i++) this.getMatrixAt(i, nr), td.copy(e.boundingBox).applyMatrix4(nr), this.boundingBox.union(td);
        }
        computeBoundingSphere() {
          const e = this.geometry,
            t = this.count;
          this.boundingSphere === null && (this.boundingSphere = new pi()),
            e.boundingSphere === null && e.computeBoundingSphere(),
            this.boundingSphere.makeEmpty();
          for (let i = 0; i < t; i++) this.getMatrixAt(i, nr), nA.copy(e.boundingSphere).applyMatrix4(nr), this.boundingSphere.union(nA);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.instanceMatrix.copy(e.instanceMatrix),
            e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
            e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
            e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
            this
          );
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, e * 16);
        }
        getMorphAt(e, t) {
          const i = t.morphTargetInfluences,
            s = this.morphTexture.source.data.data,
            r = i.length + 1,
            A = e * r + 1;
          for (let o = 0; o < i.length; o++) i[o] = s[A + o];
        }
        raycast(e, t) {
          const i = this.matrixWorld,
            s = this.count;
          if (
            ((tA.geometry = this.geometry),
            (tA.material = this.material),
            tA.material !== void 0 &&
              (this.boundingSphere === null && this.computeBoundingSphere(),
              nA.copy(this.boundingSphere),
              nA.applyMatrix4(i),
              e.ray.intersectsSphere(nA) !== !1))
          )
            for (let r = 0; r < s; r++) {
              this.getMatrixAt(r, nr), ed.multiplyMatrices(i, nr), (tA.matrixWorld = ed), tA.raycast(e, Ao);
              for (let A = 0, o = Ao.length; A < o; A++) {
                const a = Ao[A];
                (a.instanceId = r), (a.object = this), t.push(a);
              }
              Ao.length = 0;
            }
        }
        setColorAt(e, t) {
          this.instanceColor === null && (this.instanceColor = new Il(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)),
            t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, e * 16);
        }
        setMorphAt(e, t) {
          const i = t.morphTargetInfluences,
            s = i.length + 1;
          this.morphTexture === null && (this.morphTexture = new cg(new Float32Array(s * this.count), s, this.count, Gu, Xn));
          const r = this.morphTexture.source.data.data;
          let A = 0;
          for (let c = 0; c < i.length; c++) A += i[c];
          const o = this.geometry.morphTargetsRelative ? 1 : 1 - A,
            a = s * e;
          (r[a] = o), r.set(i, a + 1);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), (this.morphTexture = null));
        }
      }
      const cc = new R(),
        Wv = new R(),
        Kv = new Ne();
      class Es {
        constructor(e = new R(1, 0, 0), t = 0) {
          (this.isPlane = !0), (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, i, s) {
          return this.normal.set(e, t, i), (this.constant = s), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
        }
        setFromCoplanarPoints(e, t, i) {
          const s = cc.subVectors(i, t).cross(Wv.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(s, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
          const i = e.delta(cc),
            s = this.normal.dot(i);
          if (s === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / s;
          return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            i = this.distanceToPoint(e.end);
          return (t < 0 && i > 0) || (i < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const i = t || Kv.getNormalMatrix(e),
            s = this.coplanarPoint(cc).applyMatrix4(e),
            r = this.normal.applyMatrix3(i).normalize();
          return (this.constant = -s.dot(r)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const ws = new pi(),
        Yv = new qe(0.5, 0.5),
        oo = new R();
      class qu {
        constructor(e = new Es(), t = new Es(), i = new Es(), s = new Es(), r = new Es(), A = new Es()) {
          this.planes = [e, t, i, s, r, A];
        }
        set(e, t, i, s, r, A) {
          const o = this.planes;
          return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(s), o[4].copy(r), o[5].copy(A), this;
        }
        copy(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
          return this;
        }
        setFromProjectionMatrix(e, t = bi) {
          const i = this.planes,
            s = e.elements,
            r = s[0],
            A = s[1],
            o = s[2],
            a = s[3],
            c = s[4],
            l = s[5],
            u = s[6],
            h = s[7],
            d = s[8],
            m = s[9],
            g = s[10],
            p = s[11],
            f = s[12],
            E = s[13],
            T = s[14],
            _ = s[15];
          if (
            (i[0].setComponents(a - r, h - c, p - d, _ - f).normalize(),
            i[1].setComponents(a + r, h + c, p + d, _ + f).normalize(),
            i[2].setComponents(a + A, h + l, p + m, _ + E).normalize(),
            i[3].setComponents(a - A, h - l, p - m, _ - E).normalize(),
            i[4].setComponents(a - o, h - u, p - g, _ - T).normalize(),
            t === bi)
          )
            i[5].setComponents(a + o, h + u, p + g, _ + T).normalize();
          else if (t === No) i[5].setComponents(o, u, g, T).normalize();
          else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
          return this;
        }
        intersectsObject(e) {
          if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), ws.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
          else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(), ws.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
          }
          return this.intersectsSphere(ws);
        }
        intersectsSprite(e) {
          ws.center.set(0, 0, 0);
          const t = Yv.distanceTo(e.center);
          return (ws.radius = 0.7071067811865476 + t), ws.applyMatrix4(e.matrixWorld), this.intersectsSphere(ws);
        }
        intersectsSphere(e) {
          const t = this.planes,
            i = e.center,
            s = -e.radius;
          for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(i) < s) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) {
            const s = t[i];
            if (
              ((oo.x = s.normal.x > 0 ? e.max.x : e.min.x),
              (oo.y = s.normal.y > 0 ? e.max.y : e.min.y),
              (oo.z = s.normal.z > 0 ? e.max.z : e.min.z),
              s.distanceToPoint(oo) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class lg extends ci {
        constructor(e) {
          super(),
            (this.isLineBasicMaterial = !0),
            (this.type = "LineBasicMaterial"),
            (this.color = new Ue(16777215)),
            (this.map = null),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      const ko = new R(),
        Go = new R(),
        nd = new ke(),
        iA = new wa(),
        ao = new pi(),
        lc = new R(),
        id = new R();
      class Xu extends It {
        constructor(e = new mi(), t = new lg()) {
          super(),
            (this.isLine = !0),
            (this.type = "Line"),
            (this.geometry = e),
            (this.material = t),
            (this.morphTargetDictionary = void 0),
            (this.morphTargetInfluences = void 0),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), (this.material = Array.isArray(e.material) ? e.material.slice() : e.material), (this.geometry = e.geometry), this;
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.index === null) {
            const t = e.attributes.position,
              i = [0];
            for (let s = 1, r = t.count; s < r; s++)
              ko.fromBufferAttribute(t, s - 1), Go.fromBufferAttribute(t, s), (i[s] = i[s - 1]), (i[s] += ko.distanceTo(Go));
            e.setAttribute("lineDistance", new Ui(i, 1));
          } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
        raycast(e, t) {
          const i = this.geometry,
            s = this.matrixWorld,
            r = e.params.Line.threshold,
            A = i.drawRange;
          if (
            (i.boundingSphere === null && i.computeBoundingSphere(),
            ao.copy(i.boundingSphere),
            ao.applyMatrix4(s),
            (ao.radius += r),
            e.ray.intersectsSphere(ao) === !1)
          )
            return;
          nd.copy(s).invert(), iA.copy(e.ray).applyMatrix4(nd);
          const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o,
            c = this.isLineSegments ? 2 : 1,
            l = i.index,
            h = i.attributes.position;
          if (l !== null) {
            const d = Math.max(0, A.start),
              m = Math.min(l.count, A.start + A.count);
            for (let g = d, p = m - 1; g < p; g += c) {
              const f = l.getX(g),
                E = l.getX(g + 1),
                T = co(this, e, iA, a, f, E, g);
              T && t.push(T);
            }
            if (this.isLineLoop) {
              const g = l.getX(m - 1),
                p = l.getX(d),
                f = co(this, e, iA, a, g, p, m - 1);
              f && t.push(f);
            }
          } else {
            const d = Math.max(0, A.start),
              m = Math.min(h.count, A.start + A.count);
            for (let g = d, p = m - 1; g < p; g += c) {
              const f = co(this, e, iA, a, g, g + 1, g);
              f && t.push(f);
            }
            if (this.isLineLoop) {
              const g = co(this, e, iA, a, m - 1, d, m - 1);
              g && t.push(g);
            }
          }
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes,
            i = Object.keys(t);
          if (i.length > 0) {
            const s = t[i[0]];
            if (s !== void 0) {
              (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
              for (let r = 0, A = s.length; r < A; r++) {
                const o = s[r].name || String(r);
                this.morphTargetInfluences.push(0), (this.morphTargetDictionary[o] = r);
              }
            }
          }
        }
      }
      function co(n, e, t, i, s, r, A) {
        const o = n.geometry.attributes.position;
        if ((ko.fromBufferAttribute(o, s), Go.fromBufferAttribute(o, r), t.distanceSqToSegment(ko, Go, lc, id) > i)) return;
        lc.applyMatrix4(n.matrixWorld);
        const c = e.ray.origin.distanceTo(lc);
        if (!(c < e.near || c > e.far))
          return { distance: c, point: id.clone().applyMatrix4(n.matrixWorld), index: A, face: null, faceIndex: null, barycoord: null, object: n };
      }
      const sd = new R(),
        rd = new R();
      class qv extends Xu {
        constructor(e, t) {
          super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.index === null) {
            const t = e.attributes.position,
              i = [];
            for (let s = 0, r = t.count; s < r; s += 2)
              sd.fromBufferAttribute(t, s), rd.fromBufferAttribute(t, s + 1), (i[s] = s === 0 ? 0 : i[s - 1]), (i[s + 1] = i[s] + sd.distanceTo(rd));
            e.setAttribute("lineDistance", new Ui(i, 1));
          } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
      }
      class Xv extends Xu {
        constructor(e, t) {
          super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
        }
      }
      class ug extends ci {
        constructor(e) {
          super(),
            (this.isPointsMaterial = !0),
            (this.type = "PointsMaterial"),
            (this.color = new Ue(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
          );
        }
      }
      const Ad = new ke(),
        bl = new wa(),
        lo = new pi(),
        uo = new R();
      class Jv extends It {
        constructor(e = new mi(), t = new ug()) {
          super(),
            (this.isPoints = !0),
            (this.type = "Points"),
            (this.geometry = e),
            (this.material = t),
            (this.morphTargetDictionary = void 0),
            (this.morphTargetInfluences = void 0),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), (this.material = Array.isArray(e.material) ? e.material.slice() : e.material), (this.geometry = e.geometry), this;
        }
        raycast(e, t) {
          const i = this.geometry,
            s = this.matrixWorld,
            r = e.params.Points.threshold,
            A = i.drawRange;
          if (
            (i.boundingSphere === null && i.computeBoundingSphere(),
            lo.copy(i.boundingSphere),
            lo.applyMatrix4(s),
            (lo.radius += r),
            e.ray.intersectsSphere(lo) === !1)
          )
            return;
          Ad.copy(s).invert(), bl.copy(e.ray).applyMatrix4(Ad);
          const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            a = o * o,
            c = i.index,
            u = i.attributes.position;
          if (c !== null) {
            const h = Math.max(0, A.start),
              d = Math.min(c.count, A.start + A.count);
            for (let m = h, g = d; m < g; m++) {
              const p = c.getX(m);
              uo.fromBufferAttribute(u, p), od(uo, p, a, s, e, t, this);
            }
          } else {
            const h = Math.max(0, A.start),
              d = Math.min(u.count, A.start + A.count);
            for (let m = h, g = d; m < g; m++) uo.fromBufferAttribute(u, m), od(uo, m, a, s, e, t, this);
          }
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes,
            i = Object.keys(t);
          if (i.length > 0) {
            const s = t[i[0]];
            if (s !== void 0) {
              (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
              for (let r = 0, A = s.length; r < A; r++) {
                const o = s[r].name || String(r);
                this.morphTargetInfluences.push(0), (this.morphTargetDictionary[o] = r);
              }
            }
          }
        }
      }
      function od(n, e, t, i, s, r, A) {
        const o = bl.distanceSqToPoint(n);
        if (o < t) {
          const a = new R();
          bl.closestPointToPoint(n, a), a.applyMatrix4(i);
          const c = s.ray.origin.distanceTo(a);
          if (c < s.near || c > s.far) return;
          r.push({ distance: c, distanceToRay: Math.sqrt(o), point: a, index: e, face: null, faceIndex: null, barycoord: null, object: A });
        }
      }
      class hg extends Kt {
        constructor(e, t, i = Us, s, r, A, o = sn, a = sn, c, l = EA, u = 1) {
          if (l !== EA && l !== DA) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          const h = { width: e, height: t, depth: u };
          super(h, s, r, A, o, a, l, i, c), (this.isDepthTexture = !0), (this.flipY = !1), (this.generateMipmaps = !1), (this.compareFunction = null);
        }
        copy(e) {
          return super.copy(e), (this.source = new Wu(Object.assign({}, e.image))), (this.compareFunction = e.compareFunction), this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
        }
      }
      class _a extends mi {
        constructor(e = 1, t = 1, i = 1, s = 1) {
          super(), (this.type = "PlaneGeometry"), (this.parameters = { width: e, height: t, widthSegments: i, heightSegments: s });
          const r = e / 2,
            A = t / 2,
            o = Math.floor(i),
            a = Math.floor(s),
            c = o + 1,
            l = a + 1,
            u = e / o,
            h = t / a,
            d = [],
            m = [],
            g = [],
            p = [];
          for (let f = 0; f < l; f++) {
            const E = f * h - A;
            for (let T = 0; T < c; T++) {
              const _ = T * u - r;
              m.push(_, -E, 0), g.push(0, 0, 1), p.push(T / o), p.push(1 - f / a);
            }
          }
          for (let f = 0; f < a; f++)
            for (let E = 0; E < o; E++) {
              const T = E + c * f,
                _ = E + c * (f + 1),
                b = E + 1 + c * (f + 1),
                S = E + 1 + c * f;
              d.push(T, _, S), d.push(_, b, S);
            }
          this.setIndex(d), this.setAttribute("position", new Ui(m, 3)), this.setAttribute("normal", new Ui(g, 3)), this.setAttribute("uv", new Ui(p, 2));
        }
        copy(e) {
          return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
        }
        static fromJSON(e) {
          return new _a(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      class Ju extends ci {
        constructor(e) {
          super(),
            (this.isMeshStandardMaterial = !0),
            (this.type = "MeshStandardMaterial"),
            (this.defines = { STANDARD: "" }),
            (this.color = new Ue(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ue(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Jm),
            (this.normalScale = new qe(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new fi()),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.envMapIntensity = e.envMapIntensity),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      class gi extends Ju {
        constructor(e) {
          super(),
            (this.isMeshPhysicalMaterial = !0),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.anisotropyRotation = 0),
            (this.anisotropyMap = null),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new qe(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
              get: function () {
                return Qe((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
              },
              set: function (t) {
                this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
              },
            }),
            (this.iridescenceMap = null),
            (this.iridescenceIOR = 1.3),
            (this.iridescenceThicknessRange = [100, 400]),
            (this.iridescenceThicknessMap = null),
            (this.sheenColor = new Ue(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 1 / 0),
            (this.attenuationColor = new Ue(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new Ue(1, 1, 1)),
            (this.specularColorMap = null),
            (this._anisotropy = 0),
            (this._clearcoat = 0),
            (this._dispersion = 0),
            (this._iridescence = 0),
            (this._sheen = 0),
            (this._transmission = 0),
            this.setValues(e);
        }
        get anisotropy() {
          return this._anisotropy;
        }
        set anisotropy(e) {
          this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(e) {
          this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
        }
        get dispersion() {
          return this._dispersion;
        }
        set dispersion(e) {
          this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.anisotropy = e.anisotropy),
            (this.anisotropyRotation = e.anisotropyRotation),
            (this.anisotropyMap = e.anisotropyMap),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.dispersion = e.dispersion),
            (this.ior = e.ior),
            (this.iridescence = e.iridescence),
            (this.iridescenceMap = e.iridescenceMap),
            (this.iridescenceIOR = e.iridescenceIOR),
            (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
            (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
            (this.sheen = e.sheen),
            this.sheenColor.copy(e.sheenColor),
            (this.sheenColorMap = e.sheenColorMap),
            (this.sheenRoughness = e.sheenRoughness),
            (this.sheenRoughnessMap = e.sheenRoughnessMap),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            (this.specularIntensity = e.specularIntensity),
            (this.specularIntensityMap = e.specularIntensityMap),
            this.specularColor.copy(e.specularColor),
            (this.specularColorMap = e.specularColorMap),
            this
          );
        }
      }
      class Zv extends ci {
        constructor(e) {
          super(),
            (this.isMeshDepthMaterial = !0),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = F0),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      class $v extends ci {
        constructor(e) {
          super(),
            (this.isMeshDistanceMaterial = !0),
            (this.type = "MeshDistanceMaterial"),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      function ho(n, e) {
        return !n || n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n);
      }
      function ew(n) {
        return ArrayBuffer.isView(n) && !(n instanceof DataView);
      }
      function tw(n) {
        function e(s, r) {
          return n[s] - n[r];
        }
        const t = n.length,
          i = new Array(t);
        for (let s = 0; s !== t; ++s) i[s] = s;
        return i.sort(e), i;
      }
      function ad(n, e, t) {
        const i = n.length,
          s = new n.constructor(i);
        for (let r = 0, A = 0; A !== i; ++r) {
          const o = t[r] * e;
          for (let a = 0; a !== e; ++a) s[A++] = n[o + a];
        }
        return s;
      }
      function fg(n, e, t, i) {
        let s = 1,
          r = n[0];
        for (; r !== void 0 && r[i] === void 0; ) r = n[s++];
        if (r === void 0) return;
        let A = r[i];
        if (A !== void 0)
          if (Array.isArray(A))
            do (A = r[i]), A !== void 0 && (e.push(r.time), t.push(...A)), (r = n[s++]);
            while (r !== void 0);
          else if (A.toArray !== void 0)
            do (A = r[i]), A !== void 0 && (e.push(r.time), A.toArray(t, t.length)), (r = n[s++]);
            while (r !== void 0);
          else
            do (A = r[i]), A !== void 0 && (e.push(r.time), t.push(A)), (r = n[s++]);
            while (r !== void 0);
      }
      class OA {
        constructor(e, t, i, s) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = s !== void 0 ? s : new t.constructor(i)),
            (this.sampleValues = t),
            (this.valueSize = i),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let i = this._cachedIndex,
            s = t[i],
            r = t[i - 1];
          e: {
            t: {
              let A;
              n: {
                i: if (!(e < s)) {
                  for (let o = i + 2; ; ) {
                    if (s === void 0) {
                      if (e < r) break i;
                      return (i = t.length), (this._cachedIndex = i), this.copySampleValue_(i - 1);
                    }
                    if (i === o) break;
                    if (((r = s), (s = t[++i]), e < s)) break t;
                  }
                  A = t.length;
                  break n;
                }
                if (!(e >= r)) {
                  const o = t[1];
                  e < o && ((i = 2), (r = o));
                  for (let a = i - 2; ; ) {
                    if (r === void 0) return (this._cachedIndex = 0), this.copySampleValue_(0);
                    if (i === a) break;
                    if (((s = r), (r = t[--i - 1]), e >= r)) break t;
                  }
                  (A = i), (i = 0);
                  break n;
                }
                break e;
              }
              for (; i < A; ) {
                const o = (i + A) >>> 1;
                e < t[o] ? (A = o) : (i = o + 1);
              }
              if (((s = t[i]), (r = t[i - 1]), r === void 0)) return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (s === void 0) return (i = t.length), (this._cachedIndex = i), this.copySampleValue_(i - 1);
            }
            (this._cachedIndex = i), this.intervalChanged_(i, r, s);
          }
          return this.interpolate_(i, r, e, s);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            i = this.sampleValues,
            s = this.valueSize,
            r = e * s;
          for (let A = 0; A !== s; ++A) t[A] = i[r + A];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      class nw extends OA {
        constructor(e, t, i, s) {
          super(e, t, i, s),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: Ef, endingEnd: Ef });
        }
        intervalChanged_(e, t, i) {
          const s = this.parameterPositions;
          let r = e - 2,
            A = e + 1,
            o = s[r],
            a = s[A];
          if (o === void 0)
            switch (this.getSettings_().endingStart) {
              case Df:
                (r = e), (o = 2 * t - i);
                break;
              case Mf:
                (r = s.length - 2), (o = t + s[r] - s[r + 1]);
                break;
              default:
                (r = e), (o = i);
            }
          if (a === void 0)
            switch (this.getSettings_().endingEnd) {
              case Df:
                (A = e), (a = 2 * i - t);
                break;
              case Mf:
                (A = 1), (a = i + s[1] - s[0]);
                break;
              default:
                (A = e - 1), (a = t);
            }
          const c = (i - t) * 0.5,
            l = this.valueSize;
          (this._weightPrev = c / (t - o)), (this._weightNext = c / (a - i)), (this._offsetPrev = r * l), (this._offsetNext = A * l);
        }
        interpolate_(e, t, i, s) {
          const r = this.resultBuffer,
            A = this.sampleValues,
            o = this.valueSize,
            a = e * o,
            c = a - o,
            l = this._offsetPrev,
            u = this._offsetNext,
            h = this._weightPrev,
            d = this._weightNext,
            m = (i - t) / (s - t),
            g = m * m,
            p = g * m,
            f = -h * p + 2 * h * g - h * m,
            E = (1 + h) * p + (-1.5 - 2 * h) * g + (-0.5 + h) * m + 1,
            T = (-1 - d) * p + (1.5 + d) * g + 0.5 * m,
            _ = d * p - d * g;
          for (let b = 0; b !== o; ++b) r[b] = f * A[l + b] + E * A[c + b] + T * A[a + b] + _ * A[u + b];
          return r;
        }
      }
      class iw extends OA {
        constructor(e, t, i, s) {
          super(e, t, i, s);
        }
        interpolate_(e, t, i, s) {
          const r = this.resultBuffer,
            A = this.sampleValues,
            o = this.valueSize,
            a = e * o,
            c = a - o,
            l = (i - t) / (s - t),
            u = 1 - l;
          for (let h = 0; h !== o; ++h) r[h] = A[c + h] * u + A[a + h] * l;
          return r;
        }
      }
      class sw extends OA {
        constructor(e, t, i, s) {
          super(e, t, i, s);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class ni {
        constructor(e, t, i, s) {
          if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
          (this.name = e),
            (this.times = ho(t, this.TimeBufferType)),
            (this.values = ho(i, this.ValueBufferType)),
            this.setInterpolation(s || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let i;
          if (t.toJSON !== this.toJSON) i = t.toJSON(e);
          else {
            i = { name: e.name, times: ho(e.times, Array), values: ho(e.values, Array) };
            const s = e.getInterpolation();
            s !== e.DefaultInterpolation && (i.interpolation = s);
          }
          return (i.type = e.ValueTypeName), i;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new sw(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new iw(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new nw(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case MA:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case CA:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case Na:
              t = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
              if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
              else throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return MA;
            case this.InterpolantFactoryMethodLinear:
              return CA;
            case this.InterpolantFactoryMethodSmooth:
              return Na;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (e !== 0) {
            const t = this.times;
            for (let i = 0, s = t.length; i !== s; ++i) t[i] += e;
          }
          return this;
        }
        scale(e) {
          if (e !== 1) {
            const t = this.times;
            for (let i = 0, s = t.length; i !== s; ++i) t[i] *= e;
          }
          return this;
        }
        trim(e, t) {
          const i = this.times,
            s = i.length;
          let r = 0,
            A = s - 1;
          for (; r !== s && i[r] < e; ) ++r;
          for (; A !== -1 && i[A] > t; ) --A;
          if ((++A, r !== 0 || A !== s)) {
            r >= A && ((A = Math.max(A, 1)), (r = A - 1));
            const o = this.getValueSize();
            (this.times = i.slice(r, A)), (this.values = this.values.slice(r * o, A * o));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), (e = !1));
          const i = this.times,
            s = this.values,
            r = i.length;
          r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
          let A = null;
          for (let o = 0; o !== r; o++) {
            const a = i[o];
            if (typeof a == "number" && isNaN(a)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, a), (e = !1);
              break;
            }
            if (A !== null && A > a) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, o, a, A), (e = !1);
              break;
            }
            A = a;
          }
          if (s !== void 0 && ew(s))
            for (let o = 0, a = s.length; o !== a; ++o) {
              const c = s[o];
              if (isNaN(c)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = this.times.slice(),
            t = this.values.slice(),
            i = this.getValueSize(),
            s = this.getInterpolation() === Na,
            r = e.length - 1;
          let A = 1;
          for (let o = 1; o < r; ++o) {
            let a = !1;
            const c = e[o],
              l = e[o + 1];
            if (c !== l && (o !== 1 || c !== e[0]))
              if (s) a = !0;
              else {
                const u = o * i,
                  h = u - i,
                  d = u + i;
                for (let m = 0; m !== i; ++m) {
                  const g = t[u + m];
                  if (g !== t[h + m] || g !== t[d + m]) {
                    a = !0;
                    break;
                  }
                }
              }
            if (a) {
              if (o !== A) {
                e[A] = e[o];
                const u = o * i,
                  h = A * i;
                for (let d = 0; d !== i; ++d) t[h + d] = t[u + d];
              }
              ++A;
            }
          }
          if (r > 0) {
            e[A] = e[r];
            for (let o = r * i, a = A * i, c = 0; c !== i; ++c) t[a + c] = t[o + c];
            ++A;
          }
          return A !== e.length ? ((this.times = e.slice(0, A)), (this.values = t.slice(0, A * i))) : ((this.times = e), (this.values = t)), this;
        }
        clone() {
          const e = this.times.slice(),
            t = this.values.slice(),
            i = this.constructor,
            s = new i(this.name, e, t);
          return (s.createInterpolant = this.createInterpolant), s;
        }
      }
      ni.prototype.ValueTypeName = "";
      ni.prototype.TimeBufferType = Float32Array;
      ni.prototype.ValueBufferType = Float32Array;
      ni.prototype.DefaultInterpolation = CA;
      class Qr extends ni {
        constructor(e, t, i) {
          super(e, t, i);
        }
      }
      Qr.prototype.ValueTypeName = "bool";
      Qr.prototype.ValueBufferType = Array;
      Qr.prototype.DefaultInterpolation = MA;
      Qr.prototype.InterpolantFactoryMethodLinear = void 0;
      Qr.prototype.InterpolantFactoryMethodSmooth = void 0;
      class dg extends ni {
        constructor(e, t, i, s) {
          super(e, t, i, s);
        }
      }
      dg.prototype.ValueTypeName = "color";
      class br extends ni {
        constructor(e, t, i, s) {
          super(e, t, i, s);
        }
      }
      br.prototype.ValueTypeName = "number";
      class rw extends OA {
        constructor(e, t, i, s) {
          super(e, t, i, s);
        }
        interpolate_(e, t, i, s) {
          const r = this.resultBuffer,
            A = this.sampleValues,
            o = this.valueSize,
            a = (i - t) / (s - t);
          let c = e * o;
          for (let l = c + o; c !== l; c += 4) fs.slerpFlat(r, 0, A, c - o, A, c, a);
          return r;
        }
      }
      class zr extends ni {
        constructor(e, t, i, s) {
          super(e, t, i, s);
        }
        InterpolantFactoryMethodLinear(e) {
          return new rw(this.times, this.values, this.getValueSize(), e);
        }
      }
      zr.prototype.ValueTypeName = "quaternion";
      zr.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Vr extends ni {
        constructor(e, t, i) {
          super(e, t, i);
        }
      }
      Vr.prototype.ValueTypeName = "string";
      Vr.prototype.ValueBufferType = Array;
      Vr.prototype.DefaultInterpolation = MA;
      Vr.prototype.InterpolantFactoryMethodLinear = void 0;
      Vr.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Rr extends ni {
        constructor(e, t, i, s) {
          super(e, t, i, s);
        }
      }
      Rr.prototype.ValueTypeName = "vector";
      class Aw {
        constructor(e = "", t = -1, i = [], s = L0) {
          (this.name = e), (this.tracks = i), (this.duration = t), (this.blendMode = s), (this.uuid = Jn()), this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            i = e.tracks,
            s = 1 / (e.fps || 1);
          for (let A = 0, o = i.length; A !== o; ++A) t.push(aw(i[A]).scale(s));
          const r = new this(e.name, e.duration, t, e.blendMode);
          return (r.uuid = e.uuid), r;
        }
        static toJSON(e) {
          const t = [],
            i = e.tracks,
            s = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode };
          for (let r = 0, A = i.length; r !== A; ++r) t.push(ni.toJSON(i[r]));
          return s;
        }
        static CreateFromMorphTargetSequence(e, t, i, s) {
          const r = t.length,
            A = [];
          for (let o = 0; o < r; o++) {
            let a = [],
              c = [];
            a.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
            const l = tw(a);
            (a = ad(a, 1, l)),
              (c = ad(c, 1, l)),
              !s && a[0] === 0 && (a.push(r), c.push(c[0])),
              A.push(new br(".morphTargetInfluences[" + t[o].name + "]", a, c).scale(1 / i));
          }
          return new this(e, -1, A);
        }
        static findByName(e, t) {
          let i = e;
          if (!Array.isArray(e)) {
            const s = e;
            i = (s.geometry && s.geometry.animations) || s.animations;
          }
          for (let s = 0; s < i.length; s++) if (i[s].name === t) return i[s];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, i) {
          const s = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let o = 0, a = e.length; o < a; o++) {
            const c = e[o],
              l = c.name.match(r);
            if (l && l.length > 1) {
              const u = l[1];
              let h = s[u];
              h || (s[u] = h = []), h.push(c);
            }
          }
          const A = [];
          for (const o in s) A.push(this.CreateFromMorphTargetSequence(o, s[o], t, i));
          return A;
        }
        static parseAnimation(e, t) {
          if ((console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e))
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
          const i = function (u, h, d, m, g) {
              if (d.length !== 0) {
                const p = [],
                  f = [];
                fg(d, p, f, m), p.length !== 0 && g.push(new u(h, p, f));
              }
            },
            s = [],
            r = e.name || "default",
            A = e.fps || 30,
            o = e.blendMode;
          let a = e.length || -1;
          const c = e.hierarchy || [];
          for (let u = 0; u < c.length; u++) {
            const h = c[u].keys;
            if (!(!h || h.length === 0))
              if (h[0].morphTargets) {
                const d = {};
                let m;
                for (m = 0; m < h.length; m++) if (h[m].morphTargets) for (let g = 0; g < h[m].morphTargets.length; g++) d[h[m].morphTargets[g]] = -1;
                for (const g in d) {
                  const p = [],
                    f = [];
                  for (let E = 0; E !== h[m].morphTargets.length; ++E) {
                    const T = h[m];
                    p.push(T.time), f.push(T.morphTarget === g ? 1 : 0);
                  }
                  s.push(new br(".morphTargetInfluence[" + g + "]", p, f));
                }
                a = d.length * A;
              } else {
                const d = ".bones[" + t[u].name + "]";
                i(Rr, d + ".position", h, "pos", s), i(zr, d + ".quaternion", h, "rot", s), i(Rr, d + ".scale", h, "scl", s);
              }
          }
          return s.length === 0 ? null : new this(r, a, s, o);
        }
        resetDuration() {
          const e = this.tracks;
          let t = 0;
          for (let i = 0, s = e.length; i !== s; ++i) {
            const r = this.tracks[i];
            t = Math.max(t, r.times[r.times.length - 1]);
          }
          return (this.duration = t), this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
          return new this.constructor(this.name, this.duration, e, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function ow(n) {
        switch (n.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return br;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return Rr;
          case "color":
            return dg;
          case "quaternion":
            return zr;
          case "bool":
          case "boolean":
            return Qr;
          case "string":
            return Vr;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
      }
      function aw(n) {
        if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = ow(n.type);
        if (n.times === void 0) {
          const t = [],
            i = [];
          fg(n.keys, t, i, "value"), (n.times = t), (n.values = i);
        }
        return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation);
      }
      const zi = {
        enabled: !1,
        files: {},
        add: function (n, e) {
          this.enabled !== !1 && (this.files[n] = e);
        },
        get: function (n) {
          if (this.enabled !== !1) return this.files[n];
        },
        remove: function (n) {
          delete this.files[n];
        },
        clear: function () {
          this.files = {};
        },
      };
      class cw {
        constructor(e, t, i) {
          const s = this;
          let r = !1,
            A = 0,
            o = 0,
            a;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = i),
            (this.itemStart = function (l) {
              o++, r === !1 && s.onStart !== void 0 && s.onStart(l, A, o), (r = !0);
            }),
            (this.itemEnd = function (l) {
              A++, s.onProgress !== void 0 && s.onProgress(l, A, o), A === o && ((r = !1), s.onLoad !== void 0 && s.onLoad());
            }),
            (this.itemError = function (l) {
              s.onError !== void 0 && s.onError(l);
            }),
            (this.resolveURL = function (l) {
              return a ? a(l) : l;
            }),
            (this.setURLModifier = function (l) {
              return (a = l), this;
            }),
            (this.addHandler = function (l, u) {
              return c.push(l, u), this;
            }),
            (this.removeHandler = function (l) {
              const u = c.indexOf(l);
              return u !== -1 && c.splice(u, 2), this;
            }),
            (this.getHandler = function (l) {
              for (let u = 0, h = c.length; u < h; u += 2) {
                const d = c[u],
                  m = c[u + 1];
                if ((d.global && (d.lastIndex = 0), d.test(l))) return m;
              }
              return null;
            });
        }
      }
      const lw = new cw();
      class Wr {
        constructor(e) {
          (this.manager = e !== void 0 ? e : lw),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(e, t) {
          const i = this;
          return new Promise(function (s, r) {
            i.load(e, s, t, r);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          return (this.crossOrigin = e), this;
        }
        setWithCredentials(e) {
          return (this.withCredentials = e), this;
        }
        setPath(e) {
          return (this.path = e), this;
        }
        setResourcePath(e) {
          return (this.resourcePath = e), this;
        }
        setRequestHeader(e) {
          return (this.requestHeader = e), this;
        }
      }
      Wr.DEFAULT_MATERIAL_NAME = "__DEFAULT";
      const Ti = {};
      class uw extends Error {
        constructor(e, t) {
          super(e), (this.response = t);
        }
      }
      class pg extends Wr {
        constructor(e) {
          super(e), (this.mimeType = ""), (this.responseType = "");
        }
        load(e, t, i, s) {
          e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e));
          const r = zi.get(`file:${e}`);
          if (r !== void 0)
            return (
              this.manager.itemStart(e),
              setTimeout(() => {
                t && t(r), this.manager.itemEnd(e);
              }, 0),
              r
            );
          if (Ti[e] !== void 0) {
            Ti[e].push({ onLoad: t, onProgress: i, onError: s });
            return;
          }
          (Ti[e] = []), Ti[e].push({ onLoad: t, onProgress: i, onError: s });
          const A = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }),
            o = this.mimeType,
            a = this.responseType;
          fetch(A)
            .then((c) => {
              if (c.status === 200 || c.status === 0) {
                if (
                  (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
                )
                  return c;
                const l = Ti[e],
                  u = c.body.getReader(),
                  h = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
                  d = h ? parseInt(h) : 0,
                  m = d !== 0;
                let g = 0;
                const p = new ReadableStream({
                  start(f) {
                    E();
                    function E() {
                      u.read().then(
                        ({ done: T, value: _ }) => {
                          if (T) f.close();
                          else {
                            g += _.byteLength;
                            const b = new ProgressEvent("progress", { lengthComputable: m, loaded: g, total: d });
                            for (let S = 0, D = l.length; S < D; S++) {
                              const O = l[S];
                              O.onProgress && O.onProgress(b);
                            }
                            f.enqueue(_), E();
                          }
                        },
                        (T) => {
                          f.error(T);
                        }
                      );
                    }
                  },
                });
                return new Response(p);
              } else throw new uw(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
            })
            .then((c) => {
              switch (a) {
                case "arraybuffer":
                  return c.arrayBuffer();
                case "blob":
                  return c.blob();
                case "document":
                  return c.text().then((l) => new DOMParser().parseFromString(l, o));
                case "json":
                  return c.json();
                default:
                  if (o === "") return c.text();
                  {
                    const u = /charset="?([^;"\s]*)"?/i.exec(o),
                      h = u && u[1] ? u[1].toLowerCase() : void 0,
                      d = new TextDecoder(h);
                    return c.arrayBuffer().then((m) => d.decode(m));
                  }
              }
            })
            .then((c) => {
              zi.add(`file:${e}`, c);
              const l = Ti[e];
              delete Ti[e];
              for (let u = 0, h = l.length; u < h; u++) {
                const d = l[u];
                d.onLoad && d.onLoad(c);
              }
            })
            .catch((c) => {
              const l = Ti[e];
              if (l === void 0) throw (this.manager.itemError(e), c);
              delete Ti[e];
              for (let u = 0, h = l.length; u < h; u++) {
                const d = l[u];
                d.onError && d.onError(c);
              }
              this.manager.itemError(e);
            })
            .finally(() => {
              this.manager.itemEnd(e);
            }),
            this.manager.itemStart(e);
        }
        setResponseType(e) {
          return (this.responseType = e), this;
        }
        setMimeType(e) {
          return (this.mimeType = e), this;
        }
      }
      const ir = new WeakMap();
      class hw extends Wr {
        constructor(e) {
          super(e);
        }
        load(e, t, i, s) {
          this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e));
          const r = this,
            A = zi.get(`image:${e}`);
          if (A !== void 0) {
            if (A.complete === !0)
              r.manager.itemStart(e),
                setTimeout(function () {
                  t && t(A), r.manager.itemEnd(e);
                }, 0);
            else {
              let u = ir.get(A);
              u === void 0 && ((u = []), ir.set(A, u)), u.push({ onLoad: t, onError: s });
            }
            return A;
          }
          const o = SA("img");
          function a() {
            l(), t && t(this);
            const u = ir.get(this) || [];
            for (let h = 0; h < u.length; h++) {
              const d = u[h];
              d.onLoad && d.onLoad(this);
            }
            ir.delete(this), r.manager.itemEnd(e);
          }
          function c(u) {
            l(), s && s(u), zi.remove(`image:${e}`);
            const h = ir.get(this) || [];
            for (let d = 0; d < h.length; d++) {
              const m = h[d];
              m.onError && m.onError(u);
            }
            ir.delete(this), r.manager.itemError(e), r.manager.itemEnd(e);
          }
          function l() {
            o.removeEventListener("load", a, !1), o.removeEventListener("error", c, !1);
          }
          return (
            o.addEventListener("load", a, !1),
            o.addEventListener("error", c, !1),
            e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin),
            zi.add(`image:${e}`, o),
            r.manager.itemStart(e),
            (o.src = e),
            o
          );
        }
      }
      class fw extends Wr {
        constructor(e) {
          super(e);
        }
        load(e, t, i, s) {
          const r = new Kt(),
            A = new hw(this.manager);
          return (
            A.setCrossOrigin(this.crossOrigin),
            A.setPath(this.path),
            A.load(
              e,
              function (o) {
                (r.image = o), (r.needsUpdate = !0), t !== void 0 && t(r);
              },
              i,
              s
            ),
            r
          );
        }
      }
      class xa extends It {
        constructor(e, t = 1) {
          super(), (this.isLight = !0), (this.type = "Light"), (this.color = new Ue(e)), (this.intensity = t);
        }
        dispose() {}
        copy(e, t) {
          return super.copy(e, t), this.color.copy(e.color), (this.intensity = e.intensity), this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (t.object.distance = this.distance),
            this.angle !== void 0 && (t.object.angle = this.angle),
            this.decay !== void 0 && (t.object.decay = this.decay),
            this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
            this.target !== void 0 && (t.object.target = this.target.uuid),
            t
          );
        }
      }
      const uc = new ke(),
        cd = new R(),
        ld = new R();
      class Zu {
        constructor(e) {
          (this.camera = e),
            (this.intensity = 1),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new qe(512, 512)),
            (this.mapType = hi),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new ke()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new qu()),
            (this._frameExtents = new qe(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new st(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            i = this.matrix;
          cd.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(cd),
            ld.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(ld),
            t.updateMatrixWorld(),
            uc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(uc),
            i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            i.multiply(uc);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.intensity = e.intensity),
            (this.bias = e.bias),
            (this.radius = e.radius),
            (this.autoUpdate = e.autoUpdate),
            (this.needsUpdate = e.needsUpdate),
            (this.normalBias = e.normalBias),
            (this.blurSamples = e.blurSamples),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            this.intensity !== 1 && (e.intensity = this.intensity),
            this.bias !== 0 && (e.bias = this.bias),
            this.normalBias !== 0 && (e.normalBias = this.normalBias),
            this.radius !== 1 && (e.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      class dw extends Zu {
        constructor() {
          super(new nn(50, 1, 0.5, 500)), (this.isSpotLightShadow = !0), (this.focus = 1), (this.aspect = 1);
        }
        updateMatrices(e) {
          const t = this.camera,
            i = Sr * 2 * e.angle * this.focus,
            s = (this.mapSize.width / this.mapSize.height) * this.aspect,
            r = e.distance || t.far;
          (i !== t.fov || s !== t.aspect || r !== t.far) && ((t.fov = i), (t.aspect = s), (t.far = r), t.updateProjectionMatrix()), super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), (this.focus = e.focus), this;
        }
      }
      class pw extends xa {
        constructor(e, t, i = 0, s = Math.PI / 3, r = 0, A = 2) {
          super(e, t),
            (this.isSpotLight = !0),
            (this.type = "SpotLight"),
            this.position.copy(It.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new It()),
            (this.distance = i),
            (this.angle = s),
            (this.penumbra = r),
            (this.decay = A),
            (this.map = null),
            (this.shadow = new dw());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      const ud = new ke(),
        sA = new R(),
        hc = new R();
      class mw extends Zu {
        constructor() {
          super(new nn(90, 1, 0.5, 500)),
            (this.isPointLightShadow = !0),
            (this._frameExtents = new qe(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [new st(2, 1, 1, 1), new st(0, 1, 1, 1), new st(3, 1, 1, 1), new st(1, 1, 1, 1), new st(3, 0, 1, 1), new st(1, 0, 1, 1)]),
            (this._cubeDirections = [new R(1, 0, 0), new R(-1, 0, 0), new R(0, 0, 1), new R(0, 0, -1), new R(0, 1, 0), new R(0, -1, 0)]),
            (this._cubeUps = [new R(0, 1, 0), new R(0, 1, 0), new R(0, 1, 0), new R(0, 1, 0), new R(0, 0, 1), new R(0, 0, -1)]);
        }
        updateMatrices(e, t = 0) {
          const i = this.camera,
            s = this.matrix,
            r = e.distance || i.far;
          r !== i.far && ((i.far = r), i.updateProjectionMatrix()),
            sA.setFromMatrixPosition(e.matrixWorld),
            i.position.copy(sA),
            hc.copy(i.position),
            hc.add(this._cubeDirections[t]),
            i.up.copy(this._cubeUps[t]),
            i.lookAt(hc),
            i.updateMatrixWorld(),
            s.makeTranslation(-sA.x, -sA.y, -sA.z),
            ud.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(ud);
        }
      }
      class gw extends xa {
        constructor(e, t, i = 0, s = 2) {
          super(e, t), (this.isPointLight = !0), (this.type = "PointLight"), (this.distance = i), (this.decay = s), (this.shadow = new mw());
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return super.copy(e, t), (this.distance = e.distance), (this.decay = e.decay), (this.shadow = e.shadow.clone()), this;
        }
      }
      class $u extends Ag {
        constructor(e = -1, t = 1, i = 1, s = -1, r = 0.1, A = 2e3) {
          super(),
            (this.isOrthographicCamera = !0),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = i),
            (this.bottom = s),
            (this.near = r),
            (this.far = A),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, i, s, r, A) {
          this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = i),
            (this.view.offsetY = s),
            (this.view.width = r),
            (this.view.height = A),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            s = (this.top + this.bottom) / 2;
          let r = i - e,
            A = i + e,
            o = s + t,
            a = s - t;
          if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
              l = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += c * this.view.offsetX), (A = r + c * this.view.width), (o -= l * this.view.offsetY), (a = o - l * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(r, A, o, a, this.near, this.far, this.coordinateSystem),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            this.view !== null && (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      class Pw extends Zu {
        constructor() {
          super(new $u(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
        }
      }
      class mg extends xa {
        constructor(e, t) {
          super(e, t),
            (this.isDirectionalLight = !0),
            (this.type = "DirectionalLight"),
            this.position.copy(It.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new It()),
            (this.shadow = new Pw());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return super.copy(e), (this.target = e.target.clone()), (this.shadow = e.shadow.clone()), this;
        }
      }
      class vw extends xa {
        constructor(e, t) {
          super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
        }
      }
      class pA {
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return t === -1 ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
          return typeof e != "string" || e === ""
            ? ""
            : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
        }
      }
      const fc = new WeakMap();
      class ww extends Wr {
        constructor(e) {
          super(e),
            (this.isImageBitmapLoader = !0),
            typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
            typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
          return (this.options = e), this;
        }
        load(e, t, i, s) {
          e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e));
          const r = this,
            A = zi.get(`image-bitmap:${e}`);
          if (A !== void 0) {
            if ((r.manager.itemStart(e), A.then)) {
              A.then((c) => {
                if (fc.has(A) === !0) s && s(fc.get(A)), r.manager.itemError(e), r.manager.itemEnd(e);
                else return t && t(c), r.manager.itemEnd(e), c;
              });
              return;
            }
            return (
              setTimeout(function () {
                t && t(A), r.manager.itemEnd(e);
              }, 0),
              A
            );
          }
          const o = {};
          (o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include"), (o.headers = this.requestHeader);
          const a = fetch(e, o)
            .then(function (c) {
              return c.blob();
            })
            .then(function (c) {
              return createImageBitmap(c, Object.assign(r.options, { colorSpaceConversion: "none" }));
            })
            .then(function (c) {
              return zi.add(`image-bitmap:${e}`, c), t && t(c), r.manager.itemEnd(e), c;
            })
            .catch(function (c) {
              s && s(c), fc.set(a, c), zi.remove(`image-bitmap:${e}`), r.manager.itemError(e), r.manager.itemEnd(e);
            });
          zi.add(`image-bitmap:${e}`, a), r.manager.itemStart(e);
        }
      }
      class _w extends nn {
        constructor(e = []) {
          super(), (this.isArrayCamera = !0), (this.isMultiViewCamera = !1), (this.cameras = e);
        }
      }
      const eh = "\\[\\]\\.:\\/",
        xw = new RegExp("[" + eh + "]", "g"),
        th = "[^" + eh + "]",
        yw = "[^" + eh.replace("\\.", "") + "]",
        Tw = /((?:WC+[\/:])*)/.source.replace("WC", th),
        Ew = /(WCOD+)?/.source.replace("WCOD", yw),
        Dw = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", th),
        Mw = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", th),
        Cw = new RegExp("^" + Tw + Ew + Dw + Mw + "$"),
        Sw = ["material", "materials", "bones", "map"];
      class Iw {
        constructor(e, t, i) {
          const s = i || ct.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, s));
        }
        getValue(e, t) {
          this.bind();
          const i = this._targetGroup.nCachedObjects_,
            s = this._bindings[i];
          s !== void 0 && s.getValue(e, t);
        }
        setValue(e, t) {
          const i = this._bindings;
          for (let s = this._targetGroup.nCachedObjects_, r = i.length; s !== r; ++s) i[s].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind();
        }
      }
      class ct {
        constructor(e, t, i) {
          (this.path = t),
            (this.parsedPath = i || ct.parseTrackName(t)),
            (this.node = ct.findNode(e, this.parsedPath.nodeName)),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(e, t, i) {
          return e && e.isAnimationObjectGroup ? new ct.Composite(e, t, i) : new ct(e, t, i);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(xw, "");
        }
        static parseTrackName(e) {
          const t = Cw.exec(e);
          if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] },
            s = i.nodeName && i.nodeName.lastIndexOf(".");
          if (s !== void 0 && s !== -1) {
            const r = i.nodeName.substring(s + 1);
            Sw.indexOf(r) !== -1 && ((i.nodeName = i.nodeName.substring(0, s)), (i.objectName = r));
          }
          if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
          return i;
        }
        static findNode(e, t) {
          if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
          if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0) return i;
          }
          if (e.children) {
            const i = function (r) {
                for (let A = 0; A < r.length; A++) {
                  const o = r[A];
                  if (o.name === t || o.uuid === t) return o;
                  const a = i(o.children);
                  if (a) return a;
                }
                return null;
              },
              s = i(e.children);
            if (s) return s;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const i = this.resolvedProperty;
          for (let s = 0, r = i.length; s !== r; ++s) e[t++] = i[s];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]), (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]), (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
          const i = this.resolvedProperty;
          for (let s = 0, r = i.length; s !== r; ++s) i[s] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const i = this.resolvedProperty;
          for (let s = 0, r = i.length; s !== r; ++s) i[s] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const i = this.resolvedProperty;
          for (let s = 0, r = i.length; s !== r; ++s) i[s] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t), (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            i = t.objectName,
            s = t.propertyName;
          let r = t.propertyIndex;
          if (
            (e || ((e = ct.findNode(this.rootNode, t.nodeName)), (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
          ) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return;
          }
          if (i) {
            let c = t.objectIndex;
            switch (i) {
              case "materials":
                if (!e.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!e.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                e = e.skeleton.bones;
                for (let l = 0; l < e.length; l++)
                  if (e[l].name === c) {
                    c = l;
                    break;
                  }
                break;
              case "map":
                if ("map" in e) {
                  e = e.map;
                  break;
                }
                if (!e.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!e.material.map) {
                  console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                  return;
                }
                e = e.material.map;
                break;
              default:
                if (e[i] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                e = e[i];
            }
            if (c !== void 0) {
              if (e[c] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                return;
              }
              e = e[c];
            }
          }
          const A = e[s];
          if (A === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + s + " but it wasn't found.", e);
            return;
          }
          let o = this.Versioning.None;
          (this.targetObject = e),
            e.isMaterial === !0 ? (o = this.Versioning.NeedsUpdate) : e.isObject3D === !0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
          let a = this.BindingType.Direct;
          if (r !== void 0) {
            if (s === "morphTargetInfluences") {
              if (!e.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (!e.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
            }
            (a = this.BindingType.ArrayElement), (this.resolvedProperty = A), (this.propertyIndex = r);
          } else
            A.fromArray !== void 0 && A.toArray !== void 0
              ? ((a = this.BindingType.HasFromToArray), (this.resolvedProperty = A))
              : Array.isArray(A)
              ? ((a = this.BindingType.EntireArray), (this.resolvedProperty = A))
              : (this.propertyName = s);
          (this.getValue = this.GetterByBindingType[a]), (this.setValue = this.SetterByBindingTypeAndVersioning[a][o]);
        }
        unbind() {
          (this.node = null), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound);
        }
      }
      ct.Composite = Iw;
      ct.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 };
      ct.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 };
      ct.prototype.GetterByBindingType = [
        ct.prototype._getValue_direct,
        ct.prototype._getValue_array,
        ct.prototype._getValue_arrayElement,
        ct.prototype._getValue_toArray,
      ];
      ct.prototype.SetterByBindingTypeAndVersioning = [
        [ct.prototype._setValue_direct, ct.prototype._setValue_direct_setNeedsUpdate, ct.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
        [ct.prototype._setValue_array, ct.prototype._setValue_array_setNeedsUpdate, ct.prototype._setValue_array_setMatrixWorldNeedsUpdate],
        [
          ct.prototype._setValue_arrayElement,
          ct.prototype._setValue_arrayElement_setNeedsUpdate,
          ct.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [ct.prototype._setValue_fromArray, ct.prototype._setValue_fromArray_setNeedsUpdate, ct.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate],
      ];
      function hd(n, e, t, i) {
        const s = bw(i);
        switch (t) {
          case Wm:
            return n * e;
          case Gu:
            return ((n * e) / s.components) * s.byteLength;
          case ju:
            return ((n * e) / s.components) * s.byteLength;
          case Ym:
            return ((n * e * 2) / s.components) * s.byteLength;
          case Hu:
            return ((n * e * 2) / s.components) * s.byteLength;
          case Km:
            return ((n * e * 3) / s.components) * s.byteLength;
          case kn:
            return ((n * e * 4) / s.components) * s.byteLength;
          case Qu:
            return ((n * e * 4) / s.components) * s.byteLength;
          case yo:
          case To:
            return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
          case Eo:
          case Do:
            return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case il:
          case rl:
            return (Math.max(n, 16) * Math.max(e, 8)) / 4;
          case nl:
          case sl:
            return (Math.max(n, 8) * Math.max(e, 8)) / 2;
          case Al:
          case ol:
            return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
          case al:
            return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case cl:
            return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case ll:
            return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
          case ul:
            return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
          case hl:
            return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
          case fl:
            return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
          case dl:
            return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
          case pl:
            return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
          case ml:
            return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
          case gl:
            return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
          case Pl:
            return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
          case vl:
            return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
          case wl:
            return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
          case _l:
            return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
          case xl:
            return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
          case Mo:
          case yl:
          case Tl:
            return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
          case qm:
          case El:
            return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
          case Dl:
          case Ml:
            return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
        }
        throw new Error(`Unable to determine texture byte length for ${t} format.`);
      }
      function bw(n) {
        switch (n) {
          case hi:
          case Hm:
            return { byteLength: 1, components: 1 };
          case yA:
          case Qm:
          case RA:
            return { byteLength: 2, components: 1 };
          case Nu:
          case ku:
            return { byteLength: 2, components: 4 };
          case Us:
          case Fu:
          case Xn:
            return { byteLength: 4, components: 1 };
          case Vm:
            return { byteLength: 4, components: 3 };
        }
        throw new Error(`Unknown texture type ${n}.`);
      }
      typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: Uu } }));
      typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : (window.__THREE__ = Uu));
      /**
       * @license
       * Copyright 2010-2025 Three.js Authors
       * SPDX-License-Identifier: MIT
       */ function gg() {
        let n = null,
          e = !1,
          t = null,
          i = null;
        function s(r, A) {
          t(r, A), (i = n.requestAnimationFrame(s));
        }
        return {
          start: function () {
            e !== !0 && t !== null && ((i = n.requestAnimationFrame(s)), (e = !0));
          },
          stop: function () {
            n.cancelAnimationFrame(i), (e = !1);
          },
          setAnimationLoop: function (r) {
            t = r;
          },
          setContext: function (r) {
            n = r;
          },
        };
      }
      function zw(n) {
        const e = new WeakMap();
        function t(o, a) {
          const c = o.array,
            l = o.usage,
            u = c.byteLength,
            h = n.createBuffer();
          n.bindBuffer(a, h), n.bufferData(a, c, l), o.onUploadCallback();
          let d;
          if (c instanceof Float32Array) d = n.FLOAT;
          else if (typeof Float16Array < "u" && c instanceof Float16Array) d = n.HALF_FLOAT;
          else if (c instanceof Uint16Array) o.isFloat16BufferAttribute ? (d = n.HALF_FLOAT) : (d = n.UNSIGNED_SHORT);
          else if (c instanceof Int16Array) d = n.SHORT;
          else if (c instanceof Uint32Array) d = n.UNSIGNED_INT;
          else if (c instanceof Int32Array) d = n.INT;
          else if (c instanceof Int8Array) d = n.BYTE;
          else if (c instanceof Uint8Array) d = n.UNSIGNED_BYTE;
          else if (c instanceof Uint8ClampedArray) d = n.UNSIGNED_BYTE;
          else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
          return { buffer: h, type: d, bytesPerElement: c.BYTES_PER_ELEMENT, version: o.version, size: u };
        }
        function i(o, a, c) {
          const l = a.array,
            u = a.updateRanges;
          if ((n.bindBuffer(c, o), u.length === 0)) n.bufferSubData(c, 0, l);
          else {
            u.sort((d, m) => d.start - m.start);
            let h = 0;
            for (let d = 1; d < u.length; d++) {
              const m = u[h],
                g = u[d];
              g.start <= m.start + m.count + 1 ? (m.count = Math.max(m.count, g.start + g.count - m.start)) : (++h, (u[h] = g));
            }
            u.length = h + 1;
            for (let d = 0, m = u.length; d < m; d++) {
              const g = u[d];
              n.bufferSubData(c, g.start * l.BYTES_PER_ELEMENT, l, g.start, g.count);
            }
            a.clearUpdateRanges();
          }
          a.onUploadCallback();
        }
        function s(o) {
          return o.isInterleavedBufferAttribute && (o = o.data), e.get(o);
        }
        function r(o) {
          o.isInterleavedBufferAttribute && (o = o.data);
          const a = e.get(o);
          a && (n.deleteBuffer(a.buffer), e.delete(o));
        }
        function A(o, a) {
          if ((o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute)) {
            const l = e.get(o);
            (!l || l.version < o.version) && e.set(o, { buffer: o.buffer, type: o.type, bytesPerElement: o.elementSize, version: o.version });
            return;
          }
          const c = e.get(o);
          if (c === void 0) e.set(o, t(o, a));
          else if (c.version < o.version) {
            if (c.size !== o.array.byteLength)
              throw new Error(
                "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
              );
            i(c.buffer, o, a), (c.version = o.version);
          }
        }
        return { get: s, remove: r, update: A };
      }
      var Rw = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
        Bw = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
        Ow = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
        Lw = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        Uw = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
        Fw = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
        Nw = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
        kw = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
        Gw = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
        jw = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
        Hw = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
        Qw = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
        Vw = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
        Ww = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
        Kw = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
        Yw = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
        qw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
        Xw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
        Jw = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
        Zw = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
        $w = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
        e1 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
        t1 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
        n1 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
        i1 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
        s1 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
        r1 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
        A1 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
        o1 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
        a1 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
        c1 = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        l1 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
        u1 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
        h1 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
        f1 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
        d1 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
        p1 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
        m1 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
        g1 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
        P1 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
        v1 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
        w1 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
        _1 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
        x1 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
        y1 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
        T1 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
        E1 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
        D1 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
        M1 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
        C1 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
        S1 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
        I1 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
        b1 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
        z1 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
        R1 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
        B1 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
        O1 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
        L1 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        U1 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
        F1 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
        N1 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
        k1 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
        G1 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
        j1 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
        H1 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
        Q1 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
        V1 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
        W1 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
        K1 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
        Y1 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
        q1 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
        X1 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
        J1 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
        Z1 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        $1 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
        e2 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
        t2 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
        n2 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
        i2 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
        s2 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
        r2 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
        A2 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
        o2 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
        a2 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
        c2 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
        l2 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
        u2 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
        h2 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
        f2 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
        d2 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
        p2 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
        m2 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
        g2 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
        P2 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
        v2 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
        w2 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
        _2 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
        x2 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
        y2 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
        T2 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
        E2 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
        D2 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
        M2 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
        C2 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
        S2 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
        I2 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
        b2 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
      const z2 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
        R2 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
        B2 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
        O2 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
        L2 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
        U2 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
        F2 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
        N2 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
        k2 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
        G2 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
        j2 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
        H2 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
        Q2 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        V2 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        W2 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
        K2 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Y2 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        q2 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        X2 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
        J2 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        Z2 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
        $2 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
        e_ = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        t_ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        n_ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
        i_ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        s_ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        r_ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
        A_ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
        o_ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
        a_ = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
        c_ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
        l_ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
        u_ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
        je = {
          alphahash_fragment: Rw,
          alphahash_pars_fragment: Bw,
          alphamap_fragment: Ow,
          alphamap_pars_fragment: Lw,
          alphatest_fragment: Uw,
          alphatest_pars_fragment: Fw,
          aomap_fragment: Nw,
          aomap_pars_fragment: kw,
          batching_pars_vertex: Gw,
          batching_vertex: jw,
          begin_vertex: Hw,
          beginnormal_vertex: Qw,
          bsdfs: Vw,
          iridescence_fragment: Ww,
          bumpmap_pars_fragment: Kw,
          clipping_planes_fragment: Yw,
          clipping_planes_pars_fragment: qw,
          clipping_planes_pars_vertex: Xw,
          clipping_planes_vertex: Jw,
          color_fragment: Zw,
          color_pars_fragment: $w,
          color_pars_vertex: e1,
          color_vertex: t1,
          common: n1,
          cube_uv_reflection_fragment: i1,
          defaultnormal_vertex: s1,
          displacementmap_pars_vertex: r1,
          displacementmap_vertex: A1,
          emissivemap_fragment: o1,
          emissivemap_pars_fragment: a1,
          colorspace_fragment: c1,
          colorspace_pars_fragment: l1,
          envmap_fragment: u1,
          envmap_common_pars_fragment: h1,
          envmap_pars_fragment: f1,
          envmap_pars_vertex: d1,
          envmap_physical_pars_fragment: E1,
          envmap_vertex: p1,
          fog_vertex: m1,
          fog_pars_vertex: g1,
          fog_fragment: P1,
          fog_pars_fragment: v1,
          gradientmap_pars_fragment: w1,
          lightmap_pars_fragment: _1,
          lights_lambert_fragment: x1,
          lights_lambert_pars_fragment: y1,
          lights_pars_begin: T1,
          lights_toon_fragment: D1,
          lights_toon_pars_fragment: M1,
          lights_phong_fragment: C1,
          lights_phong_pars_fragment: S1,
          lights_physical_fragment: I1,
          lights_physical_pars_fragment: b1,
          lights_fragment_begin: z1,
          lights_fragment_maps: R1,
          lights_fragment_end: B1,
          logdepthbuf_fragment: O1,
          logdepthbuf_pars_fragment: L1,
          logdepthbuf_pars_vertex: U1,
          logdepthbuf_vertex: F1,
          map_fragment: N1,
          map_pars_fragment: k1,
          map_particle_fragment: G1,
          map_particle_pars_fragment: j1,
          metalnessmap_fragment: H1,
          metalnessmap_pars_fragment: Q1,
          morphinstance_vertex: V1,
          morphcolor_vertex: W1,
          morphnormal_vertex: K1,
          morphtarget_pars_vertex: Y1,
          morphtarget_vertex: q1,
          normal_fragment_begin: X1,
          normal_fragment_maps: J1,
          normal_pars_fragment: Z1,
          normal_pars_vertex: $1,
          normal_vertex: e2,
          normalmap_pars_fragment: t2,
          clearcoat_normal_fragment_begin: n2,
          clearcoat_normal_fragment_maps: i2,
          clearcoat_pars_fragment: s2,
          iridescence_pars_fragment: r2,
          opaque_fragment: A2,
          packing: o2,
          premultiplied_alpha_fragment: a2,
          project_vertex: c2,
          dithering_fragment: l2,
          dithering_pars_fragment: u2,
          roughnessmap_fragment: h2,
          roughnessmap_pars_fragment: f2,
          shadowmap_pars_fragment: d2,
          shadowmap_pars_vertex: p2,
          shadowmap_vertex: m2,
          shadowmask_pars_fragment: g2,
          skinbase_vertex: P2,
          skinning_pars_vertex: v2,
          skinning_vertex: w2,
          skinnormal_vertex: _2,
          specularmap_fragment: x2,
          specularmap_pars_fragment: y2,
          tonemapping_fragment: T2,
          tonemapping_pars_fragment: E2,
          transmission_fragment: D2,
          transmission_pars_fragment: M2,
          uv_pars_fragment: C2,
          uv_pars_vertex: S2,
          uv_vertex: I2,
          worldpos_vertex: b2,
          background_vert: z2,
          background_frag: R2,
          backgroundCube_vert: B2,
          backgroundCube_frag: O2,
          cube_vert: L2,
          cube_frag: U2,
          depth_vert: F2,
          depth_frag: N2,
          distanceRGBA_vert: k2,
          distanceRGBA_frag: G2,
          equirect_vert: j2,
          equirect_frag: H2,
          linedashed_vert: Q2,
          linedashed_frag: V2,
          meshbasic_vert: W2,
          meshbasic_frag: K2,
          meshlambert_vert: Y2,
          meshlambert_frag: q2,
          meshmatcap_vert: X2,
          meshmatcap_frag: J2,
          meshnormal_vert: Z2,
          meshnormal_frag: $2,
          meshphong_vert: e_,
          meshphong_frag: t_,
          meshphysical_vert: n_,
          meshphysical_frag: i_,
          meshtoon_vert: s_,
          meshtoon_frag: r_,
          points_vert: A_,
          points_frag: o_,
          shadow_vert: a_,
          shadow_frag: c_,
          sprite_vert: l_,
          sprite_frag: u_,
        },
        ie = {
          common: {
            diffuse: { value: new Ue(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            mapTransform: { value: new Ne() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Ne() },
            alphaTest: { value: 0 },
          },
          specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Ne() } },
          envmap: {
            envMap: { value: null },
            envMapRotation: { value: new Ne() },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Ne() } },
          lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Ne() } },
          bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Ne() }, bumpScale: { value: 1 } },
          normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Ne() }, normalScale: { value: new qe(1, 1) } },
          displacementmap: {
            displacementMap: { value: null },
            displacementMapTransform: { value: new Ne() },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Ne() } },
          metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Ne() } },
          roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Ne() } },
          gradientmap: { gradientMap: { value: null } },
          fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Ue(16777215) } },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: { value: [], properties: { direction: {}, color: {} } },
            directionalLightShadows: {
              value: [],
              properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } },
            spotLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
            pointLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
            rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Ue(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Ne() },
            alphaTest: { value: 0 },
            uvTransform: { value: new Ne() },
          },
          sprite: {
            diffuse: { value: new Ue(16777215) },
            opacity: { value: 1 },
            center: { value: new qe(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            mapTransform: { value: new Ne() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Ne() },
            alphaTest: { value: 0 },
          },
        },
        oi = {
          basic: {
            uniforms: tn([ie.common, ie.specularmap, ie.envmap, ie.aomap, ie.lightmap, ie.fog]),
            vertexShader: je.meshbasic_vert,
            fragmentShader: je.meshbasic_frag,
          },
          lambert: {
            uniforms: tn([
              ie.common,
              ie.specularmap,
              ie.envmap,
              ie.aomap,
              ie.lightmap,
              ie.emissivemap,
              ie.bumpmap,
              ie.normalmap,
              ie.displacementmap,
              ie.fog,
              ie.lights,
              { emissive: { value: new Ue(0) } },
            ]),
            vertexShader: je.meshlambert_vert,
            fragmentShader: je.meshlambert_frag,
          },
          phong: {
            uniforms: tn([
              ie.common,
              ie.specularmap,
              ie.envmap,
              ie.aomap,
              ie.lightmap,
              ie.emissivemap,
              ie.bumpmap,
              ie.normalmap,
              ie.displacementmap,
              ie.fog,
              ie.lights,
              { emissive: { value: new Ue(0) }, specular: { value: new Ue(1118481) }, shininess: { value: 30 } },
            ]),
            vertexShader: je.meshphong_vert,
            fragmentShader: je.meshphong_frag,
          },
          standard: {
            uniforms: tn([
              ie.common,
              ie.envmap,
              ie.aomap,
              ie.lightmap,
              ie.emissivemap,
              ie.bumpmap,
              ie.normalmap,
              ie.displacementmap,
              ie.roughnessmap,
              ie.metalnessmap,
              ie.fog,
              ie.lights,
              { emissive: { value: new Ue(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } },
            ]),
            vertexShader: je.meshphysical_vert,
            fragmentShader: je.meshphysical_frag,
          },
          toon: {
            uniforms: tn([
              ie.common,
              ie.aomap,
              ie.lightmap,
              ie.emissivemap,
              ie.bumpmap,
              ie.normalmap,
              ie.displacementmap,
              ie.gradientmap,
              ie.fog,
              ie.lights,
              { emissive: { value: new Ue(0) } },
            ]),
            vertexShader: je.meshtoon_vert,
            fragmentShader: je.meshtoon_frag,
          },
          matcap: {
            uniforms: tn([ie.common, ie.bumpmap, ie.normalmap, ie.displacementmap, ie.fog, { matcap: { value: null } }]),
            vertexShader: je.meshmatcap_vert,
            fragmentShader: je.meshmatcap_frag,
          },
          points: { uniforms: tn([ie.points, ie.fog]), vertexShader: je.points_vert, fragmentShader: je.points_frag },
          dashed: {
            uniforms: tn([ie.common, ie.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]),
            vertexShader: je.linedashed_vert,
            fragmentShader: je.linedashed_frag,
          },
          depth: { uniforms: tn([ie.common, ie.displacementmap]), vertexShader: je.depth_vert, fragmentShader: je.depth_frag },
          normal: {
            uniforms: tn([ie.common, ie.bumpmap, ie.normalmap, ie.displacementmap, { opacity: { value: 1 } }]),
            vertexShader: je.meshnormal_vert,
            fragmentShader: je.meshnormal_frag,
          },
          sprite: { uniforms: tn([ie.sprite, ie.fog]), vertexShader: je.sprite_vert, fragmentShader: je.sprite_frag },
          background: {
            uniforms: { uvTransform: { value: new Ne() }, t2D: { value: null }, backgroundIntensity: { value: 1 } },
            vertexShader: je.background_vert,
            fragmentShader: je.background_frag,
          },
          backgroundCube: {
            uniforms: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              backgroundBlurriness: { value: 0 },
              backgroundIntensity: { value: 1 },
              backgroundRotation: { value: new Ne() },
            },
            vertexShader: je.backgroundCube_vert,
            fragmentShader: je.backgroundCube_frag,
          },
          cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: je.cube_vert, fragmentShader: je.cube_frag },
          equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: je.equirect_vert, fragmentShader: je.equirect_frag },
          distanceRGBA: {
            uniforms: tn([ie.common, ie.displacementmap, { referencePosition: { value: new R() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]),
            vertexShader: je.distanceRGBA_vert,
            fragmentShader: je.distanceRGBA_frag,
          },
          shadow: {
            uniforms: tn([ie.lights, ie.fog, { color: { value: new Ue(0) }, opacity: { value: 1 } }]),
            vertexShader: je.shadow_vert,
            fragmentShader: je.shadow_frag,
          },
        };
      oi.physical = {
        uniforms: tn([
          oi.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatMapTransform: { value: new Ne() },
            clearcoatNormalMap: { value: null },
            clearcoatNormalMapTransform: { value: new Ne() },
            clearcoatNormalScale: { value: new qe(1, 1) },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatRoughnessMapTransform: { value: new Ne() },
            dispersion: { value: 0 },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceMapTransform: { value: new Ne() },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            iridescenceThicknessMapTransform: { value: new Ne() },
            sheen: { value: 0 },
            sheenColor: { value: new Ue(0) },
            sheenColorMap: { value: null },
            sheenColorMapTransform: { value: new Ne() },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            sheenRoughnessMapTransform: { value: new Ne() },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionMapTransform: { value: new Ne() },
            transmissionSamplerSize: { value: new qe() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            thicknessMapTransform: { value: new Ne() },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new Ue(0) },
            specularColor: { value: new Ue(1, 1, 1) },
            specularColorMap: { value: null },
            specularColorMapTransform: { value: new Ne() },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularIntensityMapTransform: { value: new Ne() },
            anisotropyVector: { value: new qe() },
            anisotropyMap: { value: null },
            anisotropyMapTransform: { value: new Ne() },
          },
        ]),
        vertexShader: je.meshphysical_vert,
        fragmentShader: je.meshphysical_frag,
      };
      const fo = { r: 0, b: 0, g: 0 },
        _s = new fi(),
        h_ = new ke();
      function f_(n, e, t, i, s, r, A) {
        const o = new Ue(0);
        let a = r === !0 ? 0 : 1,
          c,
          l,
          u = null,
          h = 0,
          d = null;
        function m(T) {
          let _ = T.isScene === !0 ? T.background : null;
          return _ && _.isTexture && (_ = (T.backgroundBlurriness > 0 ? t : e).get(_)), _;
        }
        function g(T) {
          let _ = !1;
          const b = m(T);
          b === null ? f(o, a) : b && b.isColor && (f(b, 1), (_ = !0));
          const S = n.xr.getEnvironmentBlendMode();
          S === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, A) : S === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, A),
            (n.autoClear || _) &&
              (i.buffers.depth.setTest(!0),
              i.buffers.depth.setMask(!0),
              i.buffers.color.setMask(!0),
              n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
        }
        function p(T, _) {
          const b = m(_);
          b && (b.isCubeTexture || b.mapping === va)
            ? (l === void 0 &&
                ((l = new En(
                  new BA(1, 1, 1),
                  new cs({
                    name: "BackgroundCubeMaterial",
                    uniforms: Ir(oi.backgroundCube.uniforms),
                    vertexShader: oi.backgroundCube.vertexShader,
                    fragmentShader: oi.backgroundCube.fragmentShader,
                    side: fn,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                    allowOverride: !1,
                  })
                )),
                l.geometry.deleteAttribute("normal"),
                l.geometry.deleteAttribute("uv"),
                (l.onBeforeRender = function (S, D, O) {
                  this.matrixWorld.copyPosition(O.matrixWorld);
                }),
                Object.defineProperty(l.material, "envMap", {
                  get: function () {
                    return this.uniforms.envMap.value;
                  },
                }),
                s.update(l)),
              _s.copy(_.backgroundRotation),
              (_s.x *= -1),
              (_s.y *= -1),
              (_s.z *= -1),
              b.isCubeTexture && b.isRenderTargetTexture === !1 && ((_s.y *= -1), (_s.z *= -1)),
              (l.material.uniforms.envMap.value = b),
              (l.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1),
              (l.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness),
              (l.material.uniforms.backgroundIntensity.value = _.backgroundIntensity),
              l.material.uniforms.backgroundRotation.value.setFromMatrix4(h_.makeRotationFromEuler(_s)),
              (l.material.toneMapped = Xe.getTransfer(b.colorSpace) !== ut),
              (u !== b || h !== b.version || d !== n.toneMapping) && ((l.material.needsUpdate = !0), (u = b), (h = b.version), (d = n.toneMapping)),
              l.layers.enableAll(),
              T.unshift(l, l.geometry, l.material, 0, 0, null))
            : b &&
              b.isTexture &&
              (c === void 0 &&
                ((c = new En(
                  new _a(2, 2),
                  new cs({
                    name: "BackgroundMaterial",
                    uniforms: Ir(oi.background.uniforms),
                    vertexShader: oi.background.vertexShader,
                    fragmentShader: oi.background.fragmentShader,
                    side: ki,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                    allowOverride: !1,
                  })
                )),
                c.geometry.deleteAttribute("normal"),
                Object.defineProperty(c.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  },
                }),
                s.update(c)),
              (c.material.uniforms.t2D.value = b),
              (c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity),
              (c.material.toneMapped = Xe.getTransfer(b.colorSpace) !== ut),
              b.matrixAutoUpdate === !0 && b.updateMatrix(),
              c.material.uniforms.uvTransform.value.copy(b.matrix),
              (u !== b || h !== b.version || d !== n.toneMapping) && ((c.material.needsUpdate = !0), (u = b), (h = b.version), (d = n.toneMapping)),
              c.layers.enableAll(),
              T.unshift(c, c.geometry, c.material, 0, 0, null));
        }
        function f(T, _) {
          T.getRGB(fo, rg(n)), i.buffers.color.setClear(fo.r, fo.g, fo.b, _, A);
        }
        function E() {
          l !== void 0 && (l.geometry.dispose(), l.material.dispose(), (l = void 0)),
            c !== void 0 && (c.geometry.dispose(), c.material.dispose(), (c = void 0));
        }
        return {
          getClearColor: function () {
            return o;
          },
          setClearColor: function (T, _ = 1) {
            o.set(T), (a = _), f(o, a);
          },
          getClearAlpha: function () {
            return a;
          },
          setClearAlpha: function (T) {
            (a = T), f(o, a);
          },
          render: g,
          addToRenderList: p,
          dispose: E,
        };
      }
      function d_(n, e) {
        const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
          i = {},
          s = h(null);
        let r = s,
          A = !1;
        function o(w, I, H, N, Y) {
          let q = !1;
          const V = u(N, H, I);
          r !== V && ((r = V), c(r.object)),
            (q = d(w, N, H, Y)),
            q && m(w, N, H, Y),
            Y !== null && e.update(Y, n.ELEMENT_ARRAY_BUFFER),
            (q || A) && ((A = !1), _(w, I, H, N), Y !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(Y).buffer));
        }
        function a() {
          return n.createVertexArray();
        }
        function c(w) {
          return n.bindVertexArray(w);
        }
        function l(w) {
          return n.deleteVertexArray(w);
        }
        function u(w, I, H) {
          const N = H.wireframe === !0;
          let Y = i[w.id];
          Y === void 0 && ((Y = {}), (i[w.id] = Y));
          let q = Y[I.id];
          q === void 0 && ((q = {}), (Y[I.id] = q));
          let V = q[N];
          return V === void 0 && ((V = h(a())), (q[N] = V)), V;
        }
        function h(w) {
          const I = [],
            H = [],
            N = [];
          for (let Y = 0; Y < t; Y++) (I[Y] = 0), (H[Y] = 0), (N[Y] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: I,
            enabledAttributes: H,
            attributeDivisors: N,
            object: w,
            attributes: {},
            index: null,
          };
        }
        function d(w, I, H, N) {
          const Y = r.attributes,
            q = I.attributes;
          let V = 0;
          const J = H.getAttributes();
          for (const k in J)
            if (J[k].location >= 0) {
              const he = Y[k];
              let Me = q[k];
              if (
                (Me === void 0 &&
                  (k === "instanceMatrix" && w.instanceMatrix && (Me = w.instanceMatrix), k === "instanceColor" && w.instanceColor && (Me = w.instanceColor)),
                he === void 0 || he.attribute !== Me || (Me && he.data !== Me.data))
              )
                return !0;
              V++;
            }
          return r.attributesNum !== V || r.index !== N;
        }
        function m(w, I, H, N) {
          const Y = {},
            q = I.attributes;
          let V = 0;
          const J = H.getAttributes();
          for (const k in J)
            if (J[k].location >= 0) {
              let he = q[k];
              he === void 0 &&
                (k === "instanceMatrix" && w.instanceMatrix && (he = w.instanceMatrix), k === "instanceColor" && w.instanceColor && (he = w.instanceColor));
              const Me = {};
              (Me.attribute = he), he && he.data && (Me.data = he.data), (Y[k] = Me), V++;
            }
          (r.attributes = Y), (r.attributesNum = V), (r.index = N);
        }
        function g() {
          const w = r.newAttributes;
          for (let I = 0, H = w.length; I < H; I++) w[I] = 0;
        }
        function p(w) {
          f(w, 0);
        }
        function f(w, I) {
          const H = r.newAttributes,
            N = r.enabledAttributes,
            Y = r.attributeDivisors;
          (H[w] = 1), N[w] === 0 && (n.enableVertexAttribArray(w), (N[w] = 1)), Y[w] !== I && (n.vertexAttribDivisor(w, I), (Y[w] = I));
        }
        function E() {
          const w = r.newAttributes,
            I = r.enabledAttributes;
          for (let H = 0, N = I.length; H < N; H++) I[H] !== w[H] && (n.disableVertexAttribArray(H), (I[H] = 0));
        }
        function T(w, I, H, N, Y, q, V) {
          V === !0 ? n.vertexAttribIPointer(w, I, H, Y, q) : n.vertexAttribPointer(w, I, H, N, Y, q);
        }
        function _(w, I, H, N) {
          g();
          const Y = N.attributes,
            q = H.getAttributes(),
            V = I.defaultAttributeValues;
          for (const J in q) {
            const k = q[J];
            if (k.location >= 0) {
              let oe = Y[J];
              if (
                (oe === void 0 &&
                  (J === "instanceMatrix" && w.instanceMatrix && (oe = w.instanceMatrix), J === "instanceColor" && w.instanceColor && (oe = w.instanceColor)),
                oe !== void 0)
              ) {
                const he = oe.normalized,
                  Me = oe.itemSize,
                  He = e.get(oe);
                if (He === void 0) continue;
                const ht = He.buffer,
                  Q = He.type,
                  te = He.bytesPerElement,
                  Te = Q === n.INT || Q === n.UNSIGNED_INT || oe.gpuType === Fu;
                if (oe.isInterleavedBufferAttribute) {
                  const ae = oe.data,
                    Ee = ae.stride,
                    tt = oe.offset;
                  if (ae.isInstancedInterleavedBuffer) {
                    for (let Re = 0; Re < k.locationSize; Re++) f(k.location + Re, ae.meshPerAttribute);
                    w.isInstancedMesh !== !0 && N._maxInstanceCount === void 0 && (N._maxInstanceCount = ae.meshPerAttribute * ae.count);
                  } else for (let Re = 0; Re < k.locationSize; Re++) p(k.location + Re);
                  n.bindBuffer(n.ARRAY_BUFFER, ht);
                  for (let Re = 0; Re < k.locationSize; Re++)
                    T(k.location + Re, Me / k.locationSize, Q, he, Ee * te, (tt + (Me / k.locationSize) * Re) * te, Te);
                } else {
                  if (oe.isInstancedBufferAttribute) {
                    for (let ae = 0; ae < k.locationSize; ae++) f(k.location + ae, oe.meshPerAttribute);
                    w.isInstancedMesh !== !0 && N._maxInstanceCount === void 0 && (N._maxInstanceCount = oe.meshPerAttribute * oe.count);
                  } else for (let ae = 0; ae < k.locationSize; ae++) p(k.location + ae);
                  n.bindBuffer(n.ARRAY_BUFFER, ht);
                  for (let ae = 0; ae < k.locationSize; ae++) T(k.location + ae, Me / k.locationSize, Q, he, Me * te, (Me / k.locationSize) * ae * te, Te);
                }
              } else if (V !== void 0) {
                const he = V[J];
                if (he !== void 0)
                  switch (he.length) {
                    case 2:
                      n.vertexAttrib2fv(k.location, he);
                      break;
                    case 3:
                      n.vertexAttrib3fv(k.location, he);
                      break;
                    case 4:
                      n.vertexAttrib4fv(k.location, he);
                      break;
                    default:
                      n.vertexAttrib1fv(k.location, he);
                  }
              }
            }
          }
          E();
        }
        function b() {
          O();
          for (const w in i) {
            const I = i[w];
            for (const H in I) {
              const N = I[H];
              for (const Y in N) l(N[Y].object), delete N[Y];
              delete I[H];
            }
            delete i[w];
          }
        }
        function S(w) {
          if (i[w.id] === void 0) return;
          const I = i[w.id];
          for (const H in I) {
            const N = I[H];
            for (const Y in N) l(N[Y].object), delete N[Y];
            delete I[H];
          }
          delete i[w.id];
        }
        function D(w) {
          for (const I in i) {
            const H = i[I];
            if (H[w.id] === void 0) continue;
            const N = H[w.id];
            for (const Y in N) l(N[Y].object), delete N[Y];
            delete H[w.id];
          }
        }
        function O() {
          x(), (A = !0), r !== s && ((r = s), c(r.object));
        }
        function x() {
          (s.geometry = null), (s.program = null), (s.wireframe = !1);
        }
        return {
          setup: o,
          reset: O,
          resetDefaultState: x,
          dispose: b,
          releaseStatesOfGeometry: S,
          releaseStatesOfProgram: D,
          initAttributes: g,
          enableAttribute: p,
          disableUnusedAttributes: E,
        };
      }
      function p_(n, e, t) {
        let i;
        function s(c) {
          i = c;
        }
        function r(c, l) {
          n.drawArrays(i, c, l), t.update(l, i, 1);
        }
        function A(c, l, u) {
          u !== 0 && (n.drawArraysInstanced(i, c, l, u), t.update(l, i, u));
        }
        function o(c, l, u) {
          if (u === 0) return;
          e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, l, 0, u);
          let d = 0;
          for (let m = 0; m < u; m++) d += l[m];
          t.update(d, i, 1);
        }
        function a(c, l, u, h) {
          if (u === 0) return;
          const d = e.get("WEBGL_multi_draw");
          if (d === null) for (let m = 0; m < c.length; m++) A(c[m], l[m], h[m]);
          else {
            d.multiDrawArraysInstancedWEBGL(i, c, 0, l, 0, h, 0, u);
            let m = 0;
            for (let g = 0; g < u; g++) m += l[g] * h[g];
            t.update(m, i, 1);
          }
        }
        (this.setMode = s), (this.render = r), (this.renderInstances = A), (this.renderMultiDraw = o), (this.renderMultiDrawInstances = a);
      }
      function m_(n, e, t, i) {
        let s;
        function r() {
          if (s !== void 0) return s;
          if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const D = e.get("EXT_texture_filter_anisotropic");
            s = n.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else s = 0;
          return s;
        }
        function A(D) {
          return !(D !== kn && i.convert(D) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT));
        }
        function o(D) {
          const O = D === RA && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
          return !(D !== hi && i.convert(D) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && D !== Xn && !O);
        }
        function a(D) {
          if (D === "highp") {
            if (
              n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 &&
              n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0
            )
              return "highp";
            D = "mediump";
          }
          return D === "mediump" &&
            n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 &&
            n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0
            ? "mediump"
            : "lowp";
        }
        let c = t.precision !== void 0 ? t.precision : "highp";
        const l = a(c);
        l !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", l, "instead."), (c = l));
        const u = t.logarithmicDepthBuffer === !0,
          h = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
          d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
          m = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          g = n.getParameter(n.MAX_TEXTURE_SIZE),
          p = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
          f = n.getParameter(n.MAX_VERTEX_ATTRIBS),
          E = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
          T = n.getParameter(n.MAX_VARYING_VECTORS),
          _ = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
          b = m > 0,
          S = n.getParameter(n.MAX_SAMPLES);
        return {
          isWebGL2: !0,
          getMaxAnisotropy: r,
          getMaxPrecision: a,
          textureFormatReadable: A,
          textureTypeReadable: o,
          precision: c,
          logarithmicDepthBuffer: u,
          reverseDepthBuffer: h,
          maxTextures: d,
          maxVertexTextures: m,
          maxTextureSize: g,
          maxCubemapSize: p,
          maxAttributes: f,
          maxVertexUniforms: E,
          maxVaryings: T,
          maxFragmentUniforms: _,
          vertexTextures: b,
          maxSamples: S,
        };
      }
      function g_(n) {
        const e = this;
        let t = null,
          i = 0,
          s = !1,
          r = !1;
        const A = new Es(),
          o = new Ne(),
          a = { value: null, needsUpdate: !1 };
        (this.uniform = a),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (u, h) {
            const d = u.length !== 0 || h || i !== 0 || s;
            return (s = h), (i = u.length), d;
          }),
          (this.beginShadows = function () {
            (r = !0), l(null);
          }),
          (this.endShadows = function () {
            r = !1;
          }),
          (this.setGlobalState = function (u, h) {
            t = l(u, h, 0);
          }),
          (this.setState = function (u, h, d) {
            const m = u.clippingPlanes,
              g = u.clipIntersection,
              p = u.clipShadows,
              f = n.get(u);
            if (!s || m === null || m.length === 0 || (r && !p)) r ? l(null) : c();
            else {
              const E = r ? 0 : i,
                T = E * 4;
              let _ = f.clippingState || null;
              (a.value = _), (_ = l(m, h, T, d));
              for (let b = 0; b !== T; ++b) _[b] = t[b];
              (f.clippingState = _), (this.numIntersection = g ? this.numPlanes : 0), (this.numPlanes += E);
            }
          });
        function c() {
          a.value !== t && ((a.value = t), (a.needsUpdate = i > 0)), (e.numPlanes = i), (e.numIntersection = 0);
        }
        function l(u, h, d, m) {
          const g = u !== null ? u.length : 0;
          let p = null;
          if (g !== 0) {
            if (((p = a.value), m !== !0 || p === null)) {
              const f = d + g * 4,
                E = h.matrixWorldInverse;
              o.getNormalMatrix(E), (p === null || p.length < f) && (p = new Float32Array(f));
              for (let T = 0, _ = d; T !== g; ++T, _ += 4) A.copy(u[T]).applyMatrix4(E, o), A.normal.toArray(p, _), (p[_ + 3] = A.constant);
            }
            (a.value = p), (a.needsUpdate = !0);
          }
          return (e.numPlanes = g), (e.numIntersection = 0), p;
        }
      }
      function P_(n) {
        let e = new WeakMap();
        function t(A, o) {
          return o === el ? (A.mapping = Dr) : o === tl && (A.mapping = Mr), A;
        }
        function i(A) {
          if (A && A.isTexture) {
            const o = A.mapping;
            if (o === el || o === tl)
              if (e.has(A)) {
                const a = e.get(A).texture;
                return t(a, A.mapping);
              } else {
                const a = A.image;
                if (a && a.height > 0) {
                  const c = new Uv(a.height);
                  return c.fromEquirectangularTexture(n, A), e.set(A, c), A.addEventListener("dispose", s), t(c.texture, A.mapping);
                } else return null;
              }
          }
          return A;
        }
        function s(A) {
          const o = A.target;
          o.removeEventListener("dispose", s);
          const a = e.get(o);
          a !== void 0 && (e.delete(o), a.dispose());
        }
        function r() {
          e = new WeakMap();
        }
        return { get: i, dispose: r };
      }
      const Ar = 4,
        fd = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        Cs = 20,
        dc = new $u(),
        dd = new Ue();
      let pc = null,
        mc = 0,
        gc = 0,
        Pc = !1;
      const Ds = (1 + Math.sqrt(5)) / 2,
        sr = 1 / Ds,
        pd = [
          new R(-Ds, sr, 0),
          new R(Ds, sr, 0),
          new R(-sr, 0, Ds),
          new R(sr, 0, Ds),
          new R(0, Ds, -sr),
          new R(0, Ds, sr),
          new R(-1, 1, -1),
          new R(1, 1, -1),
          new R(-1, 1, 1),
          new R(1, 1, 1),
        ],
        v_ = new R();
      class md {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, i = 0.1, s = 100, r = {}) {
          const { size: A = 256, position: o = v_ } = r;
          (pc = this._renderer.getRenderTarget()),
            (mc = this._renderer.getActiveCubeFace()),
            (gc = this._renderer.getActiveMipmapLevel()),
            (Pc = this._renderer.xr.enabled),
            (this._renderer.xr.enabled = !1),
            this._setSize(A);
          const a = this._allocateTargets();
          return (a.depthBuffer = !0), this._sceneToCubeUV(e, i, s, a, o), t > 0 && this._blur(a, 0, 0, t), this._applyPMREM(a), this._cleanup(a), a;
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          this._cubemapMaterial === null && ((this._cubemapMaterial = vd()), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          this._equirectMaterial === null && ((this._equirectMaterial = Pd()), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
            this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          (this._lodMax = Math.floor(Math.log2(e))), (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(pc, mc, gc), (this._renderer.xr.enabled = Pc), (e.scissorTest = !1), po(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          e.mapping === Dr || e.mapping === Mr
            ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width)
            : this._setSize(e.image.width / 4),
            (pc = this._renderer.getRenderTarget()),
            (mc = this._renderer.getActiveCubeFace()),
            (gc = this._renderer.getActiveMipmapLevel()),
            (Pc = this._renderer.xr.enabled),
            (this._renderer.xr.enabled = !1);
          const i = t || this._allocateTargets();
          return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            i = { magFilter: Tn, minFilter: Tn, generateMipmaps: !1, type: RA, format: kn, colorSpace: on, depthBuffer: !1 },
            s = gd(e, t, i);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(), (this._pingPongRenderTarget = gd(e, t, i));
            const { _lodMax: r } = this;
            ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = w_(r)), (this._blurMaterial = __(r, e, t));
          }
          return s;
        }
        _compileMaterial(e) {
          const t = new En(this._lodPlanes[0], e);
          this._renderer.compile(t, dc);
        }
        _sceneToCubeUV(e, t, i, s, r) {
          const a = new nn(90, 1, t, i),
            c = [1, -1, 1, 1, 1, 1],
            l = [1, 1, 1, -1, -1, -1],
            u = this._renderer,
            h = u.autoClear,
            d = u.toneMapping;
          u.getClearColor(dd), (u.toneMapping = As), (u.autoClear = !1);
          const m = new bs({ name: "PMREM.Background", side: fn, depthWrite: !1, depthTest: !1 }),
            g = new En(new BA(), m);
          let p = !1;
          const f = e.background;
          f ? f.isColor && (m.color.copy(f), (e.background = null), (p = !0)) : (m.color.copy(dd), (p = !0));
          for (let E = 0; E < 6; E++) {
            const T = E % 3;
            T === 0
              ? (a.up.set(0, c[E], 0), a.position.set(r.x, r.y, r.z), a.lookAt(r.x + l[E], r.y, r.z))
              : T === 1
              ? (a.up.set(0, 0, c[E]), a.position.set(r.x, r.y, r.z), a.lookAt(r.x, r.y + l[E], r.z))
              : (a.up.set(0, c[E], 0), a.position.set(r.x, r.y, r.z), a.lookAt(r.x, r.y, r.z + l[E]));
            const _ = this._cubeSize;
            po(s, T * _, E > 2 ? _ : 0, _, _), u.setRenderTarget(s), p && u.render(g, a), u.render(e, a);
          }
          g.geometry.dispose(), g.material.dispose(), (u.toneMapping = d), (u.autoClear = h), (e.background = f);
        }
        _textureToCubeUV(e, t) {
          const i = this._renderer,
            s = e.mapping === Dr || e.mapping === Mr;
          s
            ? (this._cubemapMaterial === null && (this._cubemapMaterial = vd()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1))
            : this._equirectMaterial === null && (this._equirectMaterial = Pd());
          const r = s ? this._cubemapMaterial : this._equirectMaterial,
            A = new En(this._lodPlanes[0], r),
            o = r.uniforms;
          o.envMap.value = e;
          const a = this._cubeSize;
          po(t, 0, 0, 3 * a, 2 * a), i.setRenderTarget(t), i.render(A, dc);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            i = t.autoClear;
          t.autoClear = !1;
          const s = this._lodPlanes.length;
          for (let r = 1; r < s; r++) {
            const A = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
              o = pd[(s - r - 1) % pd.length];
            this._blur(e, r - 1, r, A, o);
          }
          t.autoClear = i;
        }
        _blur(e, t, i, s, r) {
          const A = this._pingPongRenderTarget;
          this._halfBlur(e, A, t, i, s, "latitudinal", r), this._halfBlur(A, e, i, i, s, "longitudinal", r);
        }
        _halfBlur(e, t, i, s, r, A, o) {
          const a = this._renderer,
            c = this._blurMaterial;
          A !== "latitudinal" && A !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
          const l = 3,
            u = new En(this._lodPlanes[s], c),
            h = c.uniforms,
            d = this._sizeLods[i] - 1,
            m = isFinite(r) ? Math.PI / (2 * d) : (2 * Math.PI) / (2 * Cs - 1),
            g = r / m,
            p = isFinite(r) ? 1 + Math.floor(l * g) : Cs;
          p > Cs && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${Cs}`);
          const f = [];
          let E = 0;
          for (let D = 0; D < Cs; ++D) {
            const O = D / g,
              x = Math.exp((-O * O) / 2);
            f.push(x), D === 0 ? (E += x) : D < p && (E += 2 * x);
          }
          for (let D = 0; D < f.length; D++) f[D] = f[D] / E;
          (h.envMap.value = e.texture), (h.samples.value = p), (h.weights.value = f), (h.latitudinal.value = A === "latitudinal"), o && (h.poleAxis.value = o);
          const { _lodMax: T } = this;
          (h.dTheta.value = m), (h.mipInt.value = T - i);
          const _ = this._sizeLods[s],
            b = 3 * _ * (s > T - Ar ? s - T + Ar : 0),
            S = 4 * (this._cubeSize - _);
          po(t, b, S, 3 * _, 2 * _), a.setRenderTarget(t), a.render(u, dc);
        }
      }
      function w_(n) {
        const e = [],
          t = [],
          i = [];
        let s = n;
        const r = n - Ar + 1 + fd.length;
        for (let A = 0; A < r; A++) {
          const o = Math.pow(2, s);
          t.push(o);
          let a = 1 / o;
          A > n - Ar ? (a = fd[A - n + Ar - 1]) : A === 0 && (a = 0), i.push(a);
          const c = 1 / (o - 2),
            l = -c,
            u = 1 + c,
            h = [l, l, u, l, u, u, l, l, u, u, l, u],
            d = 6,
            m = 6,
            g = 3,
            p = 2,
            f = 1,
            E = new Float32Array(g * m * d),
            T = new Float32Array(p * m * d),
            _ = new Float32Array(f * m * d);
          for (let S = 0; S < d; S++) {
            const D = ((S % 3) * 2) / 3 - 1,
              O = S > 2 ? 0 : -1,
              x = [D, O, 0, D + 2 / 3, O, 0, D + 2 / 3, O + 1, 0, D, O, 0, D + 2 / 3, O + 1, 0, D, O + 1, 0];
            E.set(x, g * m * S), T.set(h, p * m * S);
            const w = [S, S, S, S, S, S];
            _.set(w, f * m * S);
          }
          const b = new mi();
          b.setAttribute("position", new rn(E, g)), b.setAttribute("uv", new rn(T, p)), b.setAttribute("faceIndex", new rn(_, f)), e.push(b), s > Ar && s--;
        }
        return { lodPlanes: e, sizeLods: t, sigmas: i };
      }
      function gd(n, e, t) {
        const i = new Fs(n, e, t);
        return (i.texture.mapping = va), (i.texture.name = "PMREM.cubeUv"), (i.scissorTest = !0), i;
      }
      function po(n, e, t, i, s) {
        n.viewport.set(e, t, i, s), n.scissor.set(e, t, i, s);
      }
      function __(n, e, t) {
        const i = new Float32Array(Cs),
          s = new R(0, 1, 0);
        return new cs({
          name: "SphericalGaussianBlur",
          defines: { n: Cs, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${n}.0` },
          uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: i },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: s },
          },
          vertexShader: nh(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: rs,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Pd() {
        return new cs({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader: nh(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: rs,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function vd() {
        return new cs({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader: nh(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: rs,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function nh() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function x_(n) {
        let e = new WeakMap(),
          t = null;
        function i(o) {
          if (o && o.isTexture) {
            const a = o.mapping,
              c = a === el || a === tl,
              l = a === Dr || a === Mr;
            if (c || l) {
              let u = e.get(o);
              const h = u !== void 0 ? u.texture.pmremVersion : 0;
              if (o.isRenderTargetTexture && o.pmremVersion !== h)
                return (
                  t === null && (t = new md(n)),
                  (u = c ? t.fromEquirectangular(o, u) : t.fromCubemap(o, u)),
                  (u.texture.pmremVersion = o.pmremVersion),
                  e.set(o, u),
                  u.texture
                );
              if (u !== void 0) return u.texture;
              {
                const d = o.image;
                return (c && d && d.height > 0) || (l && d && s(d))
                  ? (t === null && (t = new md(n)),
                    (u = c ? t.fromEquirectangular(o) : t.fromCubemap(o)),
                    (u.texture.pmremVersion = o.pmremVersion),
                    e.set(o, u),
                    o.addEventListener("dispose", r),
                    u.texture)
                  : null;
              }
            }
          }
          return o;
        }
        function s(o) {
          let a = 0;
          const c = 6;
          for (let l = 0; l < c; l++) o[l] !== void 0 && a++;
          return a === c;
        }
        function r(o) {
          const a = o.target;
          a.removeEventListener("dispose", r);
          const c = e.get(a);
          c !== void 0 && (e.delete(a), c.dispose());
        }
        function A() {
          (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
        }
        return { get: i, dispose: A };
      }
      function y_(n) {
        const e = {};
        function t(i) {
          if (e[i] !== void 0) return e[i];
          let s;
          switch (i) {
            case "WEBGL_depth_texture":
              s = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              s =
                n.getExtension("EXT_texture_filter_anisotropic") ||
                n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              s =
                n.getExtension("WEBGL_compressed_texture_s3tc") ||
                n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              s = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              s = n.getExtension(i);
          }
          return (e[i] = s), s;
        }
        return {
          has: function (i) {
            return t(i) !== null;
          },
          init: function () {
            t("EXT_color_buffer_float"),
              t("WEBGL_clip_cull_distance"),
              t("OES_texture_float_linear"),
              t("EXT_color_buffer_half_float"),
              t("WEBGL_multisampled_render_to_texture"),
              t("WEBGL_render_shared_exponent");
          },
          get: function (i) {
            const s = t(i);
            return s === null && ur("THREE.WebGLRenderer: " + i + " extension not supported."), s;
          },
        };
      }
      function T_(n, e, t, i) {
        const s = {},
          r = new WeakMap();
        function A(u) {
          const h = u.target;
          h.index !== null && e.remove(h.index);
          for (const m in h.attributes) e.remove(h.attributes[m]);
          h.removeEventListener("dispose", A), delete s[h.id];
          const d = r.get(h);
          d && (e.remove(d), r.delete(h)),
            i.releaseStatesOfGeometry(h),
            h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount,
            t.memory.geometries--;
        }
        function o(u, h) {
          return s[h.id] === !0 || (h.addEventListener("dispose", A), (s[h.id] = !0), t.memory.geometries++), h;
        }
        function a(u) {
          const h = u.attributes;
          for (const d in h) e.update(h[d], n.ARRAY_BUFFER);
        }
        function c(u) {
          const h = [],
            d = u.index,
            m = u.attributes.position;
          let g = 0;
          if (d !== null) {
            const E = d.array;
            g = d.version;
            for (let T = 0, _ = E.length; T < _; T += 3) {
              const b = E[T + 0],
                S = E[T + 1],
                D = E[T + 2];
              h.push(b, S, S, D, D, b);
            }
          } else if (m !== void 0) {
            const E = m.array;
            g = m.version;
            for (let T = 0, _ = E.length / 3 - 1; T < _; T += 3) {
              const b = T + 0,
                S = T + 1,
                D = T + 2;
              h.push(b, S, S, D, D, b);
            }
          } else return;
          const p = new ($m(h) ? sg : ig)(h, 1);
          p.version = g;
          const f = r.get(u);
          f && e.remove(f), r.set(u, p);
        }
        function l(u) {
          const h = r.get(u);
          if (h) {
            const d = u.index;
            d !== null && h.version < d.version && c(u);
          } else c(u);
          return r.get(u);
        }
        return { get: o, update: a, getWireframeAttribute: l };
      }
      function E_(n, e, t) {
        let i;
        function s(h) {
          i = h;
        }
        let r, A;
        function o(h) {
          (r = h.type), (A = h.bytesPerElement);
        }
        function a(h, d) {
          n.drawElements(i, d, r, h * A), t.update(d, i, 1);
        }
        function c(h, d, m) {
          m !== 0 && (n.drawElementsInstanced(i, d, r, h * A, m), t.update(d, i, m));
        }
        function l(h, d, m) {
          if (m === 0) return;
          e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, d, 0, r, h, 0, m);
          let p = 0;
          for (let f = 0; f < m; f++) p += d[f];
          t.update(p, i, 1);
        }
        function u(h, d, m, g) {
          if (m === 0) return;
          const p = e.get("WEBGL_multi_draw");
          if (p === null) for (let f = 0; f < h.length; f++) c(h[f] / A, d[f], g[f]);
          else {
            p.multiDrawElementsInstancedWEBGL(i, d, 0, r, h, 0, g, 0, m);
            let f = 0;
            for (let E = 0; E < m; E++) f += d[E] * g[E];
            t.update(f, i, 1);
          }
        }
        (this.setMode = s), (this.setIndex = o), (this.render = a), (this.renderInstances = c), (this.renderMultiDraw = l), (this.renderMultiDrawInstances = u);
      }
      function D_(n) {
        const e = { geometries: 0, textures: 0 },
          t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        function i(r, A, o) {
          switch ((t.calls++, A)) {
            case n.TRIANGLES:
              t.triangles += o * (r / 3);
              break;
            case n.LINES:
              t.lines += o * (r / 2);
              break;
            case n.LINE_STRIP:
              t.lines += o * (r - 1);
              break;
            case n.LINE_LOOP:
              t.lines += o * r;
              break;
            case n.POINTS:
              t.points += o * r;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", A);
              break;
          }
        }
        function s() {
          (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
        }
        return { memory: e, render: t, programs: null, autoReset: !0, reset: s, update: i };
      }
      function M_(n, e, t) {
        const i = new WeakMap(),
          s = new st();
        function r(A, o, a) {
          const c = A.morphTargetInfluences,
            l = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color,
            u = l !== void 0 ? l.length : 0;
          let h = i.get(o);
          if (h === void 0 || h.count !== u) {
            let w = function () {
              O.dispose(), i.delete(o), o.removeEventListener("dispose", w);
            };
            var d = w;
            h !== void 0 && h.texture.dispose();
            const m = o.morphAttributes.position !== void 0,
              g = o.morphAttributes.normal !== void 0,
              p = o.morphAttributes.color !== void 0,
              f = o.morphAttributes.position || [],
              E = o.morphAttributes.normal || [],
              T = o.morphAttributes.color || [];
            let _ = 0;
            m === !0 && (_ = 1), g === !0 && (_ = 2), p === !0 && (_ = 3);
            let b = o.attributes.position.count * _,
              S = 1;
            b > e.maxTextureSize && ((S = Math.ceil(b / e.maxTextureSize)), (b = e.maxTextureSize));
            const D = new Float32Array(b * S * 4 * u),
              O = new eg(D, b, S, u);
            (O.type = Xn), (O.needsUpdate = !0);
            const x = _ * 4;
            for (let I = 0; I < u; I++) {
              const H = f[I],
                N = E[I],
                Y = T[I],
                q = b * S * 4 * I;
              for (let V = 0; V < H.count; V++) {
                const J = V * x;
                m === !0 && (s.fromBufferAttribute(H, V), (D[q + J + 0] = s.x), (D[q + J + 1] = s.y), (D[q + J + 2] = s.z), (D[q + J + 3] = 0)),
                  g === !0 && (s.fromBufferAttribute(N, V), (D[q + J + 4] = s.x), (D[q + J + 5] = s.y), (D[q + J + 6] = s.z), (D[q + J + 7] = 0)),
                  p === !0 &&
                    (s.fromBufferAttribute(Y, V),
                    (D[q + J + 8] = s.x),
                    (D[q + J + 9] = s.y),
                    (D[q + J + 10] = s.z),
                    (D[q + J + 11] = Y.itemSize === 4 ? s.w : 1));
              }
            }
            (h = { count: u, texture: O, size: new qe(b, S) }), i.set(o, h), o.addEventListener("dispose", w);
          }
          if (A.isInstancedMesh === !0 && A.morphTexture !== null) a.getUniforms().setValue(n, "morphTexture", A.morphTexture, t);
          else {
            let m = 0;
            for (let p = 0; p < c.length; p++) m += c[p];
            const g = o.morphTargetsRelative ? 1 : 1 - m;
            a.getUniforms().setValue(n, "morphTargetBaseInfluence", g), a.getUniforms().setValue(n, "morphTargetInfluences", c);
          }
          a.getUniforms().setValue(n, "morphTargetsTexture", h.texture, t), a.getUniforms().setValue(n, "morphTargetsTextureSize", h.size);
        }
        return { update: r };
      }
      function C_(n, e, t, i) {
        let s = new WeakMap();
        function r(a) {
          const c = i.render.frame,
            l = a.geometry,
            u = e.get(a, l);
          if (
            (s.get(u) !== c && (e.update(u), s.set(u, c)),
            a.isInstancedMesh &&
              (a.hasEventListener("dispose", o) === !1 && a.addEventListener("dispose", o),
              s.get(a) !== c &&
                (t.update(a.instanceMatrix, n.ARRAY_BUFFER), a.instanceColor !== null && t.update(a.instanceColor, n.ARRAY_BUFFER), s.set(a, c))),
            a.isSkinnedMesh)
          ) {
            const h = a.skeleton;
            s.get(h) !== c && (h.update(), s.set(h, c));
          }
          return u;
        }
        function A() {
          s = new WeakMap();
        }
        function o(a) {
          const c = a.target;
          c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
        }
        return { update: r, dispose: A };
      }
      const Pg = new Kt(),
        wd = new hg(1, 1),
        vg = new eg(),
        wg = new wv(),
        _g = new og(),
        _d = [],
        xd = [],
        yd = new Float32Array(16),
        Td = new Float32Array(9),
        Ed = new Float32Array(4);
      function Kr(n, e, t) {
        const i = n[0];
        if (i <= 0 || i > 0) return n;
        const s = e * t;
        let r = _d[s];
        if ((r === void 0 && ((r = new Float32Array(s)), (_d[s] = r)), e !== 0)) {
          i.toArray(r, 0);
          for (let A = 1, o = 0; A !== e; ++A) (o += t), n[A].toArray(r, o);
        }
        return r;
      }
      function jt(n, e) {
        if (n.length !== e.length) return !1;
        for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
        return !0;
      }
      function Ht(n, e) {
        for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
      }
      function ya(n, e) {
        let t = xd[e];
        t === void 0 && ((t = new Int32Array(e)), (xd[e] = t));
        for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
        return t;
      }
      function S_(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
      }
      function I_(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (jt(t, e)) return;
          n.uniform2fv(this.addr, e), Ht(t, e);
        }
      }
      function b_(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
        else if (e.r !== void 0)
          (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), (t[0] = e.r), (t[1] = e.g), (t[2] = e.b));
        else {
          if (jt(t, e)) return;
          n.uniform3fv(this.addr, e), Ht(t, e);
        }
      }
      function z_(n, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z), (t[3] = e.w));
        else {
          if (jt(t, e)) return;
          n.uniform4fv(this.addr, e), Ht(t, e);
        }
      }
      function R_(n, e) {
        const t = this.cache,
          i = e.elements;
        if (i === void 0) {
          if (jt(t, e)) return;
          n.uniformMatrix2fv(this.addr, !1, e), Ht(t, e);
        } else {
          if (jt(t, i)) return;
          Ed.set(i), n.uniformMatrix2fv(this.addr, !1, Ed), Ht(t, i);
        }
      }
      function B_(n, e) {
        const t = this.cache,
          i = e.elements;
        if (i === void 0) {
          if (jt(t, e)) return;
          n.uniformMatrix3fv(this.addr, !1, e), Ht(t, e);
        } else {
          if (jt(t, i)) return;
          Td.set(i), n.uniformMatrix3fv(this.addr, !1, Td), Ht(t, i);
        }
      }
      function O_(n, e) {
        const t = this.cache,
          i = e.elements;
        if (i === void 0) {
          if (jt(t, e)) return;
          n.uniformMatrix4fv(this.addr, !1, e), Ht(t, e);
        } else {
          if (jt(t, i)) return;
          yd.set(i), n.uniformMatrix4fv(this.addr, !1, yd), Ht(t, i);
        }
      }
      function L_(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
      }
      function U_(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (jt(t, e)) return;
          n.uniform2iv(this.addr, e), Ht(t, e);
        }
      }
      function F_(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
        else {
          if (jt(t, e)) return;
          n.uniform3iv(this.addr, e), Ht(t, e);
        }
      }
      function N_(n, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z), (t[3] = e.w));
        else {
          if (jt(t, e)) return;
          n.uniform4iv(this.addr, e), Ht(t, e);
        }
      }
      function k_(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
      }
      function G_(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (jt(t, e)) return;
          n.uniform2uiv(this.addr, e), Ht(t, e);
        }
      }
      function j_(n, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
        else {
          if (jt(t, e)) return;
          n.uniform3uiv(this.addr, e), Ht(t, e);
        }
      }
      function H_(n, e) {
        const t = this.cache;
        if (e.x !== void 0)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z), (t[3] = e.w));
        else {
          if (jt(t, e)) return;
          n.uniform4uiv(this.addr, e), Ht(t, e);
        }
      }
      function Q_(n, e, t) {
        const i = this.cache,
          s = t.allocateTextureUnit();
        i[0] !== s && (n.uniform1i(this.addr, s), (i[0] = s));
        let r;
        this.type === n.SAMPLER_2D_SHADOW ? ((wd.compareFunction = Zm), (r = wd)) : (r = Pg), t.setTexture2D(e || r, s);
      }
      function V_(n, e, t) {
        const i = this.cache,
          s = t.allocateTextureUnit();
        i[0] !== s && (n.uniform1i(this.addr, s), (i[0] = s)), t.setTexture3D(e || wg, s);
      }
      function W_(n, e, t) {
        const i = this.cache,
          s = t.allocateTextureUnit();
        i[0] !== s && (n.uniform1i(this.addr, s), (i[0] = s)), t.setTextureCube(e || _g, s);
      }
      function K_(n, e, t) {
        const i = this.cache,
          s = t.allocateTextureUnit();
        i[0] !== s && (n.uniform1i(this.addr, s), (i[0] = s)), t.setTexture2DArray(e || vg, s);
      }
      function Y_(n) {
        switch (n) {
          case 5126:
            return S_;
          case 35664:
            return I_;
          case 35665:
            return b_;
          case 35666:
            return z_;
          case 35674:
            return R_;
          case 35675:
            return B_;
          case 35676:
            return O_;
          case 5124:
          case 35670:
            return L_;
          case 35667:
          case 35671:
            return U_;
          case 35668:
          case 35672:
            return F_;
          case 35669:
          case 35673:
            return N_;
          case 5125:
            return k_;
          case 36294:
            return G_;
          case 36295:
            return j_;
          case 36296:
            return H_;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Q_;
          case 35679:
          case 36299:
          case 36307:
            return V_;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return W_;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return K_;
        }
      }
      function q_(n, e) {
        n.uniform1fv(this.addr, e);
      }
      function X_(n, e) {
        const t = Kr(e, this.size, 2);
        n.uniform2fv(this.addr, t);
      }
      function J_(n, e) {
        const t = Kr(e, this.size, 3);
        n.uniform3fv(this.addr, t);
      }
      function Z_(n, e) {
        const t = Kr(e, this.size, 4);
        n.uniform4fv(this.addr, t);
      }
      function $_(n, e) {
        const t = Kr(e, this.size, 4);
        n.uniformMatrix2fv(this.addr, !1, t);
      }
      function ex(n, e) {
        const t = Kr(e, this.size, 9);
        n.uniformMatrix3fv(this.addr, !1, t);
      }
      function tx(n, e) {
        const t = Kr(e, this.size, 16);
        n.uniformMatrix4fv(this.addr, !1, t);
      }
      function nx(n, e) {
        n.uniform1iv(this.addr, e);
      }
      function ix(n, e) {
        n.uniform2iv(this.addr, e);
      }
      function sx(n, e) {
        n.uniform3iv(this.addr, e);
      }
      function rx(n, e) {
        n.uniform4iv(this.addr, e);
      }
      function Ax(n, e) {
        n.uniform1uiv(this.addr, e);
      }
      function ox(n, e) {
        n.uniform2uiv(this.addr, e);
      }
      function ax(n, e) {
        n.uniform3uiv(this.addr, e);
      }
      function cx(n, e) {
        n.uniform4uiv(this.addr, e);
      }
      function lx(n, e, t) {
        const i = this.cache,
          s = e.length,
          r = ya(t, s);
        jt(i, r) || (n.uniform1iv(this.addr, r), Ht(i, r));
        for (let A = 0; A !== s; ++A) t.setTexture2D(e[A] || Pg, r[A]);
      }
      function ux(n, e, t) {
        const i = this.cache,
          s = e.length,
          r = ya(t, s);
        jt(i, r) || (n.uniform1iv(this.addr, r), Ht(i, r));
        for (let A = 0; A !== s; ++A) t.setTexture3D(e[A] || wg, r[A]);
      }
      function hx(n, e, t) {
        const i = this.cache,
          s = e.length,
          r = ya(t, s);
        jt(i, r) || (n.uniform1iv(this.addr, r), Ht(i, r));
        for (let A = 0; A !== s; ++A) t.setTextureCube(e[A] || _g, r[A]);
      }
      function fx(n, e, t) {
        const i = this.cache,
          s = e.length,
          r = ya(t, s);
        jt(i, r) || (n.uniform1iv(this.addr, r), Ht(i, r));
        for (let A = 0; A !== s; ++A) t.setTexture2DArray(e[A] || vg, r[A]);
      }
      function dx(n) {
        switch (n) {
          case 5126:
            return q_;
          case 35664:
            return X_;
          case 35665:
            return J_;
          case 35666:
            return Z_;
          case 35674:
            return $_;
          case 35675:
            return ex;
          case 35676:
            return tx;
          case 5124:
          case 35670:
            return nx;
          case 35667:
          case 35671:
            return ix;
          case 35668:
          case 35672:
            return sx;
          case 35669:
          case 35673:
            return rx;
          case 5125:
            return Ax;
          case 36294:
            return ox;
          case 36295:
            return ax;
          case 36296:
            return cx;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return lx;
          case 35679:
          case 36299:
          case 36307:
            return ux;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return hx;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return fx;
        }
      }
      class px {
        constructor(e, t, i) {
          (this.id = e), (this.addr = i), (this.cache = []), (this.type = t.type), (this.setValue = Y_(t.type));
        }
      }
      class mx {
        constructor(e, t, i) {
          (this.id = e), (this.addr = i), (this.cache = []), (this.type = t.type), (this.size = t.size), (this.setValue = dx(t.type));
        }
      }
      class gx {
        constructor(e) {
          (this.id = e), (this.seq = []), (this.map = {});
        }
        setValue(e, t, i) {
          const s = this.seq;
          for (let r = 0, A = s.length; r !== A; ++r) {
            const o = s[r];
            o.setValue(e, t[o.id], i);
          }
        }
      }
      const vc = /(\w+)(\])?(\[|\.)?/g;
      function Dd(n, e) {
        n.seq.push(e), (n.map[e.id] = e);
      }
      function Px(n, e, t) {
        const i = n.name,
          s = i.length;
        for (vc.lastIndex = 0; ; ) {
          const r = vc.exec(i),
            A = vc.lastIndex;
          let o = r[1];
          const a = r[2] === "]",
            c = r[3];
          if ((a && (o = o | 0), c === void 0 || (c === "[" && A + 2 === s))) {
            Dd(t, c === void 0 ? new px(o, n, e) : new mx(o, n, e));
            break;
          } else {
            let u = t.map[o];
            u === void 0 && ((u = new gx(o)), Dd(t, u)), (t = u);
          }
        }
      }
      class Co {
        constructor(e, t) {
          (this.seq = []), (this.map = {});
          const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
          for (let s = 0; s < i; ++s) {
            const r = e.getActiveUniform(t, s),
              A = e.getUniformLocation(t, r.name);
            Px(r, A, this);
          }
        }
        setValue(e, t, i, s) {
          const r = this.map[t];
          r !== void 0 && r.setValue(e, i, s);
        }
        setOptional(e, t, i) {
          const s = t[i];
          s !== void 0 && this.setValue(e, i, s);
        }
        static upload(e, t, i, s) {
          for (let r = 0, A = t.length; r !== A; ++r) {
            const o = t[r],
              a = i[o.id];
            a.needsUpdate !== !1 && o.setValue(e, a.value, s);
          }
        }
        static seqWithValue(e, t) {
          const i = [];
          for (let s = 0, r = e.length; s !== r; ++s) {
            const A = e[s];
            A.id in t && i.push(A);
          }
          return i;
        }
      }
      function Md(n, e, t) {
        const i = n.createShader(e);
        return n.shaderSource(i, t), n.compileShader(i), i;
      }
      const vx = 37297;
      let wx = 0;
      function _x(n, e) {
        const t = n.split(`
`),
          i = [],
          s = Math.max(e - 6, 0),
          r = Math.min(e + 6, t.length);
        for (let A = s; A < r; A++) {
          const o = A + 1;
          i.push(`${o === e ? ">" : " "} ${o}: ${t[A]}`);
        }
        return i.join(`
`);
      }
      const Cd = new Ne();
      function xx(n) {
        Xe._getMatrix(Cd, Xe.workingColorSpace, n);
        const e = `mat3( ${Cd.elements.map((t) => t.toFixed(4))} )`;
        switch (Xe.getTransfer(n)) {
          case Fo:
            return [e, "LinearTransferOETF"];
          case ut:
            return [e, "sRGBTransferOETF"];
          default:
            return console.warn("THREE.WebGLProgram: Unsupported color space: ", n), [e, "LinearTransferOETF"];
        }
      }
      function Sd(n, e, t) {
        const i = n.getShaderParameter(e, n.COMPILE_STATUS),
          s = n.getShaderInfoLog(e).trim();
        if (i && s === "") return "";
        const r = /ERROR: 0:(\d+)/.exec(s);
        if (r) {
          const A = parseInt(r[1]);
          return (
            t.toUpperCase() +
            `

` +
            s +
            `

` +
            _x(n.getShaderSource(e), A)
          );
        } else return s;
      }
      function yx(n, e) {
        const t = xx(e);
        return [`vec4 ${n}( vec4 value ) {`, `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`, "}"].join(`
`);
      }
      function Tx(n, e) {
        let t;
        switch (e) {
          case C0:
            t = "Linear";
            break;
          case S0:
            t = "Reinhard";
            break;
          case I0:
            t = "Cineon";
            break;
          case b0:
            t = "ACESFilmic";
            break;
          case R0:
            t = "AgX";
            break;
          case B0:
            t = "Neutral";
            break;
          case z0:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), (t = "Linear");
        }
        return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
      }
      const mo = new R();
      function Ex() {
        Xe.getLuminanceCoefficients(mo);
        const n = mo.x.toFixed(4),
          e = mo.y.toFixed(4),
          t = mo.z.toFixed(4);
        return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`);
      }
      function Dx(n) {
        return [
          n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
          n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
        ].filter(cA).join(`
`);
      }
      function Mx(n) {
        const e = [];
        for (const t in n) {
          const i = n[t];
          i !== !1 && e.push("#define " + t + " " + i);
        }
        return e.join(`
`);
      }
      function Cx(n, e) {
        const t = {},
          i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
        for (let s = 0; s < i; s++) {
          const r = n.getActiveAttrib(e, s),
            A = r.name;
          let o = 1;
          r.type === n.FLOAT_MAT2 && (o = 2),
            r.type === n.FLOAT_MAT3 && (o = 3),
            r.type === n.FLOAT_MAT4 && (o = 4),
            (t[A] = { type: r.type, location: n.getAttribLocation(e, A), locationSize: o });
        }
        return t;
      }
      function cA(n) {
        return n !== "";
      }
      function Id(n, e) {
        const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
        return n
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
          .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function bd(n, e) {
        return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
      }
      const Sx = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function zl(n) {
        return n.replace(Sx, bx);
      }
      const Ix = new Map();
      function bx(n, e) {
        let t = je[e];
        if (t === void 0) {
          const i = Ix.get(e);
          if (i !== void 0) (t = je[i]), console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
          else throw new Error("Can not resolve #include <" + e + ">");
        }
        return zl(t);
      }
      const zx = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function zd(n) {
        return n.replace(zx, Rx);
      }
      function Rx(n, e, t, i) {
        let s = "";
        for (let r = parseInt(e); r < parseInt(t); r++) s += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
        return s;
      }
      function Rd(n) {
        let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
        return (
          n.precision === "highp"
            ? (e += `
#define HIGH_PRECISION`)
            : n.precision === "mediump"
            ? (e += `
#define MEDIUM_PRECISION`)
            : n.precision === "lowp" &&
              (e += `
#define LOW_PRECISION`),
          e
        );
      }
      function Bx(n) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          n.shadowMapType === Nm
            ? (e = "SHADOWMAP_TYPE_PCF")
            : n.shadowMapType === o0
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : n.shadowMapType === Ei && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      }
      function Ox(n) {
        let e = "ENVMAP_TYPE_CUBE";
        if (n.envMap)
          switch (n.envMapMode) {
            case Dr:
            case Mr:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case va:
              e = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        return e;
      }
      function Lx(n) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (n.envMap)
          switch (n.envMapMode) {
            case Mr:
              e = "ENVMAP_MODE_REFRACTION";
              break;
          }
        return e;
      }
      function Ux(n) {
        let e = "ENVMAP_BLENDING_NONE";
        if (n.envMap)
          switch (n.combine) {
            case km:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case D0:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case M0:
              e = "ENVMAP_BLENDING_ADD";
              break;
          }
        return e;
      }
      function Fx(n) {
        const e = n.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e) - 2,
          i = 1 / e;
        return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
      }
      function Nx(n, e, t, i) {
        const s = n.getContext(),
          r = t.defines;
        let A = t.vertexShader,
          o = t.fragmentShader;
        const a = Bx(t),
          c = Ox(t),
          l = Lx(t),
          u = Ux(t),
          h = Fx(t),
          d = Dx(t),
          m = Mx(r),
          g = s.createProgram();
        let p,
          f,
          E = t.glslVersion
            ? "#version " +
              t.glslVersion +
              `
`
            : "";
        t.isRawShaderMaterial
          ? ((p = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m].filter(cA).join(`
`)),
            p.length > 0 &&
              (p += `
`),
            (f = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, m].filter(cA).join(`
`)),
            f.length > 0 &&
              (f += `
`))
          : ((p = [
              Rd(t),
              "#define SHADER_TYPE " + t.shaderType,
              "#define SHADER_NAME " + t.shaderName,
              m,
              t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
              t.batching ? "#define USE_BATCHING" : "",
              t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
              t.instancing ? "#define USE_INSTANCING" : "",
              t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + l : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
              t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.anisotropy ? "#define USE_ANISOTROPY" : "",
              t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.alphaHash ? "#define USE_ALPHAHASH" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              t.mapUv ? "#define MAP_UV " + t.mapUv : "",
              t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
              t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
              t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
              t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
              t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
              t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
              t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
              t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
              t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
              t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
              t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
              t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
              t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
              t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
              t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
              t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
              t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
              t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
              t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
              t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
              t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
              t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
              t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
              t.vertexColors ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUv1s ? "#define USE_UV1" : "",
              t.vertexUv2s ? "#define USE_UV2" : "",
              t.vertexUv3s ? "#define USE_UV3" : "",
              t.pointsUvs ? "#define USE_POINTS_UV" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.skinning ? "#define USE_SKINNING" : "",
              t.morphTargets ? "#define USE_MORPHTARGETS" : "",
              t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
              t.morphColors ? "#define USE_MORPHCOLORS" : "",
              t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
              t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + a : "",
              t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "#ifdef USE_INSTANCING_MORPH",
              "	uniform sampler2D morphTexture;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_UV1",
              "	attribute vec2 uv1;",
              "#endif",
              "#ifdef USE_UV2",
              "	attribute vec2 uv2;",
              "#endif",
              "#ifdef USE_UV3",
              "	attribute vec2 uv3;",
              "#endif",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
            ].filter(cA).join(`
`)),
            (f = [
              Rd(t),
              "#define SHADER_TYPE " + t.shaderType,
              "#define SHADER_NAME " + t.shaderName,
              m,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
              t.map ? "#define USE_MAP" : "",
              t.matcap ? "#define USE_MATCAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + c : "",
              t.envMap ? "#define " + l : "",
              t.envMap ? "#define " + u : "",
              h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
              h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
              h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.anisotropy ? "#define USE_ANISOTROPY" : "",
              t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              t.clearcoat ? "#define USE_CLEARCOAT" : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.dispersion ? "#define USE_DISPERSION" : "",
              t.iridescence ? "#define USE_IRIDESCENCE" : "",
              t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.alphaTest ? "#define USE_ALPHATEST" : "",
              t.alphaHash ? "#define USE_ALPHAHASH" : "",
              t.sheen ? "#define USE_SHEEN" : "",
              t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
              t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUv1s ? "#define USE_UV1" : "",
              t.vertexUv2s ? "#define USE_UV2" : "",
              t.vertexUv3s ? "#define USE_UV3" : "",
              t.pointsUvs ? "#define USE_POINTS_UV" : "",
              t.gradientMap ? "#define USE_GRADIENTMAP" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + a : "",
              t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              t.toneMapping !== As ? "#define TONE_MAPPING" : "",
              t.toneMapping !== As ? je.tonemapping_pars_fragment : "",
              t.toneMapping !== As ? Tx("toneMapping", t.toneMapping) : "",
              t.dithering ? "#define DITHERING" : "",
              t.opaque ? "#define OPAQUE" : "",
              je.colorspace_pars_fragment,
              yx("linearToOutputTexel", t.outputColorSpace),
              Ex(),
              t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
              `
`,
            ].filter(cA).join(`
`))),
          (A = zl(A)),
          (A = Id(A, t)),
          (A = bd(A, t)),
          (o = zl(o)),
          (o = Id(o, t)),
          (o = bd(o, t)),
          (A = zd(A)),
          (o = zd(o)),
          t.isRawShaderMaterial !== !0 &&
            ((E = `#version 300 es
`),
            (p =
              [d, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) +
              `
` +
              p),
            (f =
              [
                "#define varying in",
                t.glslVersion === Sf ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
                t.glslVersion === Sf ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join(`
`) +
              `
` +
              f));
        const T = E + p + A,
          _ = E + f + o,
          b = Md(s, s.VERTEX_SHADER, T),
          S = Md(s, s.FRAGMENT_SHADER, _);
        s.attachShader(g, b),
          s.attachShader(g, S),
          t.index0AttributeName !== void 0
            ? s.bindAttribLocation(g, 0, t.index0AttributeName)
            : t.morphTargets === !0 && s.bindAttribLocation(g, 0, "position"),
          s.linkProgram(g);
        function D(I) {
          if (n.debug.checkShaderErrors) {
            const H = s.getProgramInfoLog(g).trim(),
              N = s.getShaderInfoLog(b).trim(),
              Y = s.getShaderInfoLog(S).trim();
            let q = !0,
              V = !0;
            if (s.getProgramParameter(g, s.LINK_STATUS) === !1)
              if (((q = !1), typeof n.debug.onShaderError == "function")) n.debug.onShaderError(s, g, b, S);
              else {
                const J = Sd(s, b, "vertex"),
                  k = Sd(s, S, "fragment");
                console.error(
                  "THREE.WebGLProgram: Shader Error " +
                    s.getError() +
                    " - VALIDATE_STATUS " +
                    s.getProgramParameter(g, s.VALIDATE_STATUS) +
                    `

Material Name: ` +
                    I.name +
                    `
Material Type: ` +
                    I.type +
                    `

Program Info Log: ` +
                    H +
                    `
` +
                    J +
                    `
` +
                    k
                );
              }
            else H !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", H) : (N === "" || Y === "") && (V = !1);
            V && (I.diagnostics = { runnable: q, programLog: H, vertexShader: { log: N, prefix: p }, fragmentShader: { log: Y, prefix: f } });
          }
          s.deleteShader(b), s.deleteShader(S), (O = new Co(s, g)), (x = Cx(s, g));
        }
        let O;
        this.getUniforms = function () {
          return O === void 0 && D(this), O;
        };
        let x;
        this.getAttributes = function () {
          return x === void 0 && D(this), x;
        };
        let w = t.rendererExtensionParallelShaderCompile === !1;
        return (
          (this.isReady = function () {
            return w === !1 && (w = s.getProgramParameter(g, vx)), w;
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this), s.deleteProgram(g), (this.program = void 0);
          }),
          (this.type = t.shaderType),
          (this.name = t.shaderName),
          (this.id = wx++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = g),
          (this.vertexShader = b),
          (this.fragmentShader = S),
          this
        );
      }
      let kx = 0;
      class Gx {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(e) {
          const t = e.vertexShader,
            i = e.fragmentShader,
            s = this._getShaderStage(t),
            r = this._getShaderStage(i),
            A = this._getShaderCacheForMaterial(e);
          return A.has(s) === !1 && (A.add(s), s.usedTimes++), A.has(r) === !1 && (A.add(r), r.usedTimes++), this;
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          let i = t.get(e);
          return i === void 0 && ((i = new Set()), t.set(e, i)), i;
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          let i = t.get(e);
          return i === void 0 && ((i = new jx(e)), t.set(e, i)), i;
        }
      }
      class jx {
        constructor(e) {
          (this.id = kx++), (this.code = e), (this.usedTimes = 0);
        }
      }
      function Hx(n, e, t, i, s, r, A) {
        const o = new tg(),
          a = new Gx(),
          c = new Set(),
          l = [],
          u = s.logarithmicDepthBuffer,
          h = s.vertexTextures;
        let d = s.precision;
        const m = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function g(x) {
          return c.add(x), x === 0 ? "uv" : `uv${x}`;
        }
        function p(x, w, I, H, N) {
          const Y = H.fog,
            q = N.geometry,
            V = x.isMeshStandardMaterial ? H.environment : null,
            J = (x.isMeshStandardMaterial ? t : e).get(x.envMap || V),
            k = J && J.mapping === va ? J.image.height : null,
            oe = m[x.type];
          x.precision !== null &&
            ((d = s.getMaxPrecision(x.precision)),
            d !== x.precision && console.warn("THREE.WebGLProgram.getParameters:", x.precision, "not supported, using", d, "instead."));
          const he = q.morphAttributes.position || q.morphAttributes.normal || q.morphAttributes.color,
            Me = he !== void 0 ? he.length : 0;
          let He = 0;
          q.morphAttributes.position !== void 0 && (He = 1), q.morphAttributes.normal !== void 0 && (He = 2), q.morphAttributes.color !== void 0 && (He = 3);
          let ht, Q, te, Te;
          if (oe) {
            const ot = oi[oe];
            (ht = ot.vertexShader), (Q = ot.fragmentShader);
          } else (ht = x.vertexShader), (Q = x.fragmentShader), a.update(x), (te = a.getVertexShaderID(x)), (Te = a.getFragmentShaderID(x));
          const ae = n.getRenderTarget(),
            Ee = n.state.buffers.depth.getReversed(),
            tt = N.isInstancedMesh === !0,
            Re = N.isBatchedMesh === !0,
            Et = !!x.map,
            Dt = !!x.matcap,
            nt = !!J,
            M = !!x.aoMap,
            Zt = !!x.lightMap,
            it = !!x.bumpMap,
            pt = !!x.normalMap,
            ve = !!x.displacementMap,
            Ze = !!x.emissiveMap,
            Se = !!x.metalnessMap,
            Ge = !!x.roughnessMap,
            kt = x.anisotropy > 0,
            y = x.clearcoat > 0,
            P = x.dispersion > 0,
            L = x.iridescence > 0,
            j = x.sheen > 0,
            K = x.transmission > 0,
            G = kt && !!x.anisotropyMap,
            xe = y && !!x.clearcoatMap,
            se = y && !!x.clearcoatNormalMap,
            ge = y && !!x.clearcoatRoughnessMap,
            ye = L && !!x.iridescenceMap,
            X = L && !!x.iridescenceThicknessMap,
            le = j && !!x.sheenColorMap,
            ze = j && !!x.sheenRoughnessMap,
            be = !!x.specularMap,
            ne = !!x.specularColorMap,
            Le = !!x.specularIntensityMap,
            C = K && !!x.transmissionMap,
            re = K && !!x.thicknessMap,
            Z = !!x.gradientMap,
            fe = !!x.alphaMap,
            $ = x.alphaTest > 0,
            W = !!x.alphaHash,
            de = !!x.extensions;
          let Fe = As;
          x.toneMapped && (ae === null || ae.isXRRenderTarget === !0) && (Fe = n.toneMapping);
          const Pt = {
            shaderID: oe,
            shaderType: x.type,
            shaderName: x.name,
            vertexShader: ht,
            fragmentShader: Q,
            defines: x.defines,
            customVertexShaderID: te,
            customFragmentShaderID: Te,
            isRawShaderMaterial: x.isRawShaderMaterial === !0,
            glslVersion: x.glslVersion,
            precision: d,
            batching: Re,
            batchingColor: Re && N._colorsTexture !== null,
            instancing: tt,
            instancingColor: tt && N.instanceColor !== null,
            instancingMorph: tt && N.morphTexture !== null,
            supportsVertexTextures: h,
            outputColorSpace: ae === null ? n.outputColorSpace : ae.isXRRenderTarget === !0 ? ae.texture.colorSpace : on,
            alphaToCoverage: !!x.alphaToCoverage,
            map: Et,
            matcap: Dt,
            envMap: nt,
            envMapMode: nt && J.mapping,
            envMapCubeUVHeight: k,
            aoMap: M,
            lightMap: Zt,
            bumpMap: it,
            normalMap: pt,
            displacementMap: h && ve,
            emissiveMap: Ze,
            normalMapObjectSpace: pt && x.normalMapType === k0,
            normalMapTangentSpace: pt && x.normalMapType === Jm,
            metalnessMap: Se,
            roughnessMap: Ge,
            anisotropy: kt,
            anisotropyMap: G,
            clearcoat: y,
            clearcoatMap: xe,
            clearcoatNormalMap: se,
            clearcoatRoughnessMap: ge,
            dispersion: P,
            iridescence: L,
            iridescenceMap: ye,
            iridescenceThicknessMap: X,
            sheen: j,
            sheenColorMap: le,
            sheenRoughnessMap: ze,
            specularMap: be,
            specularColorMap: ne,
            specularIntensityMap: Le,
            transmission: K,
            transmissionMap: C,
            thicknessMap: re,
            gradientMap: Z,
            opaque: x.transparent === !1 && x.blending === lr && x.alphaToCoverage === !1,
            alphaMap: fe,
            alphaTest: $,
            alphaHash: W,
            combine: x.combine,
            mapUv: Et && g(x.map.channel),
            aoMapUv: M && g(x.aoMap.channel),
            lightMapUv: Zt && g(x.lightMap.channel),
            bumpMapUv: it && g(x.bumpMap.channel),
            normalMapUv: pt && g(x.normalMap.channel),
            displacementMapUv: ve && g(x.displacementMap.channel),
            emissiveMapUv: Ze && g(x.emissiveMap.channel),
            metalnessMapUv: Se && g(x.metalnessMap.channel),
            roughnessMapUv: Ge && g(x.roughnessMap.channel),
            anisotropyMapUv: G && g(x.anisotropyMap.channel),
            clearcoatMapUv: xe && g(x.clearcoatMap.channel),
            clearcoatNormalMapUv: se && g(x.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: ge && g(x.clearcoatRoughnessMap.channel),
            iridescenceMapUv: ye && g(x.iridescenceMap.channel),
            iridescenceThicknessMapUv: X && g(x.iridescenceThicknessMap.channel),
            sheenColorMapUv: le && g(x.sheenColorMap.channel),
            sheenRoughnessMapUv: ze && g(x.sheenRoughnessMap.channel),
            specularMapUv: be && g(x.specularMap.channel),
            specularColorMapUv: ne && g(x.specularColorMap.channel),
            specularIntensityMapUv: Le && g(x.specularIntensityMap.channel),
            transmissionMapUv: C && g(x.transmissionMap.channel),
            thicknessMapUv: re && g(x.thicknessMap.channel),
            alphaMapUv: fe && g(x.alphaMap.channel),
            vertexTangents: !!q.attributes.tangent && (pt || kt),
            vertexColors: x.vertexColors,
            vertexAlphas: x.vertexColors === !0 && !!q.attributes.color && q.attributes.color.itemSize === 4,
            pointsUvs: N.isPoints === !0 && !!q.attributes.uv && (Et || fe),
            fog: !!Y,
            useFog: x.fog === !0,
            fogExp2: !!Y && Y.isFogExp2,
            flatShading: x.flatShading === !0 && x.wireframe === !1,
            sizeAttenuation: x.sizeAttenuation === !0,
            logarithmicDepthBuffer: u,
            reverseDepthBuffer: Ee,
            skinning: N.isSkinnedMesh === !0,
            morphTargets: q.morphAttributes.position !== void 0,
            morphNormals: q.morphAttributes.normal !== void 0,
            morphColors: q.morphAttributes.color !== void 0,
            morphTargetsCount: Me,
            morphTextureStride: He,
            numDirLights: w.directional.length,
            numPointLights: w.point.length,
            numSpotLights: w.spot.length,
            numSpotLightMaps: w.spotLightMap.length,
            numRectAreaLights: w.rectArea.length,
            numHemiLights: w.hemi.length,
            numDirLightShadows: w.directionalShadowMap.length,
            numPointLightShadows: w.pointShadowMap.length,
            numSpotLightShadows: w.spotShadowMap.length,
            numSpotLightShadowsWithMaps: w.numSpotLightShadowsWithMaps,
            numLightProbes: w.numLightProbes,
            numClippingPlanes: A.numPlanes,
            numClipIntersection: A.numIntersection,
            dithering: x.dithering,
            shadowMapEnabled: n.shadowMap.enabled && I.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: Fe,
            decodeVideoTexture: Et && x.map.isVideoTexture === !0 && Xe.getTransfer(x.map.colorSpace) === ut,
            decodeVideoTextureEmissive: Ze && x.emissiveMap.isVideoTexture === !0 && Xe.getTransfer(x.emissiveMap.colorSpace) === ut,
            premultipliedAlpha: x.premultipliedAlpha,
            doubleSided: x.side === ai,
            flipSided: x.side === fn,
            useDepthPacking: x.depthPacking >= 0,
            depthPacking: x.depthPacking || 0,
            index0AttributeName: x.index0AttributeName,
            extensionClipCullDistance: de && x.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: ((de && x.extensions.multiDraw === !0) || Re) && i.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: x.customProgramCacheKey(),
          };
          return (Pt.vertexUv1s = c.has(1)), (Pt.vertexUv2s = c.has(2)), (Pt.vertexUv3s = c.has(3)), c.clear(), Pt;
        }
        function f(x) {
          const w = [];
          if ((x.shaderID ? w.push(x.shaderID) : (w.push(x.customVertexShaderID), w.push(x.customFragmentShaderID)), x.defines !== void 0))
            for (const I in x.defines) w.push(I), w.push(x.defines[I]);
          return x.isRawShaderMaterial === !1 && (E(w, x), T(w, x), w.push(n.outputColorSpace)), w.push(x.customProgramCacheKey), w.join();
        }
        function E(x, w) {
          x.push(w.precision),
            x.push(w.outputColorSpace),
            x.push(w.envMapMode),
            x.push(w.envMapCubeUVHeight),
            x.push(w.mapUv),
            x.push(w.alphaMapUv),
            x.push(w.lightMapUv),
            x.push(w.aoMapUv),
            x.push(w.bumpMapUv),
            x.push(w.normalMapUv),
            x.push(w.displacementMapUv),
            x.push(w.emissiveMapUv),
            x.push(w.metalnessMapUv),
            x.push(w.roughnessMapUv),
            x.push(w.anisotropyMapUv),
            x.push(w.clearcoatMapUv),
            x.push(w.clearcoatNormalMapUv),
            x.push(w.clearcoatRoughnessMapUv),
            x.push(w.iridescenceMapUv),
            x.push(w.iridescenceThicknessMapUv),
            x.push(w.sheenColorMapUv),
            x.push(w.sheenRoughnessMapUv),
            x.push(w.specularMapUv),
            x.push(w.specularColorMapUv),
            x.push(w.specularIntensityMapUv),
            x.push(w.transmissionMapUv),
            x.push(w.thicknessMapUv),
            x.push(w.combine),
            x.push(w.fogExp2),
            x.push(w.sizeAttenuation),
            x.push(w.morphTargetsCount),
            x.push(w.morphAttributeCount),
            x.push(w.numDirLights),
            x.push(w.numPointLights),
            x.push(w.numSpotLights),
            x.push(w.numSpotLightMaps),
            x.push(w.numHemiLights),
            x.push(w.numRectAreaLights),
            x.push(w.numDirLightShadows),
            x.push(w.numPointLightShadows),
            x.push(w.numSpotLightShadows),
            x.push(w.numSpotLightShadowsWithMaps),
            x.push(w.numLightProbes),
            x.push(w.shadowMapType),
            x.push(w.toneMapping),
            x.push(w.numClippingPlanes),
            x.push(w.numClipIntersection),
            x.push(w.depthPacking);
        }
        function T(x, w) {
          o.disableAll(),
            w.supportsVertexTextures && o.enable(0),
            w.instancing && o.enable(1),
            w.instancingColor && o.enable(2),
            w.instancingMorph && o.enable(3),
            w.matcap && o.enable(4),
            w.envMap && o.enable(5),
            w.normalMapObjectSpace && o.enable(6),
            w.normalMapTangentSpace && o.enable(7),
            w.clearcoat && o.enable(8),
            w.iridescence && o.enable(9),
            w.alphaTest && o.enable(10),
            w.vertexColors && o.enable(11),
            w.vertexAlphas && o.enable(12),
            w.vertexUv1s && o.enable(13),
            w.vertexUv2s && o.enable(14),
            w.vertexUv3s && o.enable(15),
            w.vertexTangents && o.enable(16),
            w.anisotropy && o.enable(17),
            w.alphaHash && o.enable(18),
            w.batching && o.enable(19),
            w.dispersion && o.enable(20),
            w.batchingColor && o.enable(21),
            w.gradientMap && o.enable(22),
            x.push(o.mask),
            o.disableAll(),
            w.fog && o.enable(0),
            w.useFog && o.enable(1),
            w.flatShading && o.enable(2),
            w.logarithmicDepthBuffer && o.enable(3),
            w.reverseDepthBuffer && o.enable(4),
            w.skinning && o.enable(5),
            w.morphTargets && o.enable(6),
            w.morphNormals && o.enable(7),
            w.morphColors && o.enable(8),
            w.premultipliedAlpha && o.enable(9),
            w.shadowMapEnabled && o.enable(10),
            w.doubleSided && o.enable(11),
            w.flipSided && o.enable(12),
            w.useDepthPacking && o.enable(13),
            w.dithering && o.enable(14),
            w.transmission && o.enable(15),
            w.sheen && o.enable(16),
            w.opaque && o.enable(17),
            w.pointsUvs && o.enable(18),
            w.decodeVideoTexture && o.enable(19),
            w.decodeVideoTextureEmissive && o.enable(20),
            w.alphaToCoverage && o.enable(21),
            x.push(o.mask);
        }
        function _(x) {
          const w = m[x.type];
          let I;
          if (w) {
            const H = oi[w];
            I = Rv.clone(H.uniforms);
          } else I = x.uniforms;
          return I;
        }
        function b(x, w) {
          let I;
          for (let H = 0, N = l.length; H < N; H++) {
            const Y = l[H];
            if (Y.cacheKey === w) {
              (I = Y), ++I.usedTimes;
              break;
            }
          }
          return I === void 0 && ((I = new Nx(n, w, x, r)), l.push(I)), I;
        }
        function S(x) {
          if (--x.usedTimes === 0) {
            const w = l.indexOf(x);
            (l[w] = l[l.length - 1]), l.pop(), x.destroy();
          }
        }
        function D(x) {
          a.remove(x);
        }
        function O() {
          a.dispose();
        }
        return {
          getParameters: p,
          getProgramCacheKey: f,
          getUniforms: _,
          acquireProgram: b,
          releaseProgram: S,
          releaseShaderCache: D,
          programs: l,
          dispose: O,
        };
      }
      function Qx() {
        let n = new WeakMap();
        function e(A) {
          return n.has(A);
        }
        function t(A) {
          let o = n.get(A);
          return o === void 0 && ((o = {}), n.set(A, o)), o;
        }
        function i(A) {
          n.delete(A);
        }
        function s(A, o, a) {
          n.get(A)[o] = a;
        }
        function r() {
          n = new WeakMap();
        }
        return { has: e, get: t, remove: i, update: s, dispose: r };
      }
      function Vx(n, e) {
        return n.groupOrder !== e.groupOrder
          ? n.groupOrder - e.groupOrder
          : n.renderOrder !== e.renderOrder
          ? n.renderOrder - e.renderOrder
          : n.material.id !== e.material.id
          ? n.material.id - e.material.id
          : n.z !== e.z
          ? n.z - e.z
          : n.id - e.id;
      }
      function Bd(n, e) {
        return n.groupOrder !== e.groupOrder
          ? n.groupOrder - e.groupOrder
          : n.renderOrder !== e.renderOrder
          ? n.renderOrder - e.renderOrder
          : n.z !== e.z
          ? e.z - n.z
          : n.id - e.id;
      }
      function Od() {
        const n = [];
        let e = 0;
        const t = [],
          i = [],
          s = [];
        function r() {
          (e = 0), (t.length = 0), (i.length = 0), (s.length = 0);
        }
        function A(u, h, d, m, g, p) {
          let f = n[e];
          return (
            f === void 0
              ? ((f = { id: u.id, object: u, geometry: h, material: d, groupOrder: m, renderOrder: u.renderOrder, z: g, group: p }), (n[e] = f))
              : ((f.id = u.id),
                (f.object = u),
                (f.geometry = h),
                (f.material = d),
                (f.groupOrder = m),
                (f.renderOrder = u.renderOrder),
                (f.z = g),
                (f.group = p)),
            e++,
            f
          );
        }
        function o(u, h, d, m, g, p) {
          const f = A(u, h, d, m, g, p);
          d.transmission > 0 ? i.push(f) : d.transparent === !0 ? s.push(f) : t.push(f);
        }
        function a(u, h, d, m, g, p) {
          const f = A(u, h, d, m, g, p);
          d.transmission > 0 ? i.unshift(f) : d.transparent === !0 ? s.unshift(f) : t.unshift(f);
        }
        function c(u, h) {
          t.length > 1 && t.sort(u || Vx), i.length > 1 && i.sort(h || Bd), s.length > 1 && s.sort(h || Bd);
        }
        function l() {
          for (let u = e, h = n.length; u < h; u++) {
            const d = n[u];
            if (d.id === null) break;
            (d.id = null), (d.object = null), (d.geometry = null), (d.material = null), (d.group = null);
          }
        }
        return { opaque: t, transmissive: i, transparent: s, init: r, push: o, unshift: a, finish: l, sort: c };
      }
      function Wx() {
        let n = new WeakMap();
        function e(i, s) {
          const r = n.get(i);
          let A;
          return r === void 0 ? ((A = new Od()), n.set(i, [A])) : s >= r.length ? ((A = new Od()), r.push(A)) : (A = r[s]), A;
        }
        function t() {
          n = new WeakMap();
        }
        return { get: e, dispose: t };
      }
      function Kx() {
        const n = {};
        return {
          get: function (e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = { direction: new R(), color: new Ue() };
                break;
              case "SpotLight":
                t = { position: new R(), direction: new R(), color: new Ue(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
                break;
              case "PointLight":
                t = { position: new R(), color: new Ue(), distance: 0, decay: 0 };
                break;
              case "HemisphereLight":
                t = { direction: new R(), skyColor: new Ue(), groundColor: new Ue() };
                break;
              case "RectAreaLight":
                t = { color: new Ue(), position: new R(), halfWidth: new R(), halfHeight: new R() };
                break;
            }
            return (n[e.id] = t), t;
          },
        };
      }
      function Yx() {
        const n = {};
        return {
          get: function (e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new qe() };
                break;
              case "SpotLight":
                t = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new qe() };
                break;
              case "PointLight":
                t = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new qe(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
                break;
            }
            return (n[e.id] = t), t;
          },
        };
      }
      let qx = 0;
      function Xx(n, e) {
        return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0);
      }
      function Jx(n) {
        const e = new Kx(),
          t = Yx(),
          i = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
              numLightProbes: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0,
          };
        for (let c = 0; c < 9; c++) i.probe.push(new R());
        const s = new R(),
          r = new ke(),
          A = new ke();
        function o(c) {
          let l = 0,
            u = 0,
            h = 0;
          for (let x = 0; x < 9; x++) i.probe[x].set(0, 0, 0);
          let d = 0,
            m = 0,
            g = 0,
            p = 0,
            f = 0,
            E = 0,
            T = 0,
            _ = 0,
            b = 0,
            S = 0,
            D = 0;
          c.sort(Xx);
          for (let x = 0, w = c.length; x < w; x++) {
            const I = c[x],
              H = I.color,
              N = I.intensity,
              Y = I.distance,
              q = I.shadow && I.shadow.map ? I.shadow.map.texture : null;
            if (I.isAmbientLight) (l += H.r * N), (u += H.g * N), (h += H.b * N);
            else if (I.isLightProbe) {
              for (let V = 0; V < 9; V++) i.probe[V].addScaledVector(I.sh.coefficients[V], N);
              D++;
            } else if (I.isDirectionalLight) {
              const V = e.get(I);
              if ((V.color.copy(I.color).multiplyScalar(I.intensity), I.castShadow)) {
                const J = I.shadow,
                  k = t.get(I);
                (k.shadowIntensity = J.intensity),
                  (k.shadowBias = J.bias),
                  (k.shadowNormalBias = J.normalBias),
                  (k.shadowRadius = J.radius),
                  (k.shadowMapSize = J.mapSize),
                  (i.directionalShadow[d] = k),
                  (i.directionalShadowMap[d] = q),
                  (i.directionalShadowMatrix[d] = I.shadow.matrix),
                  E++;
              }
              (i.directional[d] = V), d++;
            } else if (I.isSpotLight) {
              const V = e.get(I);
              V.position.setFromMatrixPosition(I.matrixWorld),
                V.color.copy(H).multiplyScalar(N),
                (V.distance = Y),
                (V.coneCos = Math.cos(I.angle)),
                (V.penumbraCos = Math.cos(I.angle * (1 - I.penumbra))),
                (V.decay = I.decay),
                (i.spot[g] = V);
              const J = I.shadow;
              if ((I.map && ((i.spotLightMap[b] = I.map), b++, J.updateMatrices(I), I.castShadow && S++), (i.spotLightMatrix[g] = J.matrix), I.castShadow)) {
                const k = t.get(I);
                (k.shadowIntensity = J.intensity),
                  (k.shadowBias = J.bias),
                  (k.shadowNormalBias = J.normalBias),
                  (k.shadowRadius = J.radius),
                  (k.shadowMapSize = J.mapSize),
                  (i.spotShadow[g] = k),
                  (i.spotShadowMap[g] = q),
                  _++;
              }
              g++;
            } else if (I.isRectAreaLight) {
              const V = e.get(I);
              V.color.copy(H).multiplyScalar(N), V.halfWidth.set(I.width * 0.5, 0, 0), V.halfHeight.set(0, I.height * 0.5, 0), (i.rectArea[p] = V), p++;
            } else if (I.isPointLight) {
              const V = e.get(I);
              if ((V.color.copy(I.color).multiplyScalar(I.intensity), (V.distance = I.distance), (V.decay = I.decay), I.castShadow)) {
                const J = I.shadow,
                  k = t.get(I);
                (k.shadowIntensity = J.intensity),
                  (k.shadowBias = J.bias),
                  (k.shadowNormalBias = J.normalBias),
                  (k.shadowRadius = J.radius),
                  (k.shadowMapSize = J.mapSize),
                  (k.shadowCameraNear = J.camera.near),
                  (k.shadowCameraFar = J.camera.far),
                  (i.pointShadow[m] = k),
                  (i.pointShadowMap[m] = q),
                  (i.pointShadowMatrix[m] = I.shadow.matrix),
                  T++;
              }
              (i.point[m] = V), m++;
            } else if (I.isHemisphereLight) {
              const V = e.get(I);
              V.skyColor.copy(I.color).multiplyScalar(N), V.groundColor.copy(I.groundColor).multiplyScalar(N), (i.hemi[f] = V), f++;
            }
          }
          p > 0 &&
            (n.has("OES_texture_float_linear") === !0
              ? ((i.rectAreaLTC1 = ie.LTC_FLOAT_1), (i.rectAreaLTC2 = ie.LTC_FLOAT_2))
              : ((i.rectAreaLTC1 = ie.LTC_HALF_1), (i.rectAreaLTC2 = ie.LTC_HALF_2))),
            (i.ambient[0] = l),
            (i.ambient[1] = u),
            (i.ambient[2] = h);
          const O = i.hash;
          (O.directionalLength !== d ||
            O.pointLength !== m ||
            O.spotLength !== g ||
            O.rectAreaLength !== p ||
            O.hemiLength !== f ||
            O.numDirectionalShadows !== E ||
            O.numPointShadows !== T ||
            O.numSpotShadows !== _ ||
            O.numSpotMaps !== b ||
            O.numLightProbes !== D) &&
            ((i.directional.length = d),
            (i.spot.length = g),
            (i.rectArea.length = p),
            (i.point.length = m),
            (i.hemi.length = f),
            (i.directionalShadow.length = E),
            (i.directionalShadowMap.length = E),
            (i.pointShadow.length = T),
            (i.pointShadowMap.length = T),
            (i.spotShadow.length = _),
            (i.spotShadowMap.length = _),
            (i.directionalShadowMatrix.length = E),
            (i.pointShadowMatrix.length = T),
            (i.spotLightMatrix.length = _ + b - S),
            (i.spotLightMap.length = b),
            (i.numSpotLightShadowsWithMaps = S),
            (i.numLightProbes = D),
            (O.directionalLength = d),
            (O.pointLength = m),
            (O.spotLength = g),
            (O.rectAreaLength = p),
            (O.hemiLength = f),
            (O.numDirectionalShadows = E),
            (O.numPointShadows = T),
            (O.numSpotShadows = _),
            (O.numSpotMaps = b),
            (O.numLightProbes = D),
            (i.version = qx++));
        }
        function a(c, l) {
          let u = 0,
            h = 0,
            d = 0,
            m = 0,
            g = 0;
          const p = l.matrixWorldInverse;
          for (let f = 0, E = c.length; f < E; f++) {
            const T = c[f];
            if (T.isDirectionalLight) {
              const _ = i.directional[u];
              _.direction.setFromMatrixPosition(T.matrixWorld),
                s.setFromMatrixPosition(T.target.matrixWorld),
                _.direction.sub(s),
                _.direction.transformDirection(p),
                u++;
            } else if (T.isSpotLight) {
              const _ = i.spot[d];
              _.position.setFromMatrixPosition(T.matrixWorld),
                _.position.applyMatrix4(p),
                _.direction.setFromMatrixPosition(T.matrixWorld),
                s.setFromMatrixPosition(T.target.matrixWorld),
                _.direction.sub(s),
                _.direction.transformDirection(p),
                d++;
            } else if (T.isRectAreaLight) {
              const _ = i.rectArea[m];
              _.position.setFromMatrixPosition(T.matrixWorld),
                _.position.applyMatrix4(p),
                A.identity(),
                r.copy(T.matrixWorld),
                r.premultiply(p),
                A.extractRotation(r),
                _.halfWidth.set(T.width * 0.5, 0, 0),
                _.halfHeight.set(0, T.height * 0.5, 0),
                _.halfWidth.applyMatrix4(A),
                _.halfHeight.applyMatrix4(A),
                m++;
            } else if (T.isPointLight) {
              const _ = i.point[h];
              _.position.setFromMatrixPosition(T.matrixWorld), _.position.applyMatrix4(p), h++;
            } else if (T.isHemisphereLight) {
              const _ = i.hemi[g];
              _.direction.setFromMatrixPosition(T.matrixWorld), _.direction.transformDirection(p), g++;
            }
          }
        }
        return { setup: o, setupView: a, state: i };
      }
      function Ld(n) {
        const e = new Jx(n),
          t = [],
          i = [];
        function s(l) {
          (c.camera = l), (t.length = 0), (i.length = 0);
        }
        function r(l) {
          t.push(l);
        }
        function A(l) {
          i.push(l);
        }
        function o() {
          e.setup(t);
        }
        function a(l) {
          e.setupView(t, l);
        }
        const c = { lightsArray: t, shadowsArray: i, camera: null, lights: e, transmissionRenderTarget: {} };
        return { init: s, state: c, setupLights: o, setupLightsView: a, pushLight: r, pushShadow: A };
      }
      function Zx(n) {
        let e = new WeakMap();
        function t(s, r = 0) {
          const A = e.get(s);
          let o;
          return A === void 0 ? ((o = new Ld(n)), e.set(s, [o])) : r >= A.length ? ((o = new Ld(n)), A.push(o)) : (o = A[r]), o;
        }
        function i() {
          e = new WeakMap();
        }
        return { get: t, dispose: i };
      }
      const $x = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
        ey = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function ty(n, e, t) {
        let i = new qu();
        const s = new qe(),
          r = new qe(),
          A = new st(),
          o = new Zv({ depthPacking: N0 }),
          a = new $v(),
          c = {},
          l = t.maxTextureSize,
          u = { [ki]: fn, [fn]: ki, [ai]: ai },
          h = new cs({
            defines: { VSM_SAMPLES: 8 },
            uniforms: { shadow_pass: { value: null }, resolution: { value: new qe() }, radius: { value: 4 } },
            vertexShader: $x,
            fragmentShader: ey,
          }),
          d = h.clone();
        d.defines.HORIZONTAL_PASS = 1;
        const m = new mi();
        m.setAttribute("position", new rn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        const g = new En(m, h),
          p = this;
        (this.enabled = !1), (this.autoUpdate = !0), (this.needsUpdate = !1), (this.type = Nm);
        let f = this.type;
        this.render = function (S, D, O) {
          if (p.enabled === !1 || (p.autoUpdate === !1 && p.needsUpdate === !1) || S.length === 0) return;
          const x = n.getRenderTarget(),
            w = n.getActiveCubeFace(),
            I = n.getActiveMipmapLevel(),
            H = n.state;
          H.setBlending(rs), H.buffers.color.setClear(1, 1, 1, 1), H.buffers.depth.setTest(!0), H.setScissorTest(!1);
          const N = f !== Ei && this.type === Ei,
            Y = f === Ei && this.type !== Ei;
          for (let q = 0, V = S.length; q < V; q++) {
            const J = S[q],
              k = J.shadow;
            if (k === void 0) {
              console.warn("THREE.WebGLShadowMap:", J, "has no shadow.");
              continue;
            }
            if (k.autoUpdate === !1 && k.needsUpdate === !1) continue;
            s.copy(k.mapSize);
            const oe = k.getFrameExtents();
            if (
              (s.multiply(oe),
              r.copy(k.mapSize),
              (s.x > l || s.y > l) &&
                (s.x > l && ((r.x = Math.floor(l / oe.x)), (s.x = r.x * oe.x), (k.mapSize.x = r.x)),
                s.y > l && ((r.y = Math.floor(l / oe.y)), (s.y = r.y * oe.y), (k.mapSize.y = r.y))),
              k.map === null || N === !0 || Y === !0)
            ) {
              const Me = this.type !== Ei ? { minFilter: sn, magFilter: sn } : {};
              k.map !== null && k.map.dispose(),
                (k.map = new Fs(s.x, s.y, Me)),
                (k.map.texture.name = J.name + ".shadowMap"),
                k.camera.updateProjectionMatrix();
            }
            n.setRenderTarget(k.map), n.clear();
            const he = k.getViewportCount();
            for (let Me = 0; Me < he; Me++) {
              const He = k.getViewport(Me);
              A.set(r.x * He.x, r.y * He.y, r.x * He.z, r.y * He.w),
                H.viewport(A),
                k.updateMatrices(J, Me),
                (i = k.getFrustum()),
                _(D, O, k.camera, J, this.type);
            }
            k.isPointLightShadow !== !0 && this.type === Ei && E(k, O), (k.needsUpdate = !1);
          }
          (f = this.type), (p.needsUpdate = !1), n.setRenderTarget(x, w, I);
        };
        function E(S, D) {
          const O = e.update(g);
          h.defines.VSM_SAMPLES !== S.blurSamples &&
            ((h.defines.VSM_SAMPLES = S.blurSamples), (d.defines.VSM_SAMPLES = S.blurSamples), (h.needsUpdate = !0), (d.needsUpdate = !0)),
            S.mapPass === null && (S.mapPass = new Fs(s.x, s.y)),
            (h.uniforms.shadow_pass.value = S.map.texture),
            (h.uniforms.resolution.value = S.mapSize),
            (h.uniforms.radius.value = S.radius),
            n.setRenderTarget(S.mapPass),
            n.clear(),
            n.renderBufferDirect(D, null, O, h, g, null),
            (d.uniforms.shadow_pass.value = S.mapPass.texture),
            (d.uniforms.resolution.value = S.mapSize),
            (d.uniforms.radius.value = S.radius),
            n.setRenderTarget(S.map),
            n.clear(),
            n.renderBufferDirect(D, null, O, d, g, null);
        }
        function T(S, D, O, x) {
          let w = null;
          const I = O.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
          if (I !== void 0) w = I;
          else if (
            ((w = O.isPointLight === !0 ? a : o),
            (n.localClippingEnabled && D.clipShadows === !0 && Array.isArray(D.clippingPlanes) && D.clippingPlanes.length !== 0) ||
              (D.displacementMap && D.displacementScale !== 0) ||
              (D.alphaMap && D.alphaTest > 0) ||
              (D.map && D.alphaTest > 0) ||
              D.alphaToCoverage === !0)
          ) {
            const H = w.uuid,
              N = D.uuid;
            let Y = c[H];
            Y === void 0 && ((Y = {}), (c[H] = Y));
            let q = Y[N];
            q === void 0 && ((q = w.clone()), (Y[N] = q), D.addEventListener("dispose", b)), (w = q);
          }
          if (
            ((w.visible = D.visible),
            (w.wireframe = D.wireframe),
            x === Ei ? (w.side = D.shadowSide !== null ? D.shadowSide : D.side) : (w.side = D.shadowSide !== null ? D.shadowSide : u[D.side]),
            (w.alphaMap = D.alphaMap),
            (w.alphaTest = D.alphaToCoverage === !0 ? 0.5 : D.alphaTest),
            (w.map = D.map),
            (w.clipShadows = D.clipShadows),
            (w.clippingPlanes = D.clippingPlanes),
            (w.clipIntersection = D.clipIntersection),
            (w.displacementMap = D.displacementMap),
            (w.displacementScale = D.displacementScale),
            (w.displacementBias = D.displacementBias),
            (w.wireframeLinewidth = D.wireframeLinewidth),
            (w.linewidth = D.linewidth),
            O.isPointLight === !0 && w.isMeshDistanceMaterial === !0)
          ) {
            const H = n.properties.get(w);
            H.light = O;
          }
          return w;
        }
        function _(S, D, O, x, w) {
          if (S.visible === !1) return;
          if (
            S.layers.test(D.layers) &&
            (S.isMesh || S.isLine || S.isPoints) &&
            (S.castShadow || (S.receiveShadow && w === Ei)) &&
            (!S.frustumCulled || i.intersectsObject(S))
          ) {
            S.modelViewMatrix.multiplyMatrices(O.matrixWorldInverse, S.matrixWorld);
            const N = e.update(S),
              Y = S.material;
            if (Array.isArray(Y)) {
              const q = N.groups;
              for (let V = 0, J = q.length; V < J; V++) {
                const k = q[V],
                  oe = Y[k.materialIndex];
                if (oe && oe.visible) {
                  const he = T(S, oe, x, w);
                  S.onBeforeShadow(n, S, D, O, N, he, k), n.renderBufferDirect(O, null, N, he, S, k), S.onAfterShadow(n, S, D, O, N, he, k);
                }
              }
            } else if (Y.visible) {
              const q = T(S, Y, x, w);
              S.onBeforeShadow(n, S, D, O, N, q, null), n.renderBufferDirect(O, null, N, q, S, null), S.onAfterShadow(n, S, D, O, N, q, null);
            }
          }
          const H = S.children;
          for (let N = 0, Y = H.length; N < Y; N++) _(H[N], D, O, x, w);
        }
        function b(S) {
          S.target.removeEventListener("dispose", b);
          for (const O in c) {
            const x = c[O],
              w = S.target.uuid;
            w in x && (x[w].dispose(), delete x[w]);
          }
        }
      }
      const ny = { [Kc]: Yc, [qc]: Zc, [Xc]: $c, [Er]: Jc, [Yc]: Kc, [Zc]: qc, [$c]: Xc, [Jc]: Er };
      function iy(n, e) {
        function t() {
          let C = !1;
          const re = new st();
          let Z = null;
          const fe = new st(0, 0, 0, 0);
          return {
            setMask: function ($) {
              Z !== $ && !C && (n.colorMask($, $, $, $), (Z = $));
            },
            setLocked: function ($) {
              C = $;
            },
            setClear: function ($, W, de, Fe, Pt) {
              Pt === !0 && (($ *= Fe), (W *= Fe), (de *= Fe)), re.set($, W, de, Fe), fe.equals(re) === !1 && (n.clearColor($, W, de, Fe), fe.copy(re));
            },
            reset: function () {
              (C = !1), (Z = null), fe.set(-1, 0, 0, 0);
            },
          };
        }
        function i() {
          let C = !1,
            re = !1,
            Z = null,
            fe = null,
            $ = null;
          return {
            setReversed: function (W) {
              if (re !== W) {
                const de = e.get("EXT_clip_control");
                W ? de.clipControlEXT(de.LOWER_LEFT_EXT, de.ZERO_TO_ONE_EXT) : de.clipControlEXT(de.LOWER_LEFT_EXT, de.NEGATIVE_ONE_TO_ONE_EXT), (re = W);
                const Fe = $;
                ($ = null), this.setClear(Fe);
              }
            },
            getReversed: function () {
              return re;
            },
            setTest: function (W) {
              W ? ae(n.DEPTH_TEST) : Ee(n.DEPTH_TEST);
            },
            setMask: function (W) {
              Z !== W && !C && (n.depthMask(W), (Z = W));
            },
            setFunc: function (W) {
              if ((re && (W = ny[W]), fe !== W)) {
                switch (W) {
                  case Kc:
                    n.depthFunc(n.NEVER);
                    break;
                  case Yc:
                    n.depthFunc(n.ALWAYS);
                    break;
                  case qc:
                    n.depthFunc(n.LESS);
                    break;
                  case Er:
                    n.depthFunc(n.LEQUAL);
                    break;
                  case Xc:
                    n.depthFunc(n.EQUAL);
                    break;
                  case Jc:
                    n.depthFunc(n.GEQUAL);
                    break;
                  case Zc:
                    n.depthFunc(n.GREATER);
                    break;
                  case $c:
                    n.depthFunc(n.NOTEQUAL);
                    break;
                  default:
                    n.depthFunc(n.LEQUAL);
                }
                fe = W;
              }
            },
            setLocked: function (W) {
              C = W;
            },
            setClear: function (W) {
              $ !== W && (re && (W = 1 - W), n.clearDepth(W), ($ = W));
            },
            reset: function () {
              (C = !1), (Z = null), (fe = null), ($ = null), (re = !1);
            },
          };
        }
        function s() {
          let C = !1,
            re = null,
            Z = null,
            fe = null,
            $ = null,
            W = null,
            de = null,
            Fe = null,
            Pt = null;
          return {
            setTest: function (ot) {
              C || (ot ? ae(n.STENCIL_TEST) : Ee(n.STENCIL_TEST));
            },
            setMask: function (ot) {
              re !== ot && !C && (n.stencilMask(ot), (re = ot));
            },
            setFunc: function (ot, Qn, Pi) {
              (Z !== ot || fe !== Qn || $ !== Pi) && (n.stencilFunc(ot, Qn, Pi), (Z = ot), (fe = Qn), ($ = Pi));
            },
            setOp: function (ot, Qn, Pi) {
              (W !== ot || de !== Qn || Fe !== Pi) && (n.stencilOp(ot, Qn, Pi), (W = ot), (de = Qn), (Fe = Pi));
            },
            setLocked: function (ot) {
              C = ot;
            },
            setClear: function (ot) {
              Pt !== ot && (n.clearStencil(ot), (Pt = ot));
            },
            reset: function () {
              (C = !1), (re = null), (Z = null), (fe = null), ($ = null), (W = null), (de = null), (Fe = null), (Pt = null);
            },
          };
        }
        const r = new t(),
          A = new i(),
          o = new s(),
          a = new WeakMap(),
          c = new WeakMap();
        let l = {},
          u = {},
          h = new WeakMap(),
          d = [],
          m = null,
          g = !1,
          p = null,
          f = null,
          E = null,
          T = null,
          _ = null,
          b = null,
          S = null,
          D = new Ue(0, 0, 0),
          O = 0,
          x = !1,
          w = null,
          I = null,
          H = null,
          N = null,
          Y = null;
        const q = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let V = !1,
          J = 0;
        const k = n.getParameter(n.VERSION);
        k.indexOf("WebGL") !== -1
          ? ((J = parseFloat(/^WebGL (\d)/.exec(k)[1])), (V = J >= 1))
          : k.indexOf("OpenGL ES") !== -1 && ((J = parseFloat(/^OpenGL ES (\d)/.exec(k)[1])), (V = J >= 2));
        let oe = null,
          he = {};
        const Me = n.getParameter(n.SCISSOR_BOX),
          He = n.getParameter(n.VIEWPORT),
          ht = new st().fromArray(Me),
          Q = new st().fromArray(He);
        function te(C, re, Z, fe) {
          const $ = new Uint8Array(4),
            W = n.createTexture();
          n.bindTexture(C, W), n.texParameteri(C, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(C, n.TEXTURE_MAG_FILTER, n.NEAREST);
          for (let de = 0; de < Z; de++)
            C === n.TEXTURE_3D || C === n.TEXTURE_2D_ARRAY
              ? n.texImage3D(re, 0, n.RGBA, 1, 1, fe, 0, n.RGBA, n.UNSIGNED_BYTE, $)
              : n.texImage2D(re + de, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, $);
          return W;
        }
        const Te = {};
        (Te[n.TEXTURE_2D] = te(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
          (Te[n.TEXTURE_CUBE_MAP] = te(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6)),
          (Te[n.TEXTURE_2D_ARRAY] = te(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
          (Te[n.TEXTURE_3D] = te(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
          r.setClear(0, 0, 0, 1),
          A.setClear(1),
          o.setClear(0),
          ae(n.DEPTH_TEST),
          A.setFunc(Er),
          it(!1),
          pt(wf),
          ae(n.CULL_FACE),
          M(rs);
        function ae(C) {
          l[C] !== !0 && (n.enable(C), (l[C] = !0));
        }
        function Ee(C) {
          l[C] !== !1 && (n.disable(C), (l[C] = !1));
        }
        function tt(C, re) {
          return u[C] !== re
            ? (n.bindFramebuffer(C, re),
              (u[C] = re),
              C === n.DRAW_FRAMEBUFFER && (u[n.FRAMEBUFFER] = re),
              C === n.FRAMEBUFFER && (u[n.DRAW_FRAMEBUFFER] = re),
              !0)
            : !1;
        }
        function Re(C, re) {
          let Z = d,
            fe = !1;
          if (C) {
            (Z = h.get(re)), Z === void 0 && ((Z = []), h.set(re, Z));
            const $ = C.textures;
            if (Z.length !== $.length || Z[0] !== n.COLOR_ATTACHMENT0) {
              for (let W = 0, de = $.length; W < de; W++) Z[W] = n.COLOR_ATTACHMENT0 + W;
              (Z.length = $.length), (fe = !0);
            }
          } else Z[0] !== n.BACK && ((Z[0] = n.BACK), (fe = !0));
          fe && n.drawBuffers(Z);
        }
        function Et(C) {
          return m !== C ? (n.useProgram(C), (m = C), !0) : !1;
        }
        const Dt = { [Ms]: n.FUNC_ADD, [c0]: n.FUNC_SUBTRACT, [l0]: n.FUNC_REVERSE_SUBTRACT };
        (Dt[u0] = n.MIN), (Dt[h0] = n.MAX);
        const nt = {
          [f0]: n.ZERO,
          [d0]: n.ONE,
          [p0]: n.SRC_COLOR,
          [Vc]: n.SRC_ALPHA,
          [_0]: n.SRC_ALPHA_SATURATE,
          [v0]: n.DST_COLOR,
          [g0]: n.DST_ALPHA,
          [m0]: n.ONE_MINUS_SRC_COLOR,
          [Wc]: n.ONE_MINUS_SRC_ALPHA,
          [w0]: n.ONE_MINUS_DST_COLOR,
          [P0]: n.ONE_MINUS_DST_ALPHA,
          [x0]: n.CONSTANT_COLOR,
          [y0]: n.ONE_MINUS_CONSTANT_COLOR,
          [T0]: n.CONSTANT_ALPHA,
          [E0]: n.ONE_MINUS_CONSTANT_ALPHA,
        };
        function M(C, re, Z, fe, $, W, de, Fe, Pt, ot) {
          if (C === rs) {
            g === !0 && (Ee(n.BLEND), (g = !1));
            return;
          }
          if ((g === !1 && (ae(n.BLEND), (g = !0)), C !== a0)) {
            if (C !== p || ot !== x) {
              if (((f !== Ms || _ !== Ms) && (n.blendEquation(n.FUNC_ADD), (f = Ms), (_ = Ms)), ot))
                switch (C) {
                  case lr:
                    n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                    break;
                  case _f:
                    n.blendFunc(n.ONE, n.ONE);
                    break;
                  case xf:
                    n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                    break;
                  case yf:
                    n.blendFuncSeparate(n.DST_COLOR, n.ONE_MINUS_SRC_ALPHA, n.ZERO, n.ONE);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", C);
                    break;
                }
              else
                switch (C) {
                  case lr:
                    n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                    break;
                  case _f:
                    n.blendFuncSeparate(n.SRC_ALPHA, n.ONE, n.ONE, n.ONE);
                    break;
                  case xf:
                    console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
                    break;
                  case yf:
                    console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", C);
                    break;
                }
              (E = null), (T = null), (b = null), (S = null), D.set(0, 0, 0), (O = 0), (p = C), (x = ot);
            }
            return;
          }
          ($ = $ || re),
            (W = W || Z),
            (de = de || fe),
            (re !== f || $ !== _) && (n.blendEquationSeparate(Dt[re], Dt[$]), (f = re), (_ = $)),
            (Z !== E || fe !== T || W !== b || de !== S) && (n.blendFuncSeparate(nt[Z], nt[fe], nt[W], nt[de]), (E = Z), (T = fe), (b = W), (S = de)),
            (Fe.equals(D) === !1 || Pt !== O) && (n.blendColor(Fe.r, Fe.g, Fe.b, Pt), D.copy(Fe), (O = Pt)),
            (p = C),
            (x = !1);
        }
        function Zt(C, re) {
          C.side === ai ? Ee(n.CULL_FACE) : ae(n.CULL_FACE);
          let Z = C.side === fn;
          re && (Z = !Z),
            it(Z),
            C.blending === lr && C.transparent === !1
              ? M(rs)
              : M(
                  C.blending,
                  C.blendEquation,
                  C.blendSrc,
                  C.blendDst,
                  C.blendEquationAlpha,
                  C.blendSrcAlpha,
                  C.blendDstAlpha,
                  C.blendColor,
                  C.blendAlpha,
                  C.premultipliedAlpha
                ),
            A.setFunc(C.depthFunc),
            A.setTest(C.depthTest),
            A.setMask(C.depthWrite),
            r.setMask(C.colorWrite);
          const fe = C.stencilWrite;
          o.setTest(fe),
            fe &&
              (o.setMask(C.stencilWriteMask),
              o.setFunc(C.stencilFunc, C.stencilRef, C.stencilFuncMask),
              o.setOp(C.stencilFail, C.stencilZFail, C.stencilZPass)),
            Ze(C.polygonOffset, C.polygonOffsetFactor, C.polygonOffsetUnits),
            C.alphaToCoverage === !0 ? ae(n.SAMPLE_ALPHA_TO_COVERAGE) : Ee(n.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function it(C) {
          w !== C && (C ? n.frontFace(n.CW) : n.frontFace(n.CCW), (w = C));
        }
        function pt(C) {
          C !== r0
            ? (ae(n.CULL_FACE), C !== I && (C === wf ? n.cullFace(n.BACK) : C === A0 ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK)))
            : Ee(n.CULL_FACE),
            (I = C);
        }
        function ve(C) {
          C !== H && (V && n.lineWidth(C), (H = C));
        }
        function Ze(C, re, Z) {
          C ? (ae(n.POLYGON_OFFSET_FILL), (N !== re || Y !== Z) && (n.polygonOffset(re, Z), (N = re), (Y = Z))) : Ee(n.POLYGON_OFFSET_FILL);
        }
        function Se(C) {
          C ? ae(n.SCISSOR_TEST) : Ee(n.SCISSOR_TEST);
        }
        function Ge(C) {
          C === void 0 && (C = n.TEXTURE0 + q - 1), oe !== C && (n.activeTexture(C), (oe = C));
        }
        function kt(C, re, Z) {
          Z === void 0 && (oe === null ? (Z = n.TEXTURE0 + q - 1) : (Z = oe));
          let fe = he[Z];
          fe === void 0 && ((fe = { type: void 0, texture: void 0 }), (he[Z] = fe)),
            (fe.type !== C || fe.texture !== re) &&
              (oe !== Z && (n.activeTexture(Z), (oe = Z)), n.bindTexture(C, re || Te[C]), (fe.type = C), (fe.texture = re));
        }
        function y() {
          const C = he[oe];
          C !== void 0 && C.type !== void 0 && (n.bindTexture(C.type, null), (C.type = void 0), (C.texture = void 0));
        }
        function P() {
          try {
            n.compressedTexImage2D(...arguments);
          } catch (C) {
            console.error("THREE.WebGLState:", C);
          }
        }
        function L() {
          try {
            n.compressedTexImage3D(...arguments);
          } catch (C) {
            console.error("THREE.WebGLState:", C);
          }
        }
        function j() {
          try {
            n.texSubImage2D(...arguments);
          } catch (C) {
            console.error("THREE.WebGLState:", C);
          }
        }
        function K() {
          try {
            n.texSubImage3D(...arguments);
          } catch (C) {
            console.error("THREE.WebGLState:", C);
          }
        }
        function G() {
          try {
            n.compressedTexSubImage2D(...arguments);
          } catch (C) {
            console.error("THREE.WebGLState:", C);
          }
        }
        function xe() {
          try {
            n.compressedTexSubImage3D(...arguments);
          } catch (C) {
            console.error("THREE.WebGLState:", C);
          }
        }
        function se() {
          try {
            n.texStorage2D(...arguments);
          } catch (C) {
            console.error("THREE.WebGLState:", C);
          }
        }
        function ge() {
          try {
            n.texStorage3D(...arguments);
          } catch (C) {
            console.error("THREE.WebGLState:", C);
          }
        }
        function ye() {
          try {
            n.texImage2D(...arguments);
          } catch (C) {
            console.error("THREE.WebGLState:", C);
          }
        }
        function X() {
          try {
            n.texImage3D(...arguments);
          } catch (C) {
            console.error("THREE.WebGLState:", C);
          }
        }
        function le(C) {
          ht.equals(C) === !1 && (n.scissor(C.x, C.y, C.z, C.w), ht.copy(C));
        }
        function ze(C) {
          Q.equals(C) === !1 && (n.viewport(C.x, C.y, C.z, C.w), Q.copy(C));
        }
        function be(C, re) {
          let Z = c.get(re);
          Z === void 0 && ((Z = new WeakMap()), c.set(re, Z));
          let fe = Z.get(C);
          fe === void 0 && ((fe = n.getUniformBlockIndex(re, C.name)), Z.set(C, fe));
        }
        function ne(C, re) {
          const fe = c.get(re).get(C);
          a.get(re) !== fe && (n.uniformBlockBinding(re, fe, C.__bindingPointIndex), a.set(re, fe));
        }
        function Le() {
          n.disable(n.BLEND),
            n.disable(n.CULL_FACE),
            n.disable(n.DEPTH_TEST),
            n.disable(n.POLYGON_OFFSET_FILL),
            n.disable(n.SCISSOR_TEST),
            n.disable(n.STENCIL_TEST),
            n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
            n.blendEquation(n.FUNC_ADD),
            n.blendFunc(n.ONE, n.ZERO),
            n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
            n.blendColor(0, 0, 0, 0),
            n.colorMask(!0, !0, !0, !0),
            n.clearColor(0, 0, 0, 0),
            n.depthMask(!0),
            n.depthFunc(n.LESS),
            A.setReversed(!1),
            n.clearDepth(1),
            n.stencilMask(4294967295),
            n.stencilFunc(n.ALWAYS, 0, 4294967295),
            n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
            n.clearStencil(0),
            n.cullFace(n.BACK),
            n.frontFace(n.CCW),
            n.polygonOffset(0, 0),
            n.activeTexture(n.TEXTURE0),
            n.bindFramebuffer(n.FRAMEBUFFER, null),
            n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
            n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
            n.useProgram(null),
            n.lineWidth(1),
            n.scissor(0, 0, n.canvas.width, n.canvas.height),
            n.viewport(0, 0, n.canvas.width, n.canvas.height),
            (l = {}),
            (oe = null),
            (he = {}),
            (u = {}),
            (h = new WeakMap()),
            (d = []),
            (m = null),
            (g = !1),
            (p = null),
            (f = null),
            (E = null),
            (T = null),
            (_ = null),
            (b = null),
            (S = null),
            (D = new Ue(0, 0, 0)),
            (O = 0),
            (x = !1),
            (w = null),
            (I = null),
            (H = null),
            (N = null),
            (Y = null),
            ht.set(0, 0, n.canvas.width, n.canvas.height),
            Q.set(0, 0, n.canvas.width, n.canvas.height),
            r.reset(),
            A.reset(),
            o.reset();
        }
        return {
          buffers: { color: r, depth: A, stencil: o },
          enable: ae,
          disable: Ee,
          bindFramebuffer: tt,
          drawBuffers: Re,
          useProgram: Et,
          setBlending: M,
          setMaterial: Zt,
          setFlipSided: it,
          setCullFace: pt,
          setLineWidth: ve,
          setPolygonOffset: Ze,
          setScissorTest: Se,
          activeTexture: Ge,
          bindTexture: kt,
          unbindTexture: y,
          compressedTexImage2D: P,
          compressedTexImage3D: L,
          texImage2D: ye,
          texImage3D: X,
          updateUBOMapping: be,
          uniformBlockBinding: ne,
          texStorage2D: se,
          texStorage3D: ge,
          texSubImage2D: j,
          texSubImage3D: K,
          compressedTexSubImage2D: G,
          compressedTexSubImage3D: xe,
          scissor: le,
          viewport: ze,
          reset: Le,
        };
      }
      function sy(n, e, t, i, s, r, A) {
        const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
          a = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
          c = new qe(),
          l = new WeakMap();
        let u;
        const h = new WeakMap();
        let d = !1;
        try {
          d = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {}
        function m(y, P) {
          return d ? new OffscreenCanvas(y, P) : SA("canvas");
        }
        function g(y, P, L) {
          let j = 1;
          const K = kt(y);
          if (((K.width > L || K.height > L) && (j = L / Math.max(K.width, K.height)), j < 1))
            if (
              (typeof HTMLImageElement < "u" && y instanceof HTMLImageElement) ||
              (typeof HTMLCanvasElement < "u" && y instanceof HTMLCanvasElement) ||
              (typeof ImageBitmap < "u" && y instanceof ImageBitmap) ||
              (typeof VideoFrame < "u" && y instanceof VideoFrame)
            ) {
              const G = Math.floor(j * K.width),
                xe = Math.floor(j * K.height);
              u === void 0 && (u = m(G, xe));
              const se = P ? m(G, xe) : u;
              return (
                (se.width = G),
                (se.height = xe),
                se.getContext("2d").drawImage(y, 0, 0, G, xe),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + K.width + "x" + K.height + ") to (" + G + "x" + xe + ")."),
                se
              );
            } else return "data" in y && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + K.width + "x" + K.height + ")."), y;
          return y;
        }
        function p(y) {
          return y.generateMipmaps;
        }
        function f(y) {
          n.generateMipmap(y);
        }
        function E(y) {
          return y.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : y.isWebGL3DRenderTarget
            ? n.TEXTURE_3D
            : y.isWebGLArrayRenderTarget || y.isCompressedArrayTexture
            ? n.TEXTURE_2D_ARRAY
            : n.TEXTURE_2D;
        }
        function T(y, P, L, j, K = !1) {
          if (y !== null) {
            if (n[y] !== void 0) return n[y];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + y + "'");
          }
          let G = P;
          if (
            (P === n.RED && (L === n.FLOAT && (G = n.R32F), L === n.HALF_FLOAT && (G = n.R16F), L === n.UNSIGNED_BYTE && (G = n.R8)),
            P === n.RED_INTEGER &&
              (L === n.UNSIGNED_BYTE && (G = n.R8UI),
              L === n.UNSIGNED_SHORT && (G = n.R16UI),
              L === n.UNSIGNED_INT && (G = n.R32UI),
              L === n.BYTE && (G = n.R8I),
              L === n.SHORT && (G = n.R16I),
              L === n.INT && (G = n.R32I)),
            P === n.RG && (L === n.FLOAT && (G = n.RG32F), L === n.HALF_FLOAT && (G = n.RG16F), L === n.UNSIGNED_BYTE && (G = n.RG8)),
            P === n.RG_INTEGER &&
              (L === n.UNSIGNED_BYTE && (G = n.RG8UI),
              L === n.UNSIGNED_SHORT && (G = n.RG16UI),
              L === n.UNSIGNED_INT && (G = n.RG32UI),
              L === n.BYTE && (G = n.RG8I),
              L === n.SHORT && (G = n.RG16I),
              L === n.INT && (G = n.RG32I)),
            P === n.RGB_INTEGER &&
              (L === n.UNSIGNED_BYTE && (G = n.RGB8UI),
              L === n.UNSIGNED_SHORT && (G = n.RGB16UI),
              L === n.UNSIGNED_INT && (G = n.RGB32UI),
              L === n.BYTE && (G = n.RGB8I),
              L === n.SHORT && (G = n.RGB16I),
              L === n.INT && (G = n.RGB32I)),
            P === n.RGBA_INTEGER &&
              (L === n.UNSIGNED_BYTE && (G = n.RGBA8UI),
              L === n.UNSIGNED_SHORT && (G = n.RGBA16UI),
              L === n.UNSIGNED_INT && (G = n.RGBA32UI),
              L === n.BYTE && (G = n.RGBA8I),
              L === n.SHORT && (G = n.RGBA16I),
              L === n.INT && (G = n.RGBA32I)),
            P === n.RGB && L === n.UNSIGNED_INT_5_9_9_9_REV && (G = n.RGB9_E5),
            P === n.RGBA)
          ) {
            const xe = K ? Fo : Xe.getTransfer(j);
            L === n.FLOAT && (G = n.RGBA32F),
              L === n.HALF_FLOAT && (G = n.RGBA16F),
              L === n.UNSIGNED_BYTE && (G = xe === ut ? n.SRGB8_ALPHA8 : n.RGBA8),
              L === n.UNSIGNED_SHORT_4_4_4_4 && (G = n.RGBA4),
              L === n.UNSIGNED_SHORT_5_5_5_1 && (G = n.RGB5_A1);
          }
          return (G === n.R16F || G === n.R32F || G === n.RG16F || G === n.RG32F || G === n.RGBA16F || G === n.RGBA32F) && e.get("EXT_color_buffer_float"), G;
        }
        function _(y, P) {
          let L;
          return (
            y
              ? P === null || P === Us || P === TA
                ? (L = n.DEPTH24_STENCIL8)
                : P === Xn
                ? (L = n.DEPTH32F_STENCIL8)
                : P === yA &&
                  ((L = n.DEPTH24_STENCIL8), console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."))
              : P === null || P === Us || P === TA
              ? (L = n.DEPTH_COMPONENT24)
              : P === Xn
              ? (L = n.DEPTH_COMPONENT32F)
              : P === yA && (L = n.DEPTH_COMPONENT16),
            L
          );
        }
        function b(y, P) {
          return p(y) === !0 || (y.isFramebufferTexture && y.minFilter !== sn && y.minFilter !== Tn)
            ? Math.log2(Math.max(P.width, P.height)) + 1
            : y.mipmaps !== void 0 && y.mipmaps.length > 0
            ? y.mipmaps.length
            : y.isCompressedTexture && Array.isArray(y.image)
            ? P.mipmaps.length
            : 1;
        }
        function S(y) {
          const P = y.target;
          P.removeEventListener("dispose", S), O(P), P.isVideoTexture && l.delete(P);
        }
        function D(y) {
          const P = y.target;
          P.removeEventListener("dispose", D), w(P);
        }
        function O(y) {
          const P = i.get(y);
          if (P.__webglInit === void 0) return;
          const L = y.source,
            j = h.get(L);
          if (j) {
            const K = j[P.__cacheKey];
            K.usedTimes--, K.usedTimes === 0 && x(y), Object.keys(j).length === 0 && h.delete(L);
          }
          i.remove(y);
        }
        function x(y) {
          const P = i.get(y);
          n.deleteTexture(P.__webglTexture);
          const L = y.source,
            j = h.get(L);
          delete j[P.__cacheKey], A.memory.textures--;
        }
        function w(y) {
          const P = i.get(y);
          if ((y.depthTexture && (y.depthTexture.dispose(), i.remove(y.depthTexture)), y.isWebGLCubeRenderTarget))
            for (let j = 0; j < 6; j++) {
              if (Array.isArray(P.__webglFramebuffer[j]))
                for (let K = 0; K < P.__webglFramebuffer[j].length; K++) n.deleteFramebuffer(P.__webglFramebuffer[j][K]);
              else n.deleteFramebuffer(P.__webglFramebuffer[j]);
              P.__webglDepthbuffer && n.deleteRenderbuffer(P.__webglDepthbuffer[j]);
            }
          else {
            if (Array.isArray(P.__webglFramebuffer)) for (let j = 0; j < P.__webglFramebuffer.length; j++) n.deleteFramebuffer(P.__webglFramebuffer[j]);
            else n.deleteFramebuffer(P.__webglFramebuffer);
            if (
              (P.__webglDepthbuffer && n.deleteRenderbuffer(P.__webglDepthbuffer),
              P.__webglMultisampledFramebuffer && n.deleteFramebuffer(P.__webglMultisampledFramebuffer),
              P.__webglColorRenderbuffer)
            )
              for (let j = 0; j < P.__webglColorRenderbuffer.length; j++) P.__webglColorRenderbuffer[j] && n.deleteRenderbuffer(P.__webglColorRenderbuffer[j]);
            P.__webglDepthRenderbuffer && n.deleteRenderbuffer(P.__webglDepthRenderbuffer);
          }
          const L = y.textures;
          for (let j = 0, K = L.length; j < K; j++) {
            const G = i.get(L[j]);
            G.__webglTexture && (n.deleteTexture(G.__webglTexture), A.memory.textures--), i.remove(L[j]);
          }
          i.remove(y);
        }
        let I = 0;
        function H() {
          I = 0;
        }
        function N() {
          const y = I;
          return (
            y >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + y + " texture units while this GPU supports only " + s.maxTextures),
            (I += 1),
            y
          );
        }
        function Y(y) {
          const P = [];
          return (
            P.push(y.wrapS),
            P.push(y.wrapT),
            P.push(y.wrapR || 0),
            P.push(y.magFilter),
            P.push(y.minFilter),
            P.push(y.anisotropy),
            P.push(y.internalFormat),
            P.push(y.format),
            P.push(y.type),
            P.push(y.generateMipmaps),
            P.push(y.premultiplyAlpha),
            P.push(y.flipY),
            P.push(y.unpackAlignment),
            P.push(y.colorSpace),
            P.join()
          );
        }
        function q(y, P) {
          const L = i.get(y);
          if ((y.isVideoTexture && Se(y), y.isRenderTargetTexture === !1 && y.version > 0 && L.__version !== y.version)) {
            const j = y.image;
            if (j === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (j.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
              Te(L, y, P);
              return;
            }
          }
          t.bindTexture(n.TEXTURE_2D, L.__webglTexture, n.TEXTURE0 + P);
        }
        function V(y, P) {
          const L = i.get(y);
          if (y.version > 0 && L.__version !== y.version) {
            Te(L, y, P);
            return;
          }
          t.bindTexture(n.TEXTURE_2D_ARRAY, L.__webglTexture, n.TEXTURE0 + P);
        }
        function J(y, P) {
          const L = i.get(y);
          if (y.version > 0 && L.__version !== y.version) {
            Te(L, y, P);
            return;
          }
          t.bindTexture(n.TEXTURE_3D, L.__webglTexture, n.TEXTURE0 + P);
        }
        function k(y, P) {
          const L = i.get(y);
          if (y.version > 0 && L.__version !== y.version) {
            ae(L, y, P);
            return;
          }
          t.bindTexture(n.TEXTURE_CUBE_MAP, L.__webglTexture, n.TEXTURE0 + P);
        }
        const oe = { [Cr]: n.REPEAT, [es]: n.CLAMP_TO_EDGE, [Uo]: n.MIRRORED_REPEAT },
          he = {
            [sn]: n.NEAREST,
            [jm]: n.NEAREST_MIPMAP_NEAREST,
            [aA]: n.NEAREST_MIPMAP_LINEAR,
            [Tn]: n.LINEAR,
            [xo]: n.LINEAR_MIPMAP_NEAREST,
            [Ii]: n.LINEAR_MIPMAP_LINEAR,
          },
          Me = { [G0]: n.NEVER, [K0]: n.ALWAYS, [j0]: n.LESS, [Zm]: n.LEQUAL, [H0]: n.EQUAL, [W0]: n.GEQUAL, [Q0]: n.GREATER, [V0]: n.NOTEQUAL };
        function He(y, P) {
          if (
            (P.type === Xn &&
              e.has("OES_texture_float_linear") === !1 &&
              (P.magFilter === Tn ||
                P.magFilter === xo ||
                P.magFilter === aA ||
                P.magFilter === Ii ||
                P.minFilter === Tn ||
                P.minFilter === xo ||
                P.minFilter === aA ||
                P.minFilter === Ii) &&
              console.warn(
                "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
              ),
            n.texParameteri(y, n.TEXTURE_WRAP_S, oe[P.wrapS]),
            n.texParameteri(y, n.TEXTURE_WRAP_T, oe[P.wrapT]),
            (y === n.TEXTURE_3D || y === n.TEXTURE_2D_ARRAY) && n.texParameteri(y, n.TEXTURE_WRAP_R, oe[P.wrapR]),
            n.texParameteri(y, n.TEXTURE_MAG_FILTER, he[P.magFilter]),
            n.texParameteri(y, n.TEXTURE_MIN_FILTER, he[P.minFilter]),
            P.compareFunction &&
              (n.texParameteri(y, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(y, n.TEXTURE_COMPARE_FUNC, Me[P.compareFunction])),
            e.has("EXT_texture_filter_anisotropic") === !0)
          ) {
            if (P.magFilter === sn || (P.minFilter !== aA && P.minFilter !== Ii) || (P.type === Xn && e.has("OES_texture_float_linear") === !1)) return;
            if (P.anisotropy > 1 || i.get(P).__currentAnisotropy) {
              const L = e.get("EXT_texture_filter_anisotropic");
              n.texParameterf(y, L.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(P.anisotropy, s.getMaxAnisotropy())), (i.get(P).__currentAnisotropy = P.anisotropy);
            }
          }
        }
        function ht(y, P) {
          let L = !1;
          y.__webglInit === void 0 && ((y.__webglInit = !0), P.addEventListener("dispose", S));
          const j = P.source;
          let K = h.get(j);
          K === void 0 && ((K = {}), h.set(j, K));
          const G = Y(P);
          if (G !== y.__cacheKey) {
            K[G] === void 0 && ((K[G] = { texture: n.createTexture(), usedTimes: 0 }), A.memory.textures++, (L = !0)), K[G].usedTimes++;
            const xe = K[y.__cacheKey];
            xe !== void 0 && (K[y.__cacheKey].usedTimes--, xe.usedTimes === 0 && x(P)), (y.__cacheKey = G), (y.__webglTexture = K[G].texture);
          }
          return L;
        }
        function Q(y, P, L) {
          return Math.floor(Math.floor(y / L) / P);
        }
        function te(y, P, L, j) {
          const G = y.updateRanges;
          if (G.length === 0) t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, P.width, P.height, L, j, P.data);
          else {
            G.sort((X, le) => X.start - le.start);
            let xe = 0;
            for (let X = 1; X < G.length; X++) {
              const le = G[xe],
                ze = G[X],
                be = le.start + le.count,
                ne = Q(ze.start, P.width, 4),
                Le = Q(le.start, P.width, 4);
              ze.start <= be + 1 && ne === Le && Q(ze.start + ze.count - 1, P.width, 4) === ne
                ? (le.count = Math.max(le.count, ze.start + ze.count - le.start))
                : (++xe, (G[xe] = ze));
            }
            G.length = xe + 1;
            const se = n.getParameter(n.UNPACK_ROW_LENGTH),
              ge = n.getParameter(n.UNPACK_SKIP_PIXELS),
              ye = n.getParameter(n.UNPACK_SKIP_ROWS);
            n.pixelStorei(n.UNPACK_ROW_LENGTH, P.width);
            for (let X = 0, le = G.length; X < le; X++) {
              const ze = G[X],
                be = Math.floor(ze.start / 4),
                ne = Math.ceil(ze.count / 4),
                Le = be % P.width,
                C = Math.floor(be / P.width),
                re = ne,
                Z = 1;
              n.pixelStorei(n.UNPACK_SKIP_PIXELS, Le), n.pixelStorei(n.UNPACK_SKIP_ROWS, C), t.texSubImage2D(n.TEXTURE_2D, 0, Le, C, re, Z, L, j, P.data);
            }
            y.clearUpdateRanges(), n.pixelStorei(n.UNPACK_ROW_LENGTH, se), n.pixelStorei(n.UNPACK_SKIP_PIXELS, ge), n.pixelStorei(n.UNPACK_SKIP_ROWS, ye);
          }
        }
        function Te(y, P, L) {
          let j = n.TEXTURE_2D;
          (P.isDataArrayTexture || P.isCompressedArrayTexture) && (j = n.TEXTURE_2D_ARRAY), P.isData3DTexture && (j = n.TEXTURE_3D);
          const K = ht(y, P),
            G = P.source;
          t.bindTexture(j, y.__webglTexture, n.TEXTURE0 + L);
          const xe = i.get(G);
          if (G.version !== xe.__version || K === !0) {
            t.activeTexture(n.TEXTURE0 + L);
            const se = Xe.getPrimaries(Xe.workingColorSpace),
              ge = P.colorSpace === $i ? null : Xe.getPrimaries(P.colorSpace),
              ye = P.colorSpace === $i || se === ge ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, P.flipY),
              n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, P.premultiplyAlpha),
              n.pixelStorei(n.UNPACK_ALIGNMENT, P.unpackAlignment),
              n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, ye);
            let X = g(P.image, !1, s.maxTextureSize);
            X = Ge(P, X);
            const le = r.convert(P.format, P.colorSpace),
              ze = r.convert(P.type);
            let be = T(P.internalFormat, le, ze, P.colorSpace, P.isVideoTexture);
            He(j, P);
            let ne;
            const Le = P.mipmaps,
              C = P.isVideoTexture !== !0,
              re = xe.__version === void 0 || K === !0,
              Z = G.dataReady,
              fe = b(P, X);
            if (P.isDepthTexture)
              (be = _(P.format === DA, P.type)),
                re && (C ? t.texStorage2D(n.TEXTURE_2D, 1, be, X.width, X.height) : t.texImage2D(n.TEXTURE_2D, 0, be, X.width, X.height, 0, le, ze, null));
            else if (P.isDataTexture)
              if (Le.length > 0) {
                C && re && t.texStorage2D(n.TEXTURE_2D, fe, be, Le[0].width, Le[0].height);
                for (let $ = 0, W = Le.length; $ < W; $++)
                  (ne = Le[$]),
                    C
                      ? Z && t.texSubImage2D(n.TEXTURE_2D, $, 0, 0, ne.width, ne.height, le, ze, ne.data)
                      : t.texImage2D(n.TEXTURE_2D, $, be, ne.width, ne.height, 0, le, ze, ne.data);
                P.generateMipmaps = !1;
              } else
                C
                  ? (re && t.texStorage2D(n.TEXTURE_2D, fe, be, X.width, X.height), Z && te(P, X, le, ze))
                  : t.texImage2D(n.TEXTURE_2D, 0, be, X.width, X.height, 0, le, ze, X.data);
            else if (P.isCompressedTexture)
              if (P.isCompressedArrayTexture) {
                C && re && t.texStorage3D(n.TEXTURE_2D_ARRAY, fe, be, Le[0].width, Le[0].height, X.depth);
                for (let $ = 0, W = Le.length; $ < W; $++)
                  if (((ne = Le[$]), P.format !== kn))
                    if (le !== null)
                      if (C) {
                        if (Z)
                          if (P.layerUpdates.size > 0) {
                            const de = hd(ne.width, ne.height, P.format, P.type);
                            for (const Fe of P.layerUpdates) {
                              const Pt = ne.data.subarray((Fe * de) / ne.data.BYTES_PER_ELEMENT, ((Fe + 1) * de) / ne.data.BYTES_PER_ELEMENT);
                              t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, $, 0, 0, Fe, ne.width, ne.height, 1, le, Pt);
                            }
                            P.clearLayerUpdates();
                          } else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, $, 0, 0, 0, ne.width, ne.height, X.depth, le, ne.data);
                      } else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, $, be, ne.width, ne.height, X.depth, 0, ne.data, 0, 0);
                    else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                  else
                    C
                      ? Z && t.texSubImage3D(n.TEXTURE_2D_ARRAY, $, 0, 0, 0, ne.width, ne.height, X.depth, le, ze, ne.data)
                      : t.texImage3D(n.TEXTURE_2D_ARRAY, $, be, ne.width, ne.height, X.depth, 0, le, ze, ne.data);
              } else {
                C && re && t.texStorage2D(n.TEXTURE_2D, fe, be, Le[0].width, Le[0].height);
                for (let $ = 0, W = Le.length; $ < W; $++)
                  (ne = Le[$]),
                    P.format !== kn
                      ? le !== null
                        ? C
                          ? Z && t.compressedTexSubImage2D(n.TEXTURE_2D, $, 0, 0, ne.width, ne.height, le, ne.data)
                          : t.compressedTexImage2D(n.TEXTURE_2D, $, be, ne.width, ne.height, 0, ne.data)
                        : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()")
                      : C
                      ? Z && t.texSubImage2D(n.TEXTURE_2D, $, 0, 0, ne.width, ne.height, le, ze, ne.data)
                      : t.texImage2D(n.TEXTURE_2D, $, be, ne.width, ne.height, 0, le, ze, ne.data);
              }
            else if (P.isDataArrayTexture)
              if (C) {
                if ((re && t.texStorage3D(n.TEXTURE_2D_ARRAY, fe, be, X.width, X.height, X.depth), Z))
                  if (P.layerUpdates.size > 0) {
                    const $ = hd(X.width, X.height, P.format, P.type);
                    for (const W of P.layerUpdates) {
                      const de = X.data.subarray((W * $) / X.data.BYTES_PER_ELEMENT, ((W + 1) * $) / X.data.BYTES_PER_ELEMENT);
                      t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, W, X.width, X.height, 1, le, ze, de);
                    }
                    P.clearLayerUpdates();
                  } else t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, X.width, X.height, X.depth, le, ze, X.data);
              } else t.texImage3D(n.TEXTURE_2D_ARRAY, 0, be, X.width, X.height, X.depth, 0, le, ze, X.data);
            else if (P.isData3DTexture)
              C
                ? (re && t.texStorage3D(n.TEXTURE_3D, fe, be, X.width, X.height, X.depth),
                  Z && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, X.width, X.height, X.depth, le, ze, X.data))
                : t.texImage3D(n.TEXTURE_3D, 0, be, X.width, X.height, X.depth, 0, le, ze, X.data);
            else if (P.isFramebufferTexture) {
              if (re)
                if (C) t.texStorage2D(n.TEXTURE_2D, fe, be, X.width, X.height);
                else {
                  let $ = X.width,
                    W = X.height;
                  for (let de = 0; de < fe; de++) t.texImage2D(n.TEXTURE_2D, de, be, $, W, 0, le, ze, null), ($ >>= 1), (W >>= 1);
                }
            } else if (Le.length > 0) {
              if (C && re) {
                const $ = kt(Le[0]);
                t.texStorage2D(n.TEXTURE_2D, fe, be, $.width, $.height);
              }
              for (let $ = 0, W = Le.length; $ < W; $++)
                (ne = Le[$]), C ? Z && t.texSubImage2D(n.TEXTURE_2D, $, 0, 0, le, ze, ne) : t.texImage2D(n.TEXTURE_2D, $, be, le, ze, ne);
              P.generateMipmaps = !1;
            } else if (C) {
              if (re) {
                const $ = kt(X);
                t.texStorage2D(n.TEXTURE_2D, fe, be, $.width, $.height);
              }
              Z && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, le, ze, X);
            } else t.texImage2D(n.TEXTURE_2D, 0, be, le, ze, X);
            p(P) && f(j), (xe.__version = G.version), P.onUpdate && P.onUpdate(P);
          }
          y.__version = P.version;
        }
        function ae(y, P, L) {
          if (P.image.length !== 6) return;
          const j = ht(y, P),
            K = P.source;
          t.bindTexture(n.TEXTURE_CUBE_MAP, y.__webglTexture, n.TEXTURE0 + L);
          const G = i.get(K);
          if (K.version !== G.__version || j === !0) {
            t.activeTexture(n.TEXTURE0 + L);
            const xe = Xe.getPrimaries(Xe.workingColorSpace),
              se = P.colorSpace === $i ? null : Xe.getPrimaries(P.colorSpace),
              ge = P.colorSpace === $i || xe === se ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, P.flipY),
              n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, P.premultiplyAlpha),
              n.pixelStorei(n.UNPACK_ALIGNMENT, P.unpackAlignment),
              n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, ge);
            const ye = P.isCompressedTexture || P.image[0].isCompressedTexture,
              X = P.image[0] && P.image[0].isDataTexture,
              le = [];
            for (let W = 0; W < 6; W++)
              !ye && !X ? (le[W] = g(P.image[W], !0, s.maxCubemapSize)) : (le[W] = X ? P.image[W].image : P.image[W]), (le[W] = Ge(P, le[W]));
            const ze = le[0],
              be = r.convert(P.format, P.colorSpace),
              ne = r.convert(P.type),
              Le = T(P.internalFormat, be, ne, P.colorSpace),
              C = P.isVideoTexture !== !0,
              re = G.__version === void 0 || j === !0,
              Z = K.dataReady;
            let fe = b(P, ze);
            He(n.TEXTURE_CUBE_MAP, P);
            let $;
            if (ye) {
              C && re && t.texStorage2D(n.TEXTURE_CUBE_MAP, fe, Le, ze.width, ze.height);
              for (let W = 0; W < 6; W++) {
                $ = le[W].mipmaps;
                for (let de = 0; de < $.length; de++) {
                  const Fe = $[de];
                  P.format !== kn
                    ? be !== null
                      ? C
                        ? Z && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, de, 0, 0, Fe.width, Fe.height, be, Fe.data)
                        : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, de, Le, Fe.width, Fe.height, 0, Fe.data)
                      : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()")
                    : C
                    ? Z && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, de, 0, 0, Fe.width, Fe.height, be, ne, Fe.data)
                    : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, de, Le, Fe.width, Fe.height, 0, be, ne, Fe.data);
                }
              }
            } else {
              if ((($ = P.mipmaps), C && re)) {
                $.length > 0 && fe++;
                const W = kt(le[0]);
                t.texStorage2D(n.TEXTURE_CUBE_MAP, fe, Le, W.width, W.height);
              }
              for (let W = 0; W < 6; W++)
                if (X) {
                  C
                    ? Z && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, 0, 0, le[W].width, le[W].height, be, ne, le[W].data)
                    : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, Le, le[W].width, le[W].height, 0, be, ne, le[W].data);
                  for (let de = 0; de < $.length; de++) {
                    const Pt = $[de].image[W].image;
                    C
                      ? Z && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, de + 1, 0, 0, Pt.width, Pt.height, be, ne, Pt.data)
                      : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, de + 1, Le, Pt.width, Pt.height, 0, be, ne, Pt.data);
                  }
                } else {
                  C
                    ? Z && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, 0, 0, be, ne, le[W])
                    : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, Le, be, ne, le[W]);
                  for (let de = 0; de < $.length; de++) {
                    const Fe = $[de];
                    C
                      ? Z && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, de + 1, 0, 0, be, ne, Fe.image[W])
                      : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + W, de + 1, Le, be, ne, Fe.image[W]);
                  }
                }
            }
            p(P) && f(n.TEXTURE_CUBE_MAP), (G.__version = K.version), P.onUpdate && P.onUpdate(P);
          }
          y.__version = P.version;
        }
        function Ee(y, P, L, j, K, G) {
          const xe = r.convert(L.format, L.colorSpace),
            se = r.convert(L.type),
            ge = T(L.internalFormat, xe, se, L.colorSpace),
            ye = i.get(P),
            X = i.get(L);
          if (((X.__renderTarget = P), !ye.__hasExternalTextures)) {
            const le = Math.max(1, P.width >> G),
              ze = Math.max(1, P.height >> G);
            K === n.TEXTURE_3D || K === n.TEXTURE_2D_ARRAY
              ? t.texImage3D(K, G, ge, le, ze, P.depth, 0, xe, se, null)
              : t.texImage2D(K, G, ge, le, ze, 0, xe, se, null);
          }
          t.bindFramebuffer(n.FRAMEBUFFER, y),
            Ze(P)
              ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, j, K, X.__webglTexture, 0, ve(P))
              : (K === n.TEXTURE_2D || (K >= n.TEXTURE_CUBE_MAP_POSITIVE_X && K <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                n.framebufferTexture2D(n.FRAMEBUFFER, j, K, X.__webglTexture, G),
            t.bindFramebuffer(n.FRAMEBUFFER, null);
        }
        function tt(y, P, L) {
          if ((n.bindRenderbuffer(n.RENDERBUFFER, y), P.depthBuffer)) {
            const j = P.depthTexture,
              K = j && j.isDepthTexture ? j.type : null,
              G = _(P.stencilBuffer, K),
              xe = P.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
              se = ve(P);
            Ze(P)
              ? o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, se, G, P.width, P.height)
              : L
              ? n.renderbufferStorageMultisample(n.RENDERBUFFER, se, G, P.width, P.height)
              : n.renderbufferStorage(n.RENDERBUFFER, G, P.width, P.height),
              n.framebufferRenderbuffer(n.FRAMEBUFFER, xe, n.RENDERBUFFER, y);
          } else {
            const j = P.textures;
            for (let K = 0; K < j.length; K++) {
              const G = j[K],
                xe = r.convert(G.format, G.colorSpace),
                se = r.convert(G.type),
                ge = T(G.internalFormat, xe, se, G.colorSpace),
                ye = ve(P);
              L && Ze(P) === !1
                ? n.renderbufferStorageMultisample(n.RENDERBUFFER, ye, ge, P.width, P.height)
                : Ze(P)
                ? o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, ye, ge, P.width, P.height)
                : n.renderbufferStorage(n.RENDERBUFFER, ge, P.width, P.height);
            }
          }
          n.bindRenderbuffer(n.RENDERBUFFER, null);
        }
        function Re(y, P) {
          if (P && P.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
          if ((t.bindFramebuffer(n.FRAMEBUFFER, y), !(P.depthTexture && P.depthTexture.isDepthTexture)))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          const j = i.get(P.depthTexture);
          (j.__renderTarget = P),
            (!j.__webglTexture || P.depthTexture.image.width !== P.width || P.depthTexture.image.height !== P.height) &&
              ((P.depthTexture.image.width = P.width), (P.depthTexture.image.height = P.height), (P.depthTexture.needsUpdate = !0)),
            q(P.depthTexture, 0);
          const K = j.__webglTexture,
            G = ve(P);
          if (P.depthTexture.format === EA)
            Ze(P)
              ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, K, 0, G)
              : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, K, 0);
          else if (P.depthTexture.format === DA)
            Ze(P)
              ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, K, 0, G)
              : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, K, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function Et(y) {
          const P = i.get(y),
            L = y.isWebGLCubeRenderTarget === !0;
          if (P.__boundDepthTexture !== y.depthTexture) {
            const j = y.depthTexture;
            if ((P.__depthDisposeCallback && P.__depthDisposeCallback(), j)) {
              const K = () => {
                delete P.__boundDepthTexture, delete P.__depthDisposeCallback, j.removeEventListener("dispose", K);
              };
              j.addEventListener("dispose", K), (P.__depthDisposeCallback = K);
            }
            P.__boundDepthTexture = j;
          }
          if (y.depthTexture && !P.__autoAllocateDepthBuffer) {
            if (L) throw new Error("target.depthTexture not supported in Cube render targets");
            const j = y.texture.mipmaps;
            j && j.length > 0 ? Re(P.__webglFramebuffer[0], y) : Re(P.__webglFramebuffer, y);
          } else if (L) {
            P.__webglDepthbuffer = [];
            for (let j = 0; j < 6; j++)
              if ((t.bindFramebuffer(n.FRAMEBUFFER, P.__webglFramebuffer[j]), P.__webglDepthbuffer[j] === void 0))
                (P.__webglDepthbuffer[j] = n.createRenderbuffer()), tt(P.__webglDepthbuffer[j], y, !1);
              else {
                const K = y.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
                  G = P.__webglDepthbuffer[j];
                n.bindRenderbuffer(n.RENDERBUFFER, G), n.framebufferRenderbuffer(n.FRAMEBUFFER, K, n.RENDERBUFFER, G);
              }
          } else {
            const j = y.texture.mipmaps;
            if (
              (j && j.length > 0 ? t.bindFramebuffer(n.FRAMEBUFFER, P.__webglFramebuffer[0]) : t.bindFramebuffer(n.FRAMEBUFFER, P.__webglFramebuffer),
              P.__webglDepthbuffer === void 0)
            )
              (P.__webglDepthbuffer = n.createRenderbuffer()), tt(P.__webglDepthbuffer, y, !1);
            else {
              const K = y.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
                G = P.__webglDepthbuffer;
              n.bindRenderbuffer(n.RENDERBUFFER, G), n.framebufferRenderbuffer(n.FRAMEBUFFER, K, n.RENDERBUFFER, G);
            }
          }
          t.bindFramebuffer(n.FRAMEBUFFER, null);
        }
        function Dt(y, P, L) {
          const j = i.get(y);
          P !== void 0 && Ee(j.__webglFramebuffer, y, y.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), L !== void 0 && Et(y);
        }
        function nt(y) {
          const P = y.texture,
            L = i.get(y),
            j = i.get(P);
          y.addEventListener("dispose", D);
          const K = y.textures,
            G = y.isWebGLCubeRenderTarget === !0,
            xe = K.length > 1;
          if ((xe || (j.__webglTexture === void 0 && (j.__webglTexture = n.createTexture()), (j.__version = P.version), A.memory.textures++), G)) {
            L.__webglFramebuffer = [];
            for (let se = 0; se < 6; se++)
              if (P.mipmaps && P.mipmaps.length > 0) {
                L.__webglFramebuffer[se] = [];
                for (let ge = 0; ge < P.mipmaps.length; ge++) L.__webglFramebuffer[se][ge] = n.createFramebuffer();
              } else L.__webglFramebuffer[se] = n.createFramebuffer();
          } else {
            if (P.mipmaps && P.mipmaps.length > 0) {
              L.__webglFramebuffer = [];
              for (let se = 0; se < P.mipmaps.length; se++) L.__webglFramebuffer[se] = n.createFramebuffer();
            } else L.__webglFramebuffer = n.createFramebuffer();
            if (xe)
              for (let se = 0, ge = K.length; se < ge; se++) {
                const ye = i.get(K[se]);
                ye.__webglTexture === void 0 && ((ye.__webglTexture = n.createTexture()), A.memory.textures++);
              }
            if (y.samples > 0 && Ze(y) === !1) {
              (L.__webglMultisampledFramebuffer = n.createFramebuffer()),
                (L.__webglColorRenderbuffer = []),
                t.bindFramebuffer(n.FRAMEBUFFER, L.__webglMultisampledFramebuffer);
              for (let se = 0; se < K.length; se++) {
                const ge = K[se];
                (L.__webglColorRenderbuffer[se] = n.createRenderbuffer()), n.bindRenderbuffer(n.RENDERBUFFER, L.__webglColorRenderbuffer[se]);
                const ye = r.convert(ge.format, ge.colorSpace),
                  X = r.convert(ge.type),
                  le = T(ge.internalFormat, ye, X, ge.colorSpace, y.isXRRenderTarget === !0),
                  ze = ve(y);
                n.renderbufferStorageMultisample(n.RENDERBUFFER, ze, le, y.width, y.height),
                  n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + se, n.RENDERBUFFER, L.__webglColorRenderbuffer[se]);
              }
              n.bindRenderbuffer(n.RENDERBUFFER, null),
                y.depthBuffer && ((L.__webglDepthRenderbuffer = n.createRenderbuffer()), tt(L.__webglDepthRenderbuffer, y, !0)),
                t.bindFramebuffer(n.FRAMEBUFFER, null);
            }
          }
          if (G) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, j.__webglTexture), He(n.TEXTURE_CUBE_MAP, P);
            for (let se = 0; se < 6; se++)
              if (P.mipmaps && P.mipmaps.length > 0)
                for (let ge = 0; ge < P.mipmaps.length; ge++)
                  Ee(L.__webglFramebuffer[se][ge], y, P, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + se, ge);
              else Ee(L.__webglFramebuffer[se], y, P, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + se, 0);
            p(P) && f(n.TEXTURE_CUBE_MAP), t.unbindTexture();
          } else if (xe) {
            for (let se = 0, ge = K.length; se < ge; se++) {
              const ye = K[se],
                X = i.get(ye);
              t.bindTexture(n.TEXTURE_2D, X.__webglTexture),
                He(n.TEXTURE_2D, ye),
                Ee(L.__webglFramebuffer, y, ye, n.COLOR_ATTACHMENT0 + se, n.TEXTURE_2D, 0),
                p(ye) && f(n.TEXTURE_2D);
            }
            t.unbindTexture();
          } else {
            let se = n.TEXTURE_2D;
            if (
              ((y.isWebGL3DRenderTarget || y.isWebGLArrayRenderTarget) && (se = y.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
              t.bindTexture(se, j.__webglTexture),
              He(se, P),
              P.mipmaps && P.mipmaps.length > 0)
            )
              for (let ge = 0; ge < P.mipmaps.length; ge++) Ee(L.__webglFramebuffer[ge], y, P, n.COLOR_ATTACHMENT0, se, ge);
            else Ee(L.__webglFramebuffer, y, P, n.COLOR_ATTACHMENT0, se, 0);
            p(P) && f(se), t.unbindTexture();
          }
          y.depthBuffer && Et(y);
        }
        function M(y) {
          const P = y.textures;
          for (let L = 0, j = P.length; L < j; L++) {
            const K = P[L];
            if (p(K)) {
              const G = E(y),
                xe = i.get(K).__webglTexture;
              t.bindTexture(G, xe), f(G), t.unbindTexture();
            }
          }
        }
        const Zt = [],
          it = [];
        function pt(y) {
          if (y.samples > 0) {
            if (Ze(y) === !1) {
              const P = y.textures,
                L = y.width,
                j = y.height;
              let K = n.COLOR_BUFFER_BIT;
              const G = y.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
                xe = i.get(y),
                se = P.length > 1;
              if (se)
                for (let ye = 0; ye < P.length; ye++)
                  t.bindFramebuffer(n.FRAMEBUFFER, xe.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ye, n.RENDERBUFFER, null),
                    t.bindFramebuffer(n.FRAMEBUFFER, xe.__webglFramebuffer),
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ye, n.TEXTURE_2D, null, 0);
              t.bindFramebuffer(n.READ_FRAMEBUFFER, xe.__webglMultisampledFramebuffer);
              const ge = y.texture.mipmaps;
              ge && ge.length > 0
                ? t.bindFramebuffer(n.DRAW_FRAMEBUFFER, xe.__webglFramebuffer[0])
                : t.bindFramebuffer(n.DRAW_FRAMEBUFFER, xe.__webglFramebuffer);
              for (let ye = 0; ye < P.length; ye++) {
                if (
                  (y.resolveDepthBuffer &&
                    (y.depthBuffer && (K |= n.DEPTH_BUFFER_BIT), y.stencilBuffer && y.resolveStencilBuffer && (K |= n.STENCIL_BUFFER_BIT)),
                  se)
                ) {
                  n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, xe.__webglColorRenderbuffer[ye]);
                  const X = i.get(P[ye]).__webglTexture;
                  n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, X, 0);
                }
                n.blitFramebuffer(0, 0, L, j, 0, 0, L, j, K, n.NEAREST),
                  a === !0 &&
                    ((Zt.length = 0),
                    (it.length = 0),
                    Zt.push(n.COLOR_ATTACHMENT0 + ye),
                    y.depthBuffer && y.resolveDepthBuffer === !1 && (Zt.push(G), it.push(G), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, it)),
                    n.invalidateFramebuffer(n.READ_FRAMEBUFFER, Zt));
              }
              if ((t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), se))
                for (let ye = 0; ye < P.length; ye++) {
                  t.bindFramebuffer(n.FRAMEBUFFER, xe.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ye, n.RENDERBUFFER, xe.__webglColorRenderbuffer[ye]);
                  const X = i.get(P[ye]).__webglTexture;
                  t.bindFramebuffer(n.FRAMEBUFFER, xe.__webglFramebuffer),
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ye, n.TEXTURE_2D, X, 0);
                }
              t.bindFramebuffer(n.DRAW_FRAMEBUFFER, xe.__webglMultisampledFramebuffer);
            } else if (y.depthBuffer && y.resolveDepthBuffer === !1 && a) {
              const P = y.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
              n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [P]);
            }
          }
        }
        function ve(y) {
          return Math.min(s.maxSamples, y.samples);
        }
        function Ze(y) {
          const P = i.get(y);
          return y.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && P.__useRenderToTexture !== !1;
        }
        function Se(y) {
          const P = A.render.frame;
          l.get(y) !== P && (l.set(y, P), y.update());
        }
        function Ge(y, P) {
          const L = y.colorSpace,
            j = y.format,
            K = y.type;
          return (
            y.isCompressedTexture === !0 ||
              y.isVideoTexture === !0 ||
              (L !== on &&
                L !== $i &&
                (Xe.getTransfer(L) === ut
                  ? (j !== kn || K !== hi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.")
                  : console.error("THREE.WebGLTextures: Unsupported texture color space:", L))),
            P
          );
        }
        function kt(y) {
          return (
            typeof HTMLImageElement < "u" && y instanceof HTMLImageElement
              ? ((c.width = y.naturalWidth || y.width), (c.height = y.naturalHeight || y.height))
              : typeof VideoFrame < "u" && y instanceof VideoFrame
              ? ((c.width = y.displayWidth), (c.height = y.displayHeight))
              : ((c.width = y.width), (c.height = y.height)),
            c
          );
        }
        (this.allocateTextureUnit = N),
          (this.resetTextureUnits = H),
          (this.setTexture2D = q),
          (this.setTexture2DArray = V),
          (this.setTexture3D = J),
          (this.setTextureCube = k),
          (this.rebindTextures = Dt),
          (this.setupRenderTarget = nt),
          (this.updateRenderTargetMipmap = M),
          (this.updateMultisampleRenderTarget = pt),
          (this.setupDepthRenderbuffer = Et),
          (this.setupFrameBufferTexture = Ee),
          (this.useMultisampledRTT = Ze);
      }
      function ry(n, e) {
        function t(i, s = $i) {
          let r;
          const A = Xe.getTransfer(s);
          if (i === hi) return n.UNSIGNED_BYTE;
          if (i === Nu) return n.UNSIGNED_SHORT_4_4_4_4;
          if (i === ku) return n.UNSIGNED_SHORT_5_5_5_1;
          if (i === Vm) return n.UNSIGNED_INT_5_9_9_9_REV;
          if (i === Hm) return n.BYTE;
          if (i === Qm) return n.SHORT;
          if (i === yA) return n.UNSIGNED_SHORT;
          if (i === Fu) return n.INT;
          if (i === Us) return n.UNSIGNED_INT;
          if (i === Xn) return n.FLOAT;
          if (i === RA) return n.HALF_FLOAT;
          if (i === Wm) return n.ALPHA;
          if (i === Km) return n.RGB;
          if (i === kn) return n.RGBA;
          if (i === EA) return n.DEPTH_COMPONENT;
          if (i === DA) return n.DEPTH_STENCIL;
          if (i === Gu) return n.RED;
          if (i === ju) return n.RED_INTEGER;
          if (i === Ym) return n.RG;
          if (i === Hu) return n.RG_INTEGER;
          if (i === Qu) return n.RGBA_INTEGER;
          if (i === yo || i === To || i === Eo || i === Do)
            if (A === ut)
              if (((r = e.get("WEBGL_compressed_texture_s3tc_srgb")), r !== null)) {
                if (i === yo) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (i === To) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (i === Eo) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (i === Do) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else return null;
            else if (((r = e.get("WEBGL_compressed_texture_s3tc")), r !== null)) {
              if (i === yo) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (i === To) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (i === Eo) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (i === Do) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
          if (i === nl || i === il || i === sl || i === rl)
            if (((r = e.get("WEBGL_compressed_texture_pvrtc")), r !== null)) {
              if (i === nl) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (i === il) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (i === sl) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (i === rl) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
          if (i === Al || i === ol || i === al)
            if (((r = e.get("WEBGL_compressed_texture_etc")), r !== null)) {
              if (i === Al || i === ol) return A === ut ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
              if (i === al) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
          if (
            i === cl ||
            i === ll ||
            i === ul ||
            i === hl ||
            i === fl ||
            i === dl ||
            i === pl ||
            i === ml ||
            i === gl ||
            i === Pl ||
            i === vl ||
            i === wl ||
            i === _l ||
            i === xl
          )
            if (((r = e.get("WEBGL_compressed_texture_astc")), r !== null)) {
              if (i === cl) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (i === ll) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (i === ul) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (i === hl) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (i === fl) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (i === dl) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (i === pl) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (i === ml) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (i === gl) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (i === Pl) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (i === vl) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (i === wl) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (i === _l) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (i === xl) return A === ut ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
          if (i === Mo || i === yl || i === Tl)
            if (((r = e.get("EXT_texture_compression_bptc")), r !== null)) {
              if (i === Mo) return A === ut ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
              if (i === yl) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
              if (i === Tl) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            } else return null;
          if (i === qm || i === El || i === Dl || i === Ml)
            if (((r = e.get("EXT_texture_compression_rgtc")), r !== null)) {
              if (i === Mo) return r.COMPRESSED_RED_RGTC1_EXT;
              if (i === El) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
              if (i === Dl) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
              if (i === Ml) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            } else return null;
          return i === TA ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null;
        }
        return { convert: t };
      }
      const Ay = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
        oy = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
      class ay {
        constructor() {
          (this.texture = null), (this.mesh = null), (this.depthNear = 0), (this.depthFar = 0);
        }
        init(e, t, i) {
          if (this.texture === null) {
            const s = new Kt(),
              r = e.properties.get(s);
            (r.__webglTexture = t.texture),
              (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) && ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
              (this.texture = s);
          }
        }
        getMesh(e) {
          if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport,
              i = new cs({
                vertexShader: Ay,
                fragmentShader: oy,
                uniforms: { depthColor: { value: this.texture }, depthWidth: { value: t.z }, depthHeight: { value: t.w } },
              });
            this.mesh = new En(new _a(20, 20), i);
          }
          return this.mesh;
        }
        reset() {
          (this.texture = null), (this.mesh = null);
        }
        getDepthTexture() {
          return this.texture;
        }
      }
      class cy extends Hr {
        constructor(e, t) {
          super();
          const i = this;
          let s = null,
            r = 1,
            A = null,
            o = "local-floor",
            a = 1,
            c = null,
            l = null,
            u = null,
            h = null,
            d = null,
            m = null;
          const g = new ay(),
            p = t.getContextAttributes();
          let f = null,
            E = null;
          const T = [],
            _ = [],
            b = new qe();
          let S = null;
          const D = new nn();
          D.viewport = new st();
          const O = new nn();
          O.viewport = new st();
          const x = [D, O],
            w = new _w();
          let I = null,
            H = null;
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (Q) {
              let te = T[Q];
              return te === void 0 && ((te = new Ac()), (T[Q] = te)), te.getTargetRaySpace();
            }),
            (this.getControllerGrip = function (Q) {
              let te = T[Q];
              return te === void 0 && ((te = new Ac()), (T[Q] = te)), te.getGripSpace();
            }),
            (this.getHand = function (Q) {
              let te = T[Q];
              return te === void 0 && ((te = new Ac()), (T[Q] = te)), te.getHandSpace();
            });
          function N(Q) {
            const te = _.indexOf(Q.inputSource);
            if (te === -1) return;
            const Te = T[te];
            Te !== void 0 && (Te.update(Q.inputSource, Q.frame, c || A), Te.dispatchEvent({ type: Q.type, data: Q.inputSource }));
          }
          function Y() {
            s.removeEventListener("select", N),
              s.removeEventListener("selectstart", N),
              s.removeEventListener("selectend", N),
              s.removeEventListener("squeeze", N),
              s.removeEventListener("squeezestart", N),
              s.removeEventListener("squeezeend", N),
              s.removeEventListener("end", Y),
              s.removeEventListener("inputsourceschange", q);
            for (let Q = 0; Q < T.length; Q++) {
              const te = _[Q];
              te !== null && ((_[Q] = null), T[Q].disconnect(te));
            }
            (I = null),
              (H = null),
              g.reset(),
              e.setRenderTarget(f),
              (d = null),
              (h = null),
              (u = null),
              (s = null),
              (E = null),
              ht.stop(),
              (i.isPresenting = !1),
              e.setPixelRatio(S),
              e.setSize(b.width, b.height, !1),
              i.dispatchEvent({ type: "sessionend" });
          }
          (this.setFramebufferScaleFactor = function (Q) {
            (r = Q), i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }),
            (this.setReferenceSpaceType = function (Q) {
              (o = Q), i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }),
            (this.getReferenceSpace = function () {
              return c || A;
            }),
            (this.setReferenceSpace = function (Q) {
              c = Q;
            }),
            (this.getBaseLayer = function () {
              return h !== null ? h : d;
            }),
            (this.getBinding = function () {
              return u;
            }),
            (this.getFrame = function () {
              return m;
            }),
            (this.getSession = function () {
              return s;
            }),
            (this.setSession = async function (Q) {
              if (((s = Q), s !== null)) {
                if (
                  ((f = e.getRenderTarget()),
                  s.addEventListener("select", N),
                  s.addEventListener("selectstart", N),
                  s.addEventListener("selectend", N),
                  s.addEventListener("squeeze", N),
                  s.addEventListener("squeezestart", N),
                  s.addEventListener("squeezeend", N),
                  s.addEventListener("end", Y),
                  s.addEventListener("inputsourceschange", q),
                  p.xrCompatible !== !0 && (await t.makeXRCompatible()),
                  (S = e.getPixelRatio()),
                  e.getSize(b),
                  typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype)
                ) {
                  let Te = null,
                    ae = null,
                    Ee = null;
                  p.depth && ((Ee = p.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24), (Te = p.stencil ? DA : EA), (ae = p.stencil ? TA : Us));
                  const tt = { colorFormat: t.RGBA8, depthFormat: Ee, scaleFactor: r };
                  (u = new XRWebGLBinding(s, t)),
                    (h = u.createProjectionLayer(tt)),
                    s.updateRenderState({ layers: [h] }),
                    e.setPixelRatio(1),
                    e.setSize(h.textureWidth, h.textureHeight, !1),
                    (E = new Fs(h.textureWidth, h.textureHeight, {
                      format: kn,
                      type: hi,
                      depthTexture: new hg(h.textureWidth, h.textureHeight, ae, void 0, void 0, void 0, void 0, void 0, void 0, Te),
                      stencilBuffer: p.stencil,
                      colorSpace: e.outputColorSpace,
                      samples: p.antialias ? 4 : 0,
                      resolveDepthBuffer: h.ignoreDepthValues === !1,
                      resolveStencilBuffer: h.ignoreDepthValues === !1,
                    }));
                } else {
                  const Te = { antialias: p.antialias, alpha: !0, depth: p.depth, stencil: p.stencil, framebufferScaleFactor: r };
                  (d = new XRWebGLLayer(s, t, Te)),
                    s.updateRenderState({ baseLayer: d }),
                    e.setPixelRatio(1),
                    e.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                    (E = new Fs(d.framebufferWidth, d.framebufferHeight, {
                      format: kn,
                      type: hi,
                      colorSpace: e.outputColorSpace,
                      stencilBuffer: p.stencil,
                      resolveDepthBuffer: d.ignoreDepthValues === !1,
                      resolveStencilBuffer: d.ignoreDepthValues === !1,
                    }));
                }
                (E.isXRRenderTarget = !0),
                  this.setFoveation(a),
                  (c = null),
                  (A = await s.requestReferenceSpace(o)),
                  ht.setContext(s),
                  ht.start(),
                  (i.isPresenting = !0),
                  i.dispatchEvent({ type: "sessionstart" });
              }
            }),
            (this.getEnvironmentBlendMode = function () {
              if (s !== null) return s.environmentBlendMode;
            }),
            (this.getDepthTexture = function () {
              return g.getDepthTexture();
            });
          function q(Q) {
            for (let te = 0; te < Q.removed.length; te++) {
              const Te = Q.removed[te],
                ae = _.indexOf(Te);
              ae >= 0 && ((_[ae] = null), T[ae].disconnect(Te));
            }
            for (let te = 0; te < Q.added.length; te++) {
              const Te = Q.added[te];
              let ae = _.indexOf(Te);
              if (ae === -1) {
                for (let tt = 0; tt < T.length; tt++)
                  if (tt >= _.length) {
                    _.push(Te), (ae = tt);
                    break;
                  } else if (_[tt] === null) {
                    (_[tt] = Te), (ae = tt);
                    break;
                  }
                if (ae === -1) break;
              }
              const Ee = T[ae];
              Ee && Ee.connect(Te);
            }
          }
          const V = new R(),
            J = new R();
          function k(Q, te, Te) {
            V.setFromMatrixPosition(te.matrixWorld), J.setFromMatrixPosition(Te.matrixWorld);
            const ae = V.distanceTo(J),
              Ee = te.projectionMatrix.elements,
              tt = Te.projectionMatrix.elements,
              Re = Ee[14] / (Ee[10] - 1),
              Et = Ee[14] / (Ee[10] + 1),
              Dt = (Ee[9] + 1) / Ee[5],
              nt = (Ee[9] - 1) / Ee[5],
              M = (Ee[8] - 1) / Ee[0],
              Zt = (tt[8] + 1) / tt[0],
              it = Re * M,
              pt = Re * Zt,
              ve = ae / (-M + Zt),
              Ze = ve * -M;
            if (
              (te.matrixWorld.decompose(Q.position, Q.quaternion, Q.scale),
              Q.translateX(Ze),
              Q.translateZ(ve),
              Q.matrixWorld.compose(Q.position, Q.quaternion, Q.scale),
              Q.matrixWorldInverse.copy(Q.matrixWorld).invert(),
              Ee[10] === -1)
            )
              Q.projectionMatrix.copy(te.projectionMatrix), Q.projectionMatrixInverse.copy(te.projectionMatrixInverse);
            else {
              const Se = Re + ve,
                Ge = Et + ve,
                kt = it - Ze,
                y = pt + (ae - Ze),
                P = ((Dt * Et) / Ge) * Se,
                L = ((nt * Et) / Ge) * Se;
              Q.projectionMatrix.makePerspective(kt, y, P, L, Se, Ge), Q.projectionMatrixInverse.copy(Q.projectionMatrix).invert();
            }
          }
          function oe(Q, te) {
            te === null ? Q.matrixWorld.copy(Q.matrix) : Q.matrixWorld.multiplyMatrices(te.matrixWorld, Q.matrix),
              Q.matrixWorldInverse.copy(Q.matrixWorld).invert();
          }
          this.updateCamera = function (Q) {
            if (s === null) return;
            let te = Q.near,
              Te = Q.far;
            g.texture !== null && (g.depthNear > 0 && (te = g.depthNear), g.depthFar > 0 && (Te = g.depthFar)),
              (w.near = O.near = D.near = te),
              (w.far = O.far = D.far = Te),
              (I !== w.near || H !== w.far) && (s.updateRenderState({ depthNear: w.near, depthFar: w.far }), (I = w.near), (H = w.far)),
              (D.layers.mask = Q.layers.mask | 2),
              (O.layers.mask = Q.layers.mask | 4),
              (w.layers.mask = D.layers.mask | O.layers.mask);
            const ae = Q.parent,
              Ee = w.cameras;
            oe(w, ae);
            for (let tt = 0; tt < Ee.length; tt++) oe(Ee[tt], ae);
            Ee.length === 2 ? k(w, D, O) : w.projectionMatrix.copy(D.projectionMatrix), he(Q, w, ae);
          };
          function he(Q, te, Te) {
            Te === null ? Q.matrix.copy(te.matrixWorld) : (Q.matrix.copy(Te.matrixWorld), Q.matrix.invert(), Q.matrix.multiply(te.matrixWorld)),
              Q.matrix.decompose(Q.position, Q.quaternion, Q.scale),
              Q.updateMatrixWorld(!0),
              Q.projectionMatrix.copy(te.projectionMatrix),
              Q.projectionMatrixInverse.copy(te.projectionMatrixInverse),
              Q.isPerspectiveCamera && ((Q.fov = Sr * 2 * Math.atan(1 / Q.projectionMatrix.elements[5])), (Q.zoom = 1));
          }
          (this.getCamera = function () {
            return w;
          }),
            (this.getFoveation = function () {
              if (!(h === null && d === null)) return a;
            }),
            (this.setFoveation = function (Q) {
              (a = Q), h !== null && (h.fixedFoveation = Q), d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = Q);
            }),
            (this.hasDepthSensing = function () {
              return g.texture !== null;
            }),
            (this.getDepthSensingMesh = function () {
              return g.getMesh(w);
            });
          let Me = null;
          function He(Q, te) {
            if (((l = te.getViewerPose(c || A)), (m = te), l !== null)) {
              const Te = l.views;
              d !== null && (e.setRenderTargetFramebuffer(E, d.framebuffer), e.setRenderTarget(E));
              let ae = !1;
              Te.length !== w.cameras.length && ((w.cameras.length = 0), (ae = !0));
              for (let Re = 0; Re < Te.length; Re++) {
                const Et = Te[Re];
                let Dt = null;
                if (d !== null) Dt = d.getViewport(Et);
                else {
                  const M = u.getViewSubImage(h, Et);
                  (Dt = M.viewport), Re === 0 && (e.setRenderTargetTextures(E, M.colorTexture, M.depthStencilTexture), e.setRenderTarget(E));
                }
                let nt = x[Re];
                nt === void 0 && ((nt = new nn()), nt.layers.enable(Re), (nt.viewport = new st()), (x[Re] = nt)),
                  nt.matrix.fromArray(Et.transform.matrix),
                  nt.matrix.decompose(nt.position, nt.quaternion, nt.scale),
                  nt.projectionMatrix.fromArray(Et.projectionMatrix),
                  nt.projectionMatrixInverse.copy(nt.projectionMatrix).invert(),
                  nt.viewport.set(Dt.x, Dt.y, Dt.width, Dt.height),
                  Re === 0 && (w.matrix.copy(nt.matrix), w.matrix.decompose(w.position, w.quaternion, w.scale)),
                  ae === !0 && w.cameras.push(nt);
              }
              const Ee = s.enabledFeatures;
              if (Ee && Ee.includes("depth-sensing") && s.depthUsage == "gpu-optimized" && u) {
                const Re = u.getDepthInformation(Te[0]);
                Re && Re.isValid && Re.texture && g.init(e, Re, s.renderState);
              }
            }
            for (let Te = 0; Te < T.length; Te++) {
              const ae = _[Te],
                Ee = T[Te];
              ae !== null && Ee !== void 0 && Ee.update(ae, te, c || A);
            }
            Me && Me(Q, te), te.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: te }), (m = null);
          }
          const ht = new gg();
          ht.setAnimationLoop(He),
            (this.setAnimationLoop = function (Q) {
              Me = Q;
            }),
            (this.dispose = function () {});
        }
      }
      const xs = new fi(),
        ly = new ke();
      function uy(n, e) {
        function t(p, f) {
          p.matrixAutoUpdate === !0 && p.updateMatrix(), f.value.copy(p.matrix);
        }
        function i(p, f) {
          f.color.getRGB(p.fogColor.value, rg(n)),
            f.isFog ? ((p.fogNear.value = f.near), (p.fogFar.value = f.far)) : f.isFogExp2 && (p.fogDensity.value = f.density);
        }
        function s(p, f, E, T, _) {
          f.isMeshBasicMaterial || f.isMeshLambertMaterial
            ? r(p, f)
            : f.isMeshToonMaterial
            ? (r(p, f), u(p, f))
            : f.isMeshPhongMaterial
            ? (r(p, f), l(p, f))
            : f.isMeshStandardMaterial
            ? (r(p, f), h(p, f), f.isMeshPhysicalMaterial && d(p, f, _))
            : f.isMeshMatcapMaterial
            ? (r(p, f), m(p, f))
            : f.isMeshDepthMaterial
            ? r(p, f)
            : f.isMeshDistanceMaterial
            ? (r(p, f), g(p, f))
            : f.isMeshNormalMaterial
            ? r(p, f)
            : f.isLineBasicMaterial
            ? (A(p, f), f.isLineDashedMaterial && o(p, f))
            : f.isPointsMaterial
            ? a(p, f, E, T)
            : f.isSpriteMaterial
            ? c(p, f)
            : f.isShadowMaterial
            ? (p.color.value.copy(f.color), (p.opacity.value = f.opacity))
            : f.isShaderMaterial && (f.uniformsNeedUpdate = !1);
        }
        function r(p, f) {
          (p.opacity.value = f.opacity),
            f.color && p.diffuse.value.copy(f.color),
            f.emissive && p.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity),
            f.map && ((p.map.value = f.map), t(f.map, p.mapTransform)),
            f.alphaMap && ((p.alphaMap.value = f.alphaMap), t(f.alphaMap, p.alphaMapTransform)),
            f.bumpMap &&
              ((p.bumpMap.value = f.bumpMap), t(f.bumpMap, p.bumpMapTransform), (p.bumpScale.value = f.bumpScale), f.side === fn && (p.bumpScale.value *= -1)),
            f.normalMap &&
              ((p.normalMap.value = f.normalMap),
              t(f.normalMap, p.normalMapTransform),
              p.normalScale.value.copy(f.normalScale),
              f.side === fn && p.normalScale.value.negate()),
            f.displacementMap &&
              ((p.displacementMap.value = f.displacementMap),
              t(f.displacementMap, p.displacementMapTransform),
              (p.displacementScale.value = f.displacementScale),
              (p.displacementBias.value = f.displacementBias)),
            f.emissiveMap && ((p.emissiveMap.value = f.emissiveMap), t(f.emissiveMap, p.emissiveMapTransform)),
            f.specularMap && ((p.specularMap.value = f.specularMap), t(f.specularMap, p.specularMapTransform)),
            f.alphaTest > 0 && (p.alphaTest.value = f.alphaTest);
          const E = e.get(f),
            T = E.envMap,
            _ = E.envMapRotation;
          T &&
            ((p.envMap.value = T),
            xs.copy(_),
            (xs.x *= -1),
            (xs.y *= -1),
            (xs.z *= -1),
            T.isCubeTexture && T.isRenderTargetTexture === !1 && ((xs.y *= -1), (xs.z *= -1)),
            p.envMapRotation.value.setFromMatrix4(ly.makeRotationFromEuler(xs)),
            (p.flipEnvMap.value = T.isCubeTexture && T.isRenderTargetTexture === !1 ? -1 : 1),
            (p.reflectivity.value = f.reflectivity),
            (p.ior.value = f.ior),
            (p.refractionRatio.value = f.refractionRatio)),
            f.lightMap && ((p.lightMap.value = f.lightMap), (p.lightMapIntensity.value = f.lightMapIntensity), t(f.lightMap, p.lightMapTransform)),
            f.aoMap && ((p.aoMap.value = f.aoMap), (p.aoMapIntensity.value = f.aoMapIntensity), t(f.aoMap, p.aoMapTransform));
        }
        function A(p, f) {
          p.diffuse.value.copy(f.color), (p.opacity.value = f.opacity), f.map && ((p.map.value = f.map), t(f.map, p.mapTransform));
        }
        function o(p, f) {
          (p.dashSize.value = f.dashSize), (p.totalSize.value = f.dashSize + f.gapSize), (p.scale.value = f.scale);
        }
        function a(p, f, E, T) {
          p.diffuse.value.copy(f.color),
            (p.opacity.value = f.opacity),
            (p.size.value = f.size * E),
            (p.scale.value = T * 0.5),
            f.map && ((p.map.value = f.map), t(f.map, p.uvTransform)),
            f.alphaMap && ((p.alphaMap.value = f.alphaMap), t(f.alphaMap, p.alphaMapTransform)),
            f.alphaTest > 0 && (p.alphaTest.value = f.alphaTest);
        }
        function c(p, f) {
          p.diffuse.value.copy(f.color),
            (p.opacity.value = f.opacity),
            (p.rotation.value = f.rotation),
            f.map && ((p.map.value = f.map), t(f.map, p.mapTransform)),
            f.alphaMap && ((p.alphaMap.value = f.alphaMap), t(f.alphaMap, p.alphaMapTransform)),
            f.alphaTest > 0 && (p.alphaTest.value = f.alphaTest);
        }
        function l(p, f) {
          p.specular.value.copy(f.specular), (p.shininess.value = Math.max(f.shininess, 1e-4));
        }
        function u(p, f) {
          f.gradientMap && (p.gradientMap.value = f.gradientMap);
        }
        function h(p, f) {
          (p.metalness.value = f.metalness),
            f.metalnessMap && ((p.metalnessMap.value = f.metalnessMap), t(f.metalnessMap, p.metalnessMapTransform)),
            (p.roughness.value = f.roughness),
            f.roughnessMap && ((p.roughnessMap.value = f.roughnessMap), t(f.roughnessMap, p.roughnessMapTransform)),
            f.envMap && (p.envMapIntensity.value = f.envMapIntensity);
        }
        function d(p, f, E) {
          (p.ior.value = f.ior),
            f.sheen > 0 &&
              (p.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen),
              (p.sheenRoughness.value = f.sheenRoughness),
              f.sheenColorMap && ((p.sheenColorMap.value = f.sheenColorMap), t(f.sheenColorMap, p.sheenColorMapTransform)),
              f.sheenRoughnessMap && ((p.sheenRoughnessMap.value = f.sheenRoughnessMap), t(f.sheenRoughnessMap, p.sheenRoughnessMapTransform))),
            f.clearcoat > 0 &&
              ((p.clearcoat.value = f.clearcoat),
              (p.clearcoatRoughness.value = f.clearcoatRoughness),
              f.clearcoatMap && ((p.clearcoatMap.value = f.clearcoatMap), t(f.clearcoatMap, p.clearcoatMapTransform)),
              f.clearcoatRoughnessMap &&
                ((p.clearcoatRoughnessMap.value = f.clearcoatRoughnessMap), t(f.clearcoatRoughnessMap, p.clearcoatRoughnessMapTransform)),
              f.clearcoatNormalMap &&
                ((p.clearcoatNormalMap.value = f.clearcoatNormalMap),
                t(f.clearcoatNormalMap, p.clearcoatNormalMapTransform),
                p.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),
                f.side === fn && p.clearcoatNormalScale.value.negate())),
            f.dispersion > 0 && (p.dispersion.value = f.dispersion),
            f.iridescence > 0 &&
              ((p.iridescence.value = f.iridescence),
              (p.iridescenceIOR.value = f.iridescenceIOR),
              (p.iridescenceThicknessMinimum.value = f.iridescenceThicknessRange[0]),
              (p.iridescenceThicknessMaximum.value = f.iridescenceThicknessRange[1]),
              f.iridescenceMap && ((p.iridescenceMap.value = f.iridescenceMap), t(f.iridescenceMap, p.iridescenceMapTransform)),
              f.iridescenceThicknessMap &&
                ((p.iridescenceThicknessMap.value = f.iridescenceThicknessMap), t(f.iridescenceThicknessMap, p.iridescenceThicknessMapTransform))),
            f.transmission > 0 &&
              ((p.transmission.value = f.transmission),
              (p.transmissionSamplerMap.value = E.texture),
              p.transmissionSamplerSize.value.set(E.width, E.height),
              f.transmissionMap && ((p.transmissionMap.value = f.transmissionMap), t(f.transmissionMap, p.transmissionMapTransform)),
              (p.thickness.value = f.thickness),
              f.thicknessMap && ((p.thicknessMap.value = f.thicknessMap), t(f.thicknessMap, p.thicknessMapTransform)),
              (p.attenuationDistance.value = f.attenuationDistance),
              p.attenuationColor.value.copy(f.attenuationColor)),
            f.anisotropy > 0 &&
              (p.anisotropyVector.value.set(f.anisotropy * Math.cos(f.anisotropyRotation), f.anisotropy * Math.sin(f.anisotropyRotation)),
              f.anisotropyMap && ((p.anisotropyMap.value = f.anisotropyMap), t(f.anisotropyMap, p.anisotropyMapTransform))),
            (p.specularIntensity.value = f.specularIntensity),
            p.specularColor.value.copy(f.specularColor),
            f.specularColorMap && ((p.specularColorMap.value = f.specularColorMap), t(f.specularColorMap, p.specularColorMapTransform)),
            f.specularIntensityMap && ((p.specularIntensityMap.value = f.specularIntensityMap), t(f.specularIntensityMap, p.specularIntensityMapTransform));
        }
        function m(p, f) {
          f.matcap && (p.matcap.value = f.matcap);
        }
        function g(p, f) {
          const E = e.get(f).light;
          p.referencePosition.value.setFromMatrixPosition(E.matrixWorld),
            (p.nearDistance.value = E.shadow.camera.near),
            (p.farDistance.value = E.shadow.camera.far);
        }
        return { refreshFogUniforms: i, refreshMaterialUniforms: s };
      }
      function hy(n, e, t, i) {
        let s = {},
          r = {},
          A = [];
        const o = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
        function a(E, T) {
          const _ = T.program;
          i.uniformBlockBinding(E, _);
        }
        function c(E, T) {
          let _ = s[E.id];
          _ === void 0 && (m(E), (_ = l(E)), (s[E.id] = _), E.addEventListener("dispose", p));
          const b = T.program;
          i.updateUBOMapping(E, b);
          const S = e.render.frame;
          r[E.id] !== S && (h(E), (r[E.id] = S));
        }
        function l(E) {
          const T = u();
          E.__bindingPointIndex = T;
          const _ = n.createBuffer(),
            b = E.__size,
            S = E.usage;
          return (
            n.bindBuffer(n.UNIFORM_BUFFER, _),
            n.bufferData(n.UNIFORM_BUFFER, b, S),
            n.bindBuffer(n.UNIFORM_BUFFER, null),
            n.bindBufferBase(n.UNIFORM_BUFFER, T, _),
            _
          );
        }
        function u() {
          for (let E = 0; E < o; E++) if (A.indexOf(E) === -1) return A.push(E), E;
          return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }
        function h(E) {
          const T = s[E.id],
            _ = E.uniforms,
            b = E.__cache;
          n.bindBuffer(n.UNIFORM_BUFFER, T);
          for (let S = 0, D = _.length; S < D; S++) {
            const O = Array.isArray(_[S]) ? _[S] : [_[S]];
            for (let x = 0, w = O.length; x < w; x++) {
              const I = O[x];
              if (d(I, S, x, b) === !0) {
                const H = I.__offset,
                  N = Array.isArray(I.value) ? I.value : [I.value];
                let Y = 0;
                for (let q = 0; q < N.length; q++) {
                  const V = N[q],
                    J = g(V);
                  typeof V == "number" || typeof V == "boolean"
                    ? ((I.__data[0] = V), n.bufferSubData(n.UNIFORM_BUFFER, H + Y, I.__data))
                    : V.isMatrix3
                    ? ((I.__data[0] = V.elements[0]),
                      (I.__data[1] = V.elements[1]),
                      (I.__data[2] = V.elements[2]),
                      (I.__data[3] = 0),
                      (I.__data[4] = V.elements[3]),
                      (I.__data[5] = V.elements[4]),
                      (I.__data[6] = V.elements[5]),
                      (I.__data[7] = 0),
                      (I.__data[8] = V.elements[6]),
                      (I.__data[9] = V.elements[7]),
                      (I.__data[10] = V.elements[8]),
                      (I.__data[11] = 0))
                    : (V.toArray(I.__data, Y), (Y += J.storage / Float32Array.BYTES_PER_ELEMENT));
                }
                n.bufferSubData(n.UNIFORM_BUFFER, H, I.__data);
              }
            }
          }
          n.bindBuffer(n.UNIFORM_BUFFER, null);
        }
        function d(E, T, _, b) {
          const S = E.value,
            D = T + "_" + _;
          if (b[D] === void 0) return typeof S == "number" || typeof S == "boolean" ? (b[D] = S) : (b[D] = S.clone()), !0;
          {
            const O = b[D];
            if (typeof S == "number" || typeof S == "boolean") {
              if (O !== S) return (b[D] = S), !0;
            } else if (O.equals(S) === !1) return O.copy(S), !0;
          }
          return !1;
        }
        function m(E) {
          const T = E.uniforms;
          let _ = 0;
          const b = 16;
          for (let D = 0, O = T.length; D < O; D++) {
            const x = Array.isArray(T[D]) ? T[D] : [T[D]];
            for (let w = 0, I = x.length; w < I; w++) {
              const H = x[w],
                N = Array.isArray(H.value) ? H.value : [H.value];
              for (let Y = 0, q = N.length; Y < q; Y++) {
                const V = N[Y],
                  J = g(V),
                  k = _ % b,
                  oe = k % J.boundary,
                  he = k + oe;
                (_ += oe),
                  he !== 0 && b - he < J.storage && (_ += b - he),
                  (H.__data = new Float32Array(J.storage / Float32Array.BYTES_PER_ELEMENT)),
                  (H.__offset = _),
                  (_ += J.storage);
              }
            }
          }
          const S = _ % b;
          return S > 0 && (_ += b - S), (E.__size = _), (E.__cache = {}), this;
        }
        function g(E) {
          const T = { boundary: 0, storage: 0 };
          return (
            typeof E == "number" || typeof E == "boolean"
              ? ((T.boundary = 4), (T.storage = 4))
              : E.isVector2
              ? ((T.boundary = 8), (T.storage = 8))
              : E.isVector3 || E.isColor
              ? ((T.boundary = 16), (T.storage = 12))
              : E.isVector4
              ? ((T.boundary = 16), (T.storage = 16))
              : E.isMatrix3
              ? ((T.boundary = 48), (T.storage = 48))
              : E.isMatrix4
              ? ((T.boundary = 64), (T.storage = 64))
              : E.isTexture
              ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.")
              : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", E),
            T
          );
        }
        function p(E) {
          const T = E.target;
          T.removeEventListener("dispose", p);
          const _ = A.indexOf(T.__bindingPointIndex);
          A.splice(_, 1), n.deleteBuffer(s[T.id]), delete s[T.id], delete r[T.id];
        }
        function f() {
          for (const E in s) n.deleteBuffer(s[E]);
          (A = []), (s = {}), (r = {});
        }
        return { bind: a, update: c, dispose: f };
      }
      class fy {
        constructor(e = {}) {
          const {
            canvas: t = uv(),
            context: i = null,
            depth: s = !0,
            stencil: r = !1,
            alpha: A = !1,
            antialias: o = !1,
            premultipliedAlpha: a = !0,
            preserveDrawingBuffer: c = !1,
            powerPreference: l = "default",
            failIfMajorPerformanceCaveat: u = !1,
            reverseDepthBuffer: h = !1,
          } = e;
          this.isWebGLRenderer = !0;
          let d;
          if (i !== null) {
            if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext)
              throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            d = i.getContextAttributes().alpha;
          } else d = A;
          const m = new Uint32Array(4),
            g = new Int32Array(4);
          let p = null,
            f = null;
          const E = [],
            T = [];
          (this.domElement = t),
            (this.debug = { checkShaderErrors: !0, onShaderError: null }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this.toneMapping = As),
            (this.toneMappingExposure = 1),
            (this.transmissionResolutionScale = 1);
          const _ = this;
          let b = !1;
          this._outputColorSpace = Yt;
          let S = 0,
            D = 0,
            O = null,
            x = -1,
            w = null;
          const I = new st(),
            H = new st();
          let N = null;
          const Y = new Ue(0);
          let q = 0,
            V = t.width,
            J = t.height,
            k = 1,
            oe = null,
            he = null;
          const Me = new st(0, 0, V, J),
            He = new st(0, 0, V, J);
          let ht = !1;
          const Q = new qu();
          let te = !1,
            Te = !1;
          const ae = new ke(),
            Ee = new ke(),
            tt = new R(),
            Re = new st(),
            Et = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
          let Dt = !1;
          function nt() {
            return O === null ? k : 1;
          }
          let M = i;
          function Zt(v, z) {
            return t.getContext(v, z);
          }
          try {
            const v = {
              alpha: !0,
              depth: s,
              stencil: r,
              antialias: o,
              premultipliedAlpha: a,
              preserveDrawingBuffer: c,
              powerPreference: l,
              failIfMajorPerformanceCaveat: u,
            };
            if (
              ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Uu}`),
              t.addEventListener("webglcontextlost", fe, !1),
              t.addEventListener("webglcontextrestored", $, !1),
              t.addEventListener("webglcontextcreationerror", W, !1),
              M === null)
            ) {
              const z = "webgl2";
              if (((M = Zt(z, v)), M === null))
                throw Zt(z) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            }
          } catch (v) {
            throw (console.error("THREE.WebGLRenderer: " + v.message), v);
          }
          let it, pt, ve, Ze, Se, Ge, kt, y, P, L, j, K, G, xe, se, ge, ye, X, le, ze, be, ne, Le, C;
          function re() {
            (it = new y_(M)),
              it.init(),
              (ne = new ry(M, it)),
              (pt = new m_(M, it, e, ne)),
              (ve = new iy(M, it)),
              pt.reverseDepthBuffer && h && ve.buffers.depth.setReversed(!0),
              (Ze = new D_(M)),
              (Se = new Qx()),
              (Ge = new sy(M, it, ve, Se, pt, ne, Ze)),
              (kt = new P_(_)),
              (y = new x_(_)),
              (P = new zw(M)),
              (Le = new d_(M, P)),
              (L = new T_(M, P, Ze, Le)),
              (j = new C_(M, L, P, Ze)),
              (le = new M_(M, pt, Ge)),
              (ge = new g_(Se)),
              (K = new Hx(_, kt, y, it, pt, Le, ge)),
              (G = new uy(_, Se)),
              (xe = new Wx()),
              (se = new Zx(it)),
              (X = new f_(_, kt, y, ve, j, d, a)),
              (ye = new ty(_, j, pt)),
              (C = new hy(M, Ze, pt, ve)),
              (ze = new p_(M, it, Ze)),
              (be = new E_(M, it, Ze)),
              (Ze.programs = K.programs),
              (_.capabilities = pt),
              (_.extensions = it),
              (_.properties = Se),
              (_.renderLists = xe),
              (_.shadowMap = ye),
              (_.state = ve),
              (_.info = Ze);
          }
          re();
          const Z = new cy(_, M);
          (this.xr = Z),
            (this.getContext = function () {
              return M;
            }),
            (this.getContextAttributes = function () {
              return M.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const v = it.get("WEBGL_lose_context");
              v && v.loseContext();
            }),
            (this.forceContextRestore = function () {
              const v = it.get("WEBGL_lose_context");
              v && v.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return k;
            }),
            (this.setPixelRatio = function (v) {
              v !== void 0 && ((k = v), this.setSize(V, J, !1));
            }),
            (this.getSize = function (v) {
              return v.set(V, J);
            }),
            (this.setSize = function (v, z, U = !0) {
              if (Z.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return;
              }
              (V = v),
                (J = z),
                (t.width = Math.floor(v * k)),
                (t.height = Math.floor(z * k)),
                U === !0 && ((t.style.width = v + "px"), (t.style.height = z + "px")),
                this.setViewport(0, 0, v, z);
            }),
            (this.getDrawingBufferSize = function (v) {
              return v.set(V * k, J * k).floor();
            }),
            (this.setDrawingBufferSize = function (v, z, U) {
              (V = v), (J = z), (k = U), (t.width = Math.floor(v * U)), (t.height = Math.floor(z * U)), this.setViewport(0, 0, v, z);
            }),
            (this.getCurrentViewport = function (v) {
              return v.copy(I);
            }),
            (this.getViewport = function (v) {
              return v.copy(Me);
            }),
            (this.setViewport = function (v, z, U, F) {
              v.isVector4 ? Me.set(v.x, v.y, v.z, v.w) : Me.set(v, z, U, F), ve.viewport(I.copy(Me).multiplyScalar(k).round());
            }),
            (this.getScissor = function (v) {
              return v.copy(He);
            }),
            (this.setScissor = function (v, z, U, F) {
              v.isVector4 ? He.set(v.x, v.y, v.z, v.w) : He.set(v, z, U, F), ve.scissor(H.copy(He).multiplyScalar(k).round());
            }),
            (this.getScissorTest = function () {
              return ht;
            }),
            (this.setScissorTest = function (v) {
              ve.setScissorTest((ht = v));
            }),
            (this.setOpaqueSort = function (v) {
              oe = v;
            }),
            (this.setTransparentSort = function (v) {
              he = v;
            }),
            (this.getClearColor = function (v) {
              return v.copy(X.getClearColor());
            }),
            (this.setClearColor = function () {
              X.setClearColor(...arguments);
            }),
            (this.getClearAlpha = function () {
              return X.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              X.setClearAlpha(...arguments);
            }),
            (this.clear = function (v = !0, z = !0, U = !0) {
              let F = 0;
              if (v) {
                let B = !1;
                if (O !== null) {
                  const ee = O.texture.format;
                  B = ee === Qu || ee === Hu || ee === ju;
                }
                if (B) {
                  const ee = O.texture.type,
                    Ae = ee === hi || ee === Us || ee === yA || ee === TA || ee === Nu || ee === ku,
                    pe = X.getClearColor(),
                    ue = X.getClearAlpha(),
                    Be = pe.r,
                    Oe = pe.g,
                    Ce = pe.b;
                  Ae
                    ? ((m[0] = Be), (m[1] = Oe), (m[2] = Ce), (m[3] = ue), M.clearBufferuiv(M.COLOR, 0, m))
                    : ((g[0] = Be), (g[1] = Oe), (g[2] = Ce), (g[3] = ue), M.clearBufferiv(M.COLOR, 0, g));
                } else F |= M.COLOR_BUFFER_BIT;
              }
              z && (F |= M.DEPTH_BUFFER_BIT), U && ((F |= M.STENCIL_BUFFER_BIT), this.state.buffers.stencil.setMask(4294967295)), M.clear(F);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              t.removeEventListener("webglcontextlost", fe, !1),
                t.removeEventListener("webglcontextrestored", $, !1),
                t.removeEventListener("webglcontextcreationerror", W, !1),
                X.dispose(),
                xe.dispose(),
                se.dispose(),
                Se.dispose(),
                kt.dispose(),
                y.dispose(),
                j.dispose(),
                Le.dispose(),
                C.dispose(),
                K.dispose(),
                Z.dispose(),
                Z.removeEventListener("sessionstart", ih),
                Z.removeEventListener("sessionend", sh),
                ds.stop();
            });
          function fe(v) {
            v.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), (b = !0);
          }
          function $() {
            console.log("THREE.WebGLRenderer: Context Restored."), (b = !1);
            const v = Ze.autoReset,
              z = ye.enabled,
              U = ye.autoUpdate,
              F = ye.needsUpdate,
              B = ye.type;
            re(), (Ze.autoReset = v), (ye.enabled = z), (ye.autoUpdate = U), (ye.needsUpdate = F), (ye.type = B);
          }
          function W(v) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", v.statusMessage);
          }
          function de(v) {
            const z = v.target;
            z.removeEventListener("dispose", de), Fe(z);
          }
          function Fe(v) {
            Pt(v), Se.remove(v);
          }
          function Pt(v) {
            const z = Se.get(v).programs;
            z !== void 0 &&
              (z.forEach(function (U) {
                K.releaseProgram(U);
              }),
              v.isShaderMaterial && K.releaseShaderCache(v));
          }
          this.renderBufferDirect = function (v, z, U, F, B, ee) {
            z === null && (z = Et);
            const Ae = B.isMesh && B.matrixWorld.determinant() < 0,
              pe = Eg(v, z, U, F, B);
            ve.setMaterial(F, Ae);
            let ue = U.index,
              Be = 1;
            if (F.wireframe === !0) {
              if (((ue = L.getWireframeAttribute(U)), ue === void 0)) return;
              Be = 2;
            }
            const Oe = U.drawRange,
              Ce = U.attributes.position;
            let We = Oe.start * Be,
              lt = (Oe.start + Oe.count) * Be;
            ee !== null && ((We = Math.max(We, ee.start * Be)), (lt = Math.min(lt, (ee.start + ee.count) * Be))),
              ue !== null ? ((We = Math.max(We, 0)), (lt = Math.min(lt, ue.count))) : Ce != null && ((We = Math.max(We, 0)), (lt = Math.min(lt, Ce.count)));
            const bt = lt - We;
            if (bt < 0 || bt === 1 / 0) return;
            Le.setup(B, F, pe, U, ue);
            let vt,
              ft = ze;
            if ((ue !== null && ((vt = P.get(ue)), (ft = be), ft.setIndex(vt)), B.isMesh))
              F.wireframe === !0 ? (ve.setLineWidth(F.wireframeLinewidth * nt()), ft.setMode(M.LINES)) : ft.setMode(M.TRIANGLES);
            else if (B.isLine) {
              let Ie = F.linewidth;
              Ie === void 0 && (Ie = 1),
                ve.setLineWidth(Ie * nt()),
                B.isLineSegments ? ft.setMode(M.LINES) : B.isLineLoop ? ft.setMode(M.LINE_LOOP) : ft.setMode(M.LINE_STRIP);
            } else B.isPoints ? ft.setMode(M.POINTS) : B.isSprite && ft.setMode(M.TRIANGLES);
            if (B.isBatchedMesh)
              if (B._multiDrawInstances !== null)
                ur(
                  "THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."
                ),
                  ft.renderMultiDrawInstances(B._multiDrawStarts, B._multiDrawCounts, B._multiDrawCount, B._multiDrawInstances);
              else if (it.get("WEBGL_multi_draw")) ft.renderMultiDraw(B._multiDrawStarts, B._multiDrawCounts, B._multiDrawCount);
              else {
                const Ie = B._multiDrawStarts,
                  Mt = B._multiDrawCounts,
                  $e = B._multiDrawCount,
                  mn = ue ? P.get(ue).bytesPerElement : 1,
                  ks = Se.get(F).currentProgram.getUniforms();
                for (let gn = 0; gn < $e; gn++) ks.setValue(M, "_gl_DrawID", gn), ft.render(Ie[gn] / mn, Mt[gn]);
              }
            else if (B.isInstancedMesh) ft.renderInstances(We, bt, B.count);
            else if (U.isInstancedBufferGeometry) {
              const Ie = U._maxInstanceCount !== void 0 ? U._maxInstanceCount : 1 / 0,
                Mt = Math.min(U.instanceCount, Ie);
              ft.renderInstances(We, bt, Mt);
            } else ft.render(We, bt);
          };
          function ot(v, z, U) {
            v.transparent === !0 && v.side === ai && v.forceSinglePass === !1
              ? ((v.side = fn), (v.needsUpdate = !0), UA(v, z, U), (v.side = ki), (v.needsUpdate = !0), UA(v, z, U), (v.side = ai))
              : UA(v, z, U);
          }
          (this.compile = function (v, z, U = null) {
            U === null && (U = v),
              (f = se.get(U)),
              f.init(z),
              T.push(f),
              U.traverseVisible(function (B) {
                B.isLight && B.layers.test(z.layers) && (f.pushLight(B), B.castShadow && f.pushShadow(B));
              }),
              v !== U &&
                v.traverseVisible(function (B) {
                  B.isLight && B.layers.test(z.layers) && (f.pushLight(B), B.castShadow && f.pushShadow(B));
                }),
              f.setupLights();
            const F = new Set();
            return (
              v.traverse(function (B) {
                if (!(B.isMesh || B.isPoints || B.isLine || B.isSprite)) return;
                const ee = B.material;
                if (ee)
                  if (Array.isArray(ee))
                    for (let Ae = 0; Ae < ee.length; Ae++) {
                      const pe = ee[Ae];
                      ot(pe, U, B), F.add(pe);
                    }
                  else ot(ee, U, B), F.add(ee);
              }),
              (f = T.pop()),
              F
            );
          }),
            (this.compileAsync = function (v, z, U = null) {
              const F = this.compile(v, z, U);
              return new Promise((B) => {
                function ee() {
                  if (
                    (F.forEach(function (Ae) {
                      Se.get(Ae).currentProgram.isReady() && F.delete(Ae);
                    }),
                    F.size === 0)
                  ) {
                    B(v);
                    return;
                  }
                  setTimeout(ee, 10);
                }
                it.get("KHR_parallel_shader_compile") !== null ? ee() : setTimeout(ee, 10);
              });
            });
          let Qn = null;
          function Pi(v) {
            Qn && Qn(v);
          }
          function ih() {
            ds.stop();
          }
          function sh() {
            ds.start();
          }
          const ds = new gg();
          ds.setAnimationLoop(Pi),
            typeof self < "u" && ds.setContext(self),
            (this.setAnimationLoop = function (v) {
              (Qn = v), Z.setAnimationLoop(v), v === null ? ds.stop() : ds.start();
            }),
            Z.addEventListener("sessionstart", ih),
            Z.addEventListener("sessionend", sh),
            (this.render = function (v, z) {
              if (z !== void 0 && z.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return;
              }
              if (b === !0) return;
              if (
                (v.matrixWorldAutoUpdate === !0 && v.updateMatrixWorld(),
                z.parent === null && z.matrixWorldAutoUpdate === !0 && z.updateMatrixWorld(),
                Z.enabled === !0 && Z.isPresenting === !0 && (Z.cameraAutoUpdate === !0 && Z.updateCamera(z), (z = Z.getCamera())),
                v.isScene === !0 && v.onBeforeRender(_, v, z, O),
                (f = se.get(v, T.length)),
                f.init(z),
                T.push(f),
                Ee.multiplyMatrices(z.projectionMatrix, z.matrixWorldInverse),
                Q.setFromProjectionMatrix(Ee),
                (Te = this.localClippingEnabled),
                (te = ge.init(this.clippingPlanes, Te)),
                (p = xe.get(v, E.length)),
                p.init(),
                E.push(p),
                Z.enabled === !0 && Z.isPresenting === !0)
              ) {
                const ee = _.xr.getDepthSensingMesh();
                ee !== null && Ta(ee, z, -1 / 0, _.sortObjects);
              }
              Ta(v, z, 0, _.sortObjects),
                p.finish(),
                _.sortObjects === !0 && p.sort(oe, he),
                (Dt = Z.enabled === !1 || Z.isPresenting === !1 || Z.hasDepthSensing() === !1),
                Dt && X.addToRenderList(p, v),
                this.info.render.frame++,
                te === !0 && ge.beginShadows();
              const U = f.state.shadowsArray;
              ye.render(U, v, z), te === !0 && ge.endShadows(), this.info.autoReset === !0 && this.info.reset();
              const F = p.opaque,
                B = p.transmissive;
              if ((f.setupLights(), z.isArrayCamera)) {
                const ee = z.cameras;
                if (B.length > 0)
                  for (let Ae = 0, pe = ee.length; Ae < pe; Ae++) {
                    const ue = ee[Ae];
                    Ah(F, B, v, ue);
                  }
                Dt && X.render(v);
                for (let Ae = 0, pe = ee.length; Ae < pe; Ae++) {
                  const ue = ee[Ae];
                  rh(p, v, ue, ue.viewport);
                }
              } else B.length > 0 && Ah(F, B, v, z), Dt && X.render(v), rh(p, v, z);
              O !== null && D === 0 && (Ge.updateMultisampleRenderTarget(O), Ge.updateRenderTargetMipmap(O)),
                v.isScene === !0 && v.onAfterRender(_, v, z),
                Le.resetDefaultState(),
                (x = -1),
                (w = null),
                T.pop(),
                T.length > 0 ? ((f = T[T.length - 1]), te === !0 && ge.setGlobalState(_.clippingPlanes, f.state.camera)) : (f = null),
                E.pop(),
                E.length > 0 ? (p = E[E.length - 1]) : (p = null);
            });
          function Ta(v, z, U, F) {
            if (v.visible === !1) return;
            if (v.layers.test(z.layers)) {
              if (v.isGroup) U = v.renderOrder;
              else if (v.isLOD) v.autoUpdate === !0 && v.update(z);
              else if (v.isLight) f.pushLight(v), v.castShadow && f.pushShadow(v);
              else if (v.isSprite) {
                if (!v.frustumCulled || Q.intersectsSprite(v)) {
                  F && Re.setFromMatrixPosition(v.matrixWorld).applyMatrix4(Ee);
                  const Ae = j.update(v),
                    pe = v.material;
                  pe.visible && p.push(v, Ae, pe, U, Re.z, null);
                }
              } else if ((v.isMesh || v.isLine || v.isPoints) && (!v.frustumCulled || Q.intersectsObject(v))) {
                const Ae = j.update(v),
                  pe = v.material;
                if (
                  (F &&
                    (v.boundingSphere !== void 0
                      ? (v.boundingSphere === null && v.computeBoundingSphere(), Re.copy(v.boundingSphere.center))
                      : (Ae.boundingSphere === null && Ae.computeBoundingSphere(), Re.copy(Ae.boundingSphere.center)),
                    Re.applyMatrix4(v.matrixWorld).applyMatrix4(Ee)),
                  Array.isArray(pe))
                ) {
                  const ue = Ae.groups;
                  for (let Be = 0, Oe = ue.length; Be < Oe; Be++) {
                    const Ce = ue[Be],
                      We = pe[Ce.materialIndex];
                    We && We.visible && p.push(v, Ae, We, U, Re.z, Ce);
                  }
                } else pe.visible && p.push(v, Ae, pe, U, Re.z, null);
              }
            }
            const ee = v.children;
            for (let Ae = 0, pe = ee.length; Ae < pe; Ae++) Ta(ee[Ae], z, U, F);
          }
          function rh(v, z, U, F) {
            const B = v.opaque,
              ee = v.transmissive,
              Ae = v.transparent;
            f.setupLightsView(U),
              te === !0 && ge.setGlobalState(_.clippingPlanes, U),
              F && ve.viewport(I.copy(F)),
              B.length > 0 && LA(B, z, U),
              ee.length > 0 && LA(ee, z, U),
              Ae.length > 0 && LA(Ae, z, U),
              ve.buffers.depth.setTest(!0),
              ve.buffers.depth.setMask(!0),
              ve.buffers.color.setMask(!0),
              ve.setPolygonOffset(!1);
          }
          function Ah(v, z, U, F) {
            if ((U.isScene === !0 ? U.overrideMaterial : null) !== null) return;
            f.state.transmissionRenderTarget[F.id] === void 0 &&
              (f.state.transmissionRenderTarget[F.id] = new Fs(1, 1, {
                generateMipmaps: !0,
                type: it.has("EXT_color_buffer_half_float") || it.has("EXT_color_buffer_float") ? RA : hi,
                minFilter: Ii,
                samples: 4,
                stencilBuffer: r,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: Xe.workingColorSpace,
              }));
            const ee = f.state.transmissionRenderTarget[F.id],
              Ae = F.viewport || I;
            ee.setSize(Ae.z * _.transmissionResolutionScale, Ae.w * _.transmissionResolutionScale);
            const pe = _.getRenderTarget(),
              ue = _.getActiveCubeFace(),
              Be = _.getActiveMipmapLevel();
            _.setRenderTarget(ee), _.getClearColor(Y), (q = _.getClearAlpha()), q < 1 && _.setClearColor(16777215, 0.5), _.clear(), Dt && X.render(U);
            const Oe = _.toneMapping;
            _.toneMapping = As;
            const Ce = F.viewport;
            if (
              (F.viewport !== void 0 && (F.viewport = void 0),
              f.setupLightsView(F),
              te === !0 && ge.setGlobalState(_.clippingPlanes, F),
              LA(v, U, F),
              Ge.updateMultisampleRenderTarget(ee),
              Ge.updateRenderTargetMipmap(ee),
              it.has("WEBGL_multisampled_render_to_texture") === !1)
            ) {
              let We = !1;
              for (let lt = 0, bt = z.length; lt < bt; lt++) {
                const vt = z[lt],
                  ft = vt.object,
                  Ie = vt.geometry,
                  Mt = vt.material,
                  $e = vt.group;
                if (Mt.side === ai && ft.layers.test(F.layers)) {
                  const mn = Mt.side;
                  (Mt.side = fn), (Mt.needsUpdate = !0), oh(ft, U, F, Ie, Mt, $e), (Mt.side = mn), (Mt.needsUpdate = !0), (We = !0);
                }
              }
              We === !0 && (Ge.updateMultisampleRenderTarget(ee), Ge.updateRenderTargetMipmap(ee));
            }
            _.setRenderTarget(pe, ue, Be), _.setClearColor(Y, q), Ce !== void 0 && (F.viewport = Ce), (_.toneMapping = Oe);
          }
          function LA(v, z, U) {
            const F = z.isScene === !0 ? z.overrideMaterial : null;
            for (let B = 0, ee = v.length; B < ee; B++) {
              const Ae = v[B],
                pe = Ae.object,
                ue = Ae.geometry,
                Be = Ae.group;
              let Oe = Ae.material;
              Oe.allowOverride === !0 && F !== null && (Oe = F), pe.layers.test(U.layers) && oh(pe, z, U, ue, Oe, Be);
            }
          }
          function oh(v, z, U, F, B, ee) {
            v.onBeforeRender(_, z, U, F, B, ee),
              v.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, v.matrixWorld),
              v.normalMatrix.getNormalMatrix(v.modelViewMatrix),
              B.onBeforeRender(_, z, U, F, v, ee),
              B.transparent === !0 && B.side === ai && B.forceSinglePass === !1
                ? ((B.side = fn),
                  (B.needsUpdate = !0),
                  _.renderBufferDirect(U, z, F, B, v, ee),
                  (B.side = ki),
                  (B.needsUpdate = !0),
                  _.renderBufferDirect(U, z, F, B, v, ee),
                  (B.side = ai))
                : _.renderBufferDirect(U, z, F, B, v, ee),
              v.onAfterRender(_, z, U, F, B, ee);
          }
          function UA(v, z, U) {
            z.isScene !== !0 && (z = Et);
            const F = Se.get(v),
              B = f.state.lights,
              ee = f.state.shadowsArray,
              Ae = B.state.version,
              pe = K.getParameters(v, B.state, ee, z, U),
              ue = K.getProgramCacheKey(pe);
            let Be = F.programs;
            (F.environment = v.isMeshStandardMaterial ? z.environment : null),
              (F.fog = z.fog),
              (F.envMap = (v.isMeshStandardMaterial ? y : kt).get(v.envMap || F.environment)),
              (F.envMapRotation = F.environment !== null && v.envMap === null ? z.environmentRotation : v.envMapRotation),
              Be === void 0 && (v.addEventListener("dispose", de), (Be = new Map()), (F.programs = Be));
            let Oe = Be.get(ue);
            if (Oe !== void 0) {
              if (F.currentProgram === Oe && F.lightsStateVersion === Ae) return ch(v, pe), Oe;
            } else (pe.uniforms = K.getUniforms(v)), v.onBeforeCompile(pe, _), (Oe = K.acquireProgram(pe, ue)), Be.set(ue, Oe), (F.uniforms = pe.uniforms);
            const Ce = F.uniforms;
            return (
              ((!v.isShaderMaterial && !v.isRawShaderMaterial) || v.clipping === !0) && (Ce.clippingPlanes = ge.uniform),
              ch(v, pe),
              (F.needsLights = Mg(v)),
              (F.lightsStateVersion = Ae),
              F.needsLights &&
                ((Ce.ambientLightColor.value = B.state.ambient),
                (Ce.lightProbe.value = B.state.probe),
                (Ce.directionalLights.value = B.state.directional),
                (Ce.directionalLightShadows.value = B.state.directionalShadow),
                (Ce.spotLights.value = B.state.spot),
                (Ce.spotLightShadows.value = B.state.spotShadow),
                (Ce.rectAreaLights.value = B.state.rectArea),
                (Ce.ltc_1.value = B.state.rectAreaLTC1),
                (Ce.ltc_2.value = B.state.rectAreaLTC2),
                (Ce.pointLights.value = B.state.point),
                (Ce.pointLightShadows.value = B.state.pointShadow),
                (Ce.hemisphereLights.value = B.state.hemi),
                (Ce.directionalShadowMap.value = B.state.directionalShadowMap),
                (Ce.directionalShadowMatrix.value = B.state.directionalShadowMatrix),
                (Ce.spotShadowMap.value = B.state.spotShadowMap),
                (Ce.spotLightMatrix.value = B.state.spotLightMatrix),
                (Ce.spotLightMap.value = B.state.spotLightMap),
                (Ce.pointShadowMap.value = B.state.pointShadowMap),
                (Ce.pointShadowMatrix.value = B.state.pointShadowMatrix)),
              (F.currentProgram = Oe),
              (F.uniformsList = null),
              Oe
            );
          }
          function ah(v) {
            if (v.uniformsList === null) {
              const z = v.currentProgram.getUniforms();
              v.uniformsList = Co.seqWithValue(z.seq, v.uniforms);
            }
            return v.uniformsList;
          }
          function ch(v, z) {
            const U = Se.get(v);
            (U.outputColorSpace = z.outputColorSpace),
              (U.batching = z.batching),
              (U.batchingColor = z.batchingColor),
              (U.instancing = z.instancing),
              (U.instancingColor = z.instancingColor),
              (U.instancingMorph = z.instancingMorph),
              (U.skinning = z.skinning),
              (U.morphTargets = z.morphTargets),
              (U.morphNormals = z.morphNormals),
              (U.morphColors = z.morphColors),
              (U.morphTargetsCount = z.morphTargetsCount),
              (U.numClippingPlanes = z.numClippingPlanes),
              (U.numIntersection = z.numClipIntersection),
              (U.vertexAlphas = z.vertexAlphas),
              (U.vertexTangents = z.vertexTangents),
              (U.toneMapping = z.toneMapping);
          }
          function Eg(v, z, U, F, B) {
            z.isScene !== !0 && (z = Et), Ge.resetTextureUnits();
            const ee = z.fog,
              Ae = F.isMeshStandardMaterial ? z.environment : null,
              pe = O === null ? _.outputColorSpace : O.isXRRenderTarget === !0 ? O.texture.colorSpace : on,
              ue = (F.isMeshStandardMaterial ? y : kt).get(F.envMap || Ae),
              Be = F.vertexColors === !0 && !!U.attributes.color && U.attributes.color.itemSize === 4,
              Oe = !!U.attributes.tangent && (!!F.normalMap || F.anisotropy > 0),
              Ce = !!U.morphAttributes.position,
              We = !!U.morphAttributes.normal,
              lt = !!U.morphAttributes.color;
            let bt = As;
            F.toneMapped && (O === null || O.isXRRenderTarget === !0) && (bt = _.toneMapping);
            const vt = U.morphAttributes.position || U.morphAttributes.normal || U.morphAttributes.color,
              ft = vt !== void 0 ? vt.length : 0,
              Ie = Se.get(F),
              Mt = f.state.lights;
            if (te === !0 && (Te === !0 || v !== w)) {
              const $t = v === w && F.id === x;
              ge.setState(F, v, $t);
            }
            let $e = !1;
            F.version === Ie.__version
              ? ((Ie.needsLights && Ie.lightsStateVersion !== Mt.state.version) ||
                  Ie.outputColorSpace !== pe ||
                  (B.isBatchedMesh && Ie.batching === !1) ||
                  (!B.isBatchedMesh && Ie.batching === !0) ||
                  (B.isBatchedMesh && Ie.batchingColor === !0 && B.colorTexture === null) ||
                  (B.isBatchedMesh && Ie.batchingColor === !1 && B.colorTexture !== null) ||
                  (B.isInstancedMesh && Ie.instancing === !1) ||
                  (!B.isInstancedMesh && Ie.instancing === !0) ||
                  (B.isSkinnedMesh && Ie.skinning === !1) ||
                  (!B.isSkinnedMesh && Ie.skinning === !0) ||
                  (B.isInstancedMesh && Ie.instancingColor === !0 && B.instanceColor === null) ||
                  (B.isInstancedMesh && Ie.instancingColor === !1 && B.instanceColor !== null) ||
                  (B.isInstancedMesh && Ie.instancingMorph === !0 && B.morphTexture === null) ||
                  (B.isInstancedMesh && Ie.instancingMorph === !1 && B.morphTexture !== null) ||
                  Ie.envMap !== ue ||
                  (F.fog === !0 && Ie.fog !== ee) ||
                  (Ie.numClippingPlanes !== void 0 && (Ie.numClippingPlanes !== ge.numPlanes || Ie.numIntersection !== ge.numIntersection)) ||
                  Ie.vertexAlphas !== Be ||
                  Ie.vertexTangents !== Oe ||
                  Ie.morphTargets !== Ce ||
                  Ie.morphNormals !== We ||
                  Ie.morphColors !== lt ||
                  Ie.toneMapping !== bt ||
                  Ie.morphTargetsCount !== ft) &&
                ($e = !0)
              : (($e = !0), (Ie.__version = F.version));
            let mn = Ie.currentProgram;
            $e === !0 && (mn = UA(F, z, B));
            let ks = !1,
              gn = !1,
              Yr = !1;
            const _t = mn.getUniforms(),
              bn = Ie.uniforms;
            if ((ve.useProgram(mn.program) && ((ks = !0), (gn = !0), (Yr = !0)), F.id !== x && ((x = F.id), (gn = !0)), ks || w !== v)) {
              ve.buffers.depth.getReversed()
                ? (ae.copy(v.projectionMatrix), fv(ae), dv(ae), _t.setValue(M, "projectionMatrix", ae))
                : _t.setValue(M, "projectionMatrix", v.projectionMatrix),
                _t.setValue(M, "viewMatrix", v.matrixWorldInverse);
              const ln = _t.map.cameraPosition;
              ln !== void 0 && ln.setValue(M, tt.setFromMatrixPosition(v.matrixWorld)),
                pt.logarithmicDepthBuffer && _t.setValue(M, "logDepthBufFC", 2 / (Math.log(v.far + 1) / Math.LN2)),
                (F.isMeshPhongMaterial ||
                  F.isMeshToonMaterial ||
                  F.isMeshLambertMaterial ||
                  F.isMeshBasicMaterial ||
                  F.isMeshStandardMaterial ||
                  F.isShaderMaterial) &&
                  _t.setValue(M, "isOrthographic", v.isOrthographicCamera === !0),
                w !== v && ((w = v), (gn = !0), (Yr = !0));
            }
            if (B.isSkinnedMesh) {
              _t.setOptional(M, B, "bindMatrix"), _t.setOptional(M, B, "bindMatrixInverse");
              const $t = B.skeleton;
              $t && ($t.boneTexture === null && $t.computeBoneTexture(), _t.setValue(M, "boneTexture", $t.boneTexture, Ge));
            }
            B.isBatchedMesh &&
              (_t.setOptional(M, B, "batchingTexture"),
              _t.setValue(M, "batchingTexture", B._matricesTexture, Ge),
              _t.setOptional(M, B, "batchingIdTexture"),
              _t.setValue(M, "batchingIdTexture", B._indirectTexture, Ge),
              _t.setOptional(M, B, "batchingColorTexture"),
              B._colorsTexture !== null && _t.setValue(M, "batchingColorTexture", B._colorsTexture, Ge));
            const zn = U.morphAttributes;
            if (
              ((zn.position !== void 0 || zn.normal !== void 0 || zn.color !== void 0) && le.update(B, U, mn),
              (gn || Ie.receiveShadow !== B.receiveShadow) && ((Ie.receiveShadow = B.receiveShadow), _t.setValue(M, "receiveShadow", B.receiveShadow)),
              F.isMeshGouraudMaterial &&
                F.envMap !== null &&
                ((bn.envMap.value = ue), (bn.flipEnvMap.value = ue.isCubeTexture && ue.isRenderTargetTexture === !1 ? -1 : 1)),
              F.isMeshStandardMaterial && F.envMap === null && z.environment !== null && (bn.envMapIntensity.value = z.environmentIntensity),
              gn &&
                (_t.setValue(M, "toneMappingExposure", _.toneMappingExposure),
                Ie.needsLights && Dg(bn, Yr),
                ee && F.fog === !0 && G.refreshFogUniforms(bn, ee),
                G.refreshMaterialUniforms(bn, F, k, J, f.state.transmissionRenderTarget[v.id]),
                Co.upload(M, ah(Ie), bn, Ge)),
              F.isShaderMaterial && F.uniformsNeedUpdate === !0 && (Co.upload(M, ah(Ie), bn, Ge), (F.uniformsNeedUpdate = !1)),
              F.isSpriteMaterial && _t.setValue(M, "center", B.center),
              _t.setValue(M, "modelViewMatrix", B.modelViewMatrix),
              _t.setValue(M, "normalMatrix", B.normalMatrix),
              _t.setValue(M, "modelMatrix", B.matrixWorld),
              F.isShaderMaterial || F.isRawShaderMaterial)
            ) {
              const $t = F.uniformsGroups;
              for (let ln = 0, Ea = $t.length; ln < Ea; ln++) {
                const ps = $t[ln];
                C.update(ps, mn), C.bind(ps, mn);
              }
            }
            return mn;
          }
          function Dg(v, z) {
            (v.ambientLightColor.needsUpdate = z),
              (v.lightProbe.needsUpdate = z),
              (v.directionalLights.needsUpdate = z),
              (v.directionalLightShadows.needsUpdate = z),
              (v.pointLights.needsUpdate = z),
              (v.pointLightShadows.needsUpdate = z),
              (v.spotLights.needsUpdate = z),
              (v.spotLightShadows.needsUpdate = z),
              (v.rectAreaLights.needsUpdate = z),
              (v.hemisphereLights.needsUpdate = z);
          }
          function Mg(v) {
            return (
              v.isMeshLambertMaterial ||
              v.isMeshToonMaterial ||
              v.isMeshPhongMaterial ||
              v.isMeshStandardMaterial ||
              v.isShadowMaterial ||
              (v.isShaderMaterial && v.lights === !0)
            );
          }
          (this.getActiveCubeFace = function () {
            return S;
          }),
            (this.getActiveMipmapLevel = function () {
              return D;
            }),
            (this.getRenderTarget = function () {
              return O;
            }),
            (this.setRenderTargetTextures = function (v, z, U) {
              const F = Se.get(v);
              (F.__autoAllocateDepthBuffer = v.resolveDepthBuffer === !1),
                F.__autoAllocateDepthBuffer === !1 && (F.__useRenderToTexture = !1),
                (Se.get(v.texture).__webglTexture = z),
                (Se.get(v.depthTexture).__webglTexture = F.__autoAllocateDepthBuffer ? void 0 : U),
                (F.__hasExternalTextures = !0);
            }),
            (this.setRenderTargetFramebuffer = function (v, z) {
              const U = Se.get(v);
              (U.__webglFramebuffer = z), (U.__useDefaultFramebuffer = z === void 0);
            });
          const Cg = M.createFramebuffer();
          (this.setRenderTarget = function (v, z = 0, U = 0) {
            (O = v), (S = z), (D = U);
            let F = !0,
              B = null,
              ee = !1,
              Ae = !1;
            if (v) {
              const ue = Se.get(v);
              if (ue.__useDefaultFramebuffer !== void 0) ve.bindFramebuffer(M.FRAMEBUFFER, null), (F = !1);
              else if (ue.__webglFramebuffer === void 0) Ge.setupRenderTarget(v);
              else if (ue.__hasExternalTextures) Ge.rebindTextures(v, Se.get(v.texture).__webglTexture, Se.get(v.depthTexture).__webglTexture);
              else if (v.depthBuffer) {
                const Ce = v.depthTexture;
                if (ue.__boundDepthTexture !== Ce) {
                  if (Ce !== null && Se.has(Ce) && (v.width !== Ce.image.width || v.height !== Ce.image.height))
                    throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                  Ge.setupDepthRenderbuffer(v);
                }
              }
              const Be = v.texture;
              (Be.isData3DTexture || Be.isDataArrayTexture || Be.isCompressedArrayTexture) && (Ae = !0);
              const Oe = Se.get(v).__webglFramebuffer;
              v.isWebGLCubeRenderTarget
                ? (Array.isArray(Oe[z]) ? (B = Oe[z][U]) : (B = Oe[z]), (ee = !0))
                : v.samples > 0 && Ge.useMultisampledRTT(v) === !1
                ? (B = Se.get(v).__webglMultisampledFramebuffer)
                : Array.isArray(Oe)
                ? (B = Oe[U])
                : (B = Oe),
                I.copy(v.viewport),
                H.copy(v.scissor),
                (N = v.scissorTest);
            } else I.copy(Me).multiplyScalar(k).floor(), H.copy(He).multiplyScalar(k).floor(), (N = ht);
            if (
              (U !== 0 && (B = Cg), ve.bindFramebuffer(M.FRAMEBUFFER, B) && F && ve.drawBuffers(v, B), ve.viewport(I), ve.scissor(H), ve.setScissorTest(N), ee)
            ) {
              const ue = Se.get(v.texture);
              M.framebufferTexture2D(M.FRAMEBUFFER, M.COLOR_ATTACHMENT0, M.TEXTURE_CUBE_MAP_POSITIVE_X + z, ue.__webglTexture, U);
            } else if (Ae) {
              const ue = Se.get(v.texture),
                Be = z;
              M.framebufferTextureLayer(M.FRAMEBUFFER, M.COLOR_ATTACHMENT0, ue.__webglTexture, U, Be);
            } else if (v !== null && U !== 0) {
              const ue = Se.get(v.texture);
              M.framebufferTexture2D(M.FRAMEBUFFER, M.COLOR_ATTACHMENT0, M.TEXTURE_2D, ue.__webglTexture, U);
            }
            x = -1;
          }),
            (this.readRenderTargetPixels = function (v, z, U, F, B, ee, Ae, pe = 0) {
              if (!(v && v.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return;
              }
              let ue = Se.get(v).__webglFramebuffer;
              if ((v.isWebGLCubeRenderTarget && Ae !== void 0 && (ue = ue[Ae]), ue)) {
                ve.bindFramebuffer(M.FRAMEBUFFER, ue);
                try {
                  const Be = v.textures[pe],
                    Oe = Be.format,
                    Ce = Be.type;
                  if (!pt.textureFormatReadable(Oe)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return;
                  }
                  if (!pt.textureTypeReadable(Ce)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return;
                  }
                  z >= 0 &&
                    z <= v.width - F &&
                    U >= 0 &&
                    U <= v.height - B &&
                    (v.textures.length > 1 && M.readBuffer(M.COLOR_ATTACHMENT0 + pe), M.readPixels(z, U, F, B, ne.convert(Oe), ne.convert(Ce), ee));
                } finally {
                  const Be = O !== null ? Se.get(O).__webglFramebuffer : null;
                  ve.bindFramebuffer(M.FRAMEBUFFER, Be);
                }
              }
            }),
            (this.readRenderTargetPixelsAsync = async function (v, z, U, F, B, ee, Ae, pe = 0) {
              if (!(v && v.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
              let ue = Se.get(v).__webglFramebuffer;
              if ((v.isWebGLCubeRenderTarget && Ae !== void 0 && (ue = ue[Ae]), ue))
                if (z >= 0 && z <= v.width - F && U >= 0 && U <= v.height - B) {
                  ve.bindFramebuffer(M.FRAMEBUFFER, ue);
                  const Be = v.textures[pe],
                    Oe = Be.format,
                    Ce = Be.type;
                  if (!pt.textureFormatReadable(Oe))
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                  if (!pt.textureTypeReadable(Ce))
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                  const We = M.createBuffer();
                  M.bindBuffer(M.PIXEL_PACK_BUFFER, We),
                    M.bufferData(M.PIXEL_PACK_BUFFER, ee.byteLength, M.STREAM_READ),
                    v.textures.length > 1 && M.readBuffer(M.COLOR_ATTACHMENT0 + pe),
                    M.readPixels(z, U, F, B, ne.convert(Oe), ne.convert(Ce), 0);
                  const lt = O !== null ? Se.get(O).__webglFramebuffer : null;
                  ve.bindFramebuffer(M.FRAMEBUFFER, lt);
                  const bt = M.fenceSync(M.SYNC_GPU_COMMANDS_COMPLETE, 0);
                  return (
                    M.flush(),
                    await hv(M, bt, 4),
                    M.bindBuffer(M.PIXEL_PACK_BUFFER, We),
                    M.getBufferSubData(M.PIXEL_PACK_BUFFER, 0, ee),
                    M.deleteBuffer(We),
                    M.deleteSync(bt),
                    ee
                  );
                } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
            }),
            (this.copyFramebufferToTexture = function (v, z = null, U = 0) {
              const F = Math.pow(2, -U),
                B = Math.floor(v.image.width * F),
                ee = Math.floor(v.image.height * F),
                Ae = z !== null ? z.x : 0,
                pe = z !== null ? z.y : 0;
              Ge.setTexture2D(v, 0), M.copyTexSubImage2D(M.TEXTURE_2D, U, 0, 0, Ae, pe, B, ee), ve.unbindTexture();
            });
          const Sg = M.createFramebuffer(),
            Ig = M.createFramebuffer();
          (this.copyTextureToTexture = function (v, z, U = null, F = null, B = 0, ee = null) {
            ee === null &&
              (B !== 0
                ? (ur("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), (ee = B), (B = 0))
                : (ee = 0));
            let Ae, pe, ue, Be, Oe, Ce, We, lt, bt;
            const vt = v.isCompressedTexture ? v.mipmaps[ee] : v.image;
            if (U !== null)
              (Ae = U.max.x - U.min.x),
                (pe = U.max.y - U.min.y),
                (ue = U.isBox3 ? U.max.z - U.min.z : 1),
                (Be = U.min.x),
                (Oe = U.min.y),
                (Ce = U.isBox3 ? U.min.z : 0);
            else {
              const zn = Math.pow(2, -B);
              (Ae = Math.floor(vt.width * zn)),
                (pe = Math.floor(vt.height * zn)),
                v.isDataArrayTexture ? (ue = vt.depth) : v.isData3DTexture ? (ue = Math.floor(vt.depth * zn)) : (ue = 1),
                (Be = 0),
                (Oe = 0),
                (Ce = 0);
            }
            F !== null ? ((We = F.x), (lt = F.y), (bt = F.z)) : ((We = 0), (lt = 0), (bt = 0));
            const ft = ne.convert(z.format),
              Ie = ne.convert(z.type);
            let Mt;
            z.isData3DTexture
              ? (Ge.setTexture3D(z, 0), (Mt = M.TEXTURE_3D))
              : z.isDataArrayTexture || z.isCompressedArrayTexture
              ? (Ge.setTexture2DArray(z, 0), (Mt = M.TEXTURE_2D_ARRAY))
              : (Ge.setTexture2D(z, 0), (Mt = M.TEXTURE_2D)),
              M.pixelStorei(M.UNPACK_FLIP_Y_WEBGL, z.flipY),
              M.pixelStorei(M.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha),
              M.pixelStorei(M.UNPACK_ALIGNMENT, z.unpackAlignment);
            const $e = M.getParameter(M.UNPACK_ROW_LENGTH),
              mn = M.getParameter(M.UNPACK_IMAGE_HEIGHT),
              ks = M.getParameter(M.UNPACK_SKIP_PIXELS),
              gn = M.getParameter(M.UNPACK_SKIP_ROWS),
              Yr = M.getParameter(M.UNPACK_SKIP_IMAGES);
            M.pixelStorei(M.UNPACK_ROW_LENGTH, vt.width),
              M.pixelStorei(M.UNPACK_IMAGE_HEIGHT, vt.height),
              M.pixelStorei(M.UNPACK_SKIP_PIXELS, Be),
              M.pixelStorei(M.UNPACK_SKIP_ROWS, Oe),
              M.pixelStorei(M.UNPACK_SKIP_IMAGES, Ce);
            const _t = v.isDataArrayTexture || v.isData3DTexture,
              bn = z.isDataArrayTexture || z.isData3DTexture;
            if (v.isDepthTexture) {
              const zn = Se.get(v),
                $t = Se.get(z),
                ln = Se.get(zn.__renderTarget),
                Ea = Se.get($t.__renderTarget);
              ve.bindFramebuffer(M.READ_FRAMEBUFFER, ln.__webglFramebuffer), ve.bindFramebuffer(M.DRAW_FRAMEBUFFER, Ea.__webglFramebuffer);
              for (let ps = 0; ps < ue; ps++)
                _t &&
                  (M.framebufferTextureLayer(M.READ_FRAMEBUFFER, M.COLOR_ATTACHMENT0, Se.get(v).__webglTexture, B, Ce + ps),
                  M.framebufferTextureLayer(M.DRAW_FRAMEBUFFER, M.COLOR_ATTACHMENT0, Se.get(z).__webglTexture, ee, bt + ps)),
                  M.blitFramebuffer(Be, Oe, Ae, pe, We, lt, Ae, pe, M.DEPTH_BUFFER_BIT, M.NEAREST);
              ve.bindFramebuffer(M.READ_FRAMEBUFFER, null), ve.bindFramebuffer(M.DRAW_FRAMEBUFFER, null);
            } else if (B !== 0 || v.isRenderTargetTexture || Se.has(v)) {
              const zn = Se.get(v),
                $t = Se.get(z);
              ve.bindFramebuffer(M.READ_FRAMEBUFFER, Sg), ve.bindFramebuffer(M.DRAW_FRAMEBUFFER, Ig);
              for (let ln = 0; ln < ue; ln++)
                _t
                  ? M.framebufferTextureLayer(M.READ_FRAMEBUFFER, M.COLOR_ATTACHMENT0, zn.__webglTexture, B, Ce + ln)
                  : M.framebufferTexture2D(M.READ_FRAMEBUFFER, M.COLOR_ATTACHMENT0, M.TEXTURE_2D, zn.__webglTexture, B),
                  bn
                    ? M.framebufferTextureLayer(M.DRAW_FRAMEBUFFER, M.COLOR_ATTACHMENT0, $t.__webglTexture, ee, bt + ln)
                    : M.framebufferTexture2D(M.DRAW_FRAMEBUFFER, M.COLOR_ATTACHMENT0, M.TEXTURE_2D, $t.__webglTexture, ee),
                  B !== 0
                    ? M.blitFramebuffer(Be, Oe, Ae, pe, We, lt, Ae, pe, M.COLOR_BUFFER_BIT, M.NEAREST)
                    : bn
                    ? M.copyTexSubImage3D(Mt, ee, We, lt, bt + ln, Be, Oe, Ae, pe)
                    : M.copyTexSubImage2D(Mt, ee, We, lt, Be, Oe, Ae, pe);
              ve.bindFramebuffer(M.READ_FRAMEBUFFER, null), ve.bindFramebuffer(M.DRAW_FRAMEBUFFER, null);
            } else
              bn
                ? v.isDataTexture || v.isData3DTexture
                  ? M.texSubImage3D(Mt, ee, We, lt, bt, Ae, pe, ue, ft, Ie, vt.data)
                  : z.isCompressedArrayTexture
                  ? M.compressedTexSubImage3D(Mt, ee, We, lt, bt, Ae, pe, ue, ft, vt.data)
                  : M.texSubImage3D(Mt, ee, We, lt, bt, Ae, pe, ue, ft, Ie, vt)
                : v.isDataTexture
                ? M.texSubImage2D(M.TEXTURE_2D, ee, We, lt, Ae, pe, ft, Ie, vt.data)
                : v.isCompressedTexture
                ? M.compressedTexSubImage2D(M.TEXTURE_2D, ee, We, lt, vt.width, vt.height, ft, vt.data)
                : M.texSubImage2D(M.TEXTURE_2D, ee, We, lt, Ae, pe, ft, Ie, vt);
            M.pixelStorei(M.UNPACK_ROW_LENGTH, $e),
              M.pixelStorei(M.UNPACK_IMAGE_HEIGHT, mn),
              M.pixelStorei(M.UNPACK_SKIP_PIXELS, ks),
              M.pixelStorei(M.UNPACK_SKIP_ROWS, gn),
              M.pixelStorei(M.UNPACK_SKIP_IMAGES, Yr),
              ee === 0 && z.generateMipmaps && M.generateMipmap(Mt),
              ve.unbindTexture();
          }),
            (this.copyTextureToTexture3D = function (v, z, U = null, F = null, B = 0) {
              return (
                ur('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),
                this.copyTextureToTexture(v, z, U, F, B)
              );
            }),
            (this.initRenderTarget = function (v) {
              Se.get(v).__webglFramebuffer === void 0 && Ge.setupRenderTarget(v);
            }),
            (this.initTexture = function (v) {
              v.isCubeTexture
                ? Ge.setTextureCube(v, 0)
                : v.isData3DTexture
                ? Ge.setTexture3D(v, 0)
                : v.isDataArrayTexture || v.isCompressedArrayTexture
                ? Ge.setTexture2DArray(v, 0)
                : Ge.setTexture2D(v, 0),
                ve.unbindTexture();
            }),
            (this.resetState = function () {
              (S = 0), (D = 0), (O = null), ve.reset(), Le.reset();
            }),
            typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
        get coordinateSystem() {
          return bi;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(e) {
          this._outputColorSpace = e;
          const t = this.getContext();
          (t.drawingBufferColorSpace = Xe._getDrawingBufferColorSpace(e)), (t.unpackColorSpace = Xe._getUnpackColorSpace());
        }
      }
      function Ud(n, e) {
        if (e === U0) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), n;
        if (e === Cl || e === Xm) {
          let t = n.getIndex();
          if (t === null) {
            const A = [],
              o = n.getAttribute("position");
            if (o !== void 0) {
              for (let a = 0; a < o.count; a++) A.push(a);
              n.setIndex(A), (t = n.getIndex());
            } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n;
          }
          const i = t.count - 2,
            s = [];
          if (e === Cl) for (let A = 1; A <= i; A++) s.push(t.getX(0)), s.push(t.getX(A)), s.push(t.getX(A + 1));
          else
            for (let A = 0; A < i; A++)
              A % 2 === 0
                ? (s.push(t.getX(A)), s.push(t.getX(A + 1)), s.push(t.getX(A + 2)))
                : (s.push(t.getX(A + 2)), s.push(t.getX(A + 1)), s.push(t.getX(A)));
          s.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
          const r = n.clone();
          return r.setIndex(s), r.clearGroups(), r;
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), n;
      }
      class dy extends Wr {
        constructor(e) {
          super(e),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new vy(t);
            }),
            this.register(function (t) {
              return new wy(t);
            }),
            this.register(function (t) {
              return new Sy(t);
            }),
            this.register(function (t) {
              return new Iy(t);
            }),
            this.register(function (t) {
              return new by(t);
            }),
            this.register(function (t) {
              return new xy(t);
            }),
            this.register(function (t) {
              return new yy(t);
            }),
            this.register(function (t) {
              return new Ty(t);
            }),
            this.register(function (t) {
              return new Ey(t);
            }),
            this.register(function (t) {
              return new Py(t);
            }),
            this.register(function (t) {
              return new Dy(t);
            }),
            this.register(function (t) {
              return new _y(t);
            }),
            this.register(function (t) {
              return new Cy(t);
            }),
            this.register(function (t) {
              return new My(t);
            }),
            this.register(function (t) {
              return new my(t);
            }),
            this.register(function (t) {
              return new zy(t);
            }),
            this.register(function (t) {
              return new Ry(t);
            });
        }
        load(e, t, i, s) {
          const r = this;
          let A;
          if (this.resourcePath !== "") A = this.resourcePath;
          else if (this.path !== "") {
            const c = pA.extractUrlBase(e);
            A = pA.resolveURL(c, this.path);
          } else A = pA.extractUrlBase(e);
          this.manager.itemStart(e);
          const o = function (c) {
              s ? s(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e);
            },
            a = new pg(this.manager);
          a.setPath(this.path),
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
              e,
              function (c) {
                try {
                  r.parse(
                    c,
                    A,
                    function (l) {
                      t(l), r.manager.itemEnd(e);
                    },
                    o
                  );
                } catch (l) {
                  o(l);
                }
              },
              i,
              o
            );
        }
        setDRACOLoader(e) {
          return (this.dracoLoader = e), this;
        }
        setKTX2Loader(e) {
          return (this.ktx2Loader = e), this;
        }
        setMeshoptDecoder(e) {
          return (this.meshoptDecoder = e), this;
        }
        register(e) {
          return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
        }
        unregister(e) {
          return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
        }
        parse(e, t, i, s) {
          let r;
          const A = {},
            o = {},
            a = new TextDecoder();
          if (typeof e == "string") r = JSON.parse(e);
          else if (e instanceof ArrayBuffer)
            if (a.decode(new Uint8Array(e, 0, 4)) === xg) {
              try {
                A[Ve.KHR_BINARY_GLTF] = new By(e);
              } catch (u) {
                s && s(u);
                return;
              }
              r = JSON.parse(A[Ve.KHR_BINARY_GLTF].content);
            } else r = JSON.parse(a.decode(e));
          else r = e;
          if (r.asset === void 0 || r.asset.version[0] < 2) {
            s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return;
          }
          const c = new Ky(r, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          c.fileLoader.setRequestHeader(this.requestHeader);
          for (let l = 0; l < this.pluginCallbacks.length; l++) {
            const u = this.pluginCallbacks[l](c);
            u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), (o[u.name] = u), (A[u.name] = !0);
          }
          if (r.extensionsUsed)
            for (let l = 0; l < r.extensionsUsed.length; ++l) {
              const u = r.extensionsUsed[l],
                h = r.extensionsRequired || [];
              switch (u) {
                case Ve.KHR_MATERIALS_UNLIT:
                  A[u] = new gy();
                  break;
                case Ve.KHR_DRACO_MESH_COMPRESSION:
                  A[u] = new Oy(r, this.dracoLoader);
                  break;
                case Ve.KHR_TEXTURE_TRANSFORM:
                  A[u] = new Ly();
                  break;
                case Ve.KHR_MESH_QUANTIZATION:
                  A[u] = new Uy();
                  break;
                default:
                  h.indexOf(u) >= 0 && o[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
              }
            }
          c.setExtensions(A), c.setPlugins(o), c.parse(i, s);
        }
        parseAsync(e, t) {
          const i = this;
          return new Promise(function (s, r) {
            i.parse(e, t, s, r);
          });
        }
      }
      function py() {
        let n = {};
        return {
          get: function (e) {
            return n[e];
          },
          add: function (e, t) {
            n[e] = t;
          },
          remove: function (e) {
            delete n[e];
          },
          removeAll: function () {
            n = {};
          },
        };
      }
      const Ve = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
      };
      class my {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_LIGHTS_PUNCTUAL), (this.cache = { refs: {}, uses: {} });
        }
        _markDefs() {
          const e = this.parser,
            t = this.parser.json.nodes || [];
          for (let i = 0, s = t.length; i < s; i++) {
            const r = t[i];
            r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser,
            i = "light:" + e;
          let s = t.cache.get(i);
          if (s) return s;
          const r = t.json,
            a = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[e];
          let c;
          const l = new Ue(16777215);
          a.color !== void 0 && l.setRGB(a.color[0], a.color[1], a.color[2], on);
          const u = a.range !== void 0 ? a.range : 0;
          switch (a.type) {
            case "directional":
              (c = new mg(l)), c.target.position.set(0, 0, -1), c.add(c.target);
              break;
            case "point":
              (c = new gw(l)), (c.distance = u);
              break;
            case "spot":
              (c = new pw(l)),
                (c.distance = u),
                (a.spot = a.spot || {}),
                (a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0),
                (a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4),
                (c.angle = a.spot.outerConeAngle),
                (c.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle),
                c.target.position.set(0, 0, -1),
                c.add(c.target);
              break;
            default:
              throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
          }
          return (
            c.position.set(0, 0, 0),
            Di(c, a),
            a.intensity !== void 0 && (c.intensity = a.intensity),
            (c.name = t.createUniqueName(a.name || "light_" + e)),
            (s = Promise.resolve(c)),
            t.cache.add(i, s),
            s
          );
        }
        getDependency(e, t) {
          if (e === "light") return this._loadLight(t);
        }
        createNodeAttachment(e) {
          const t = this,
            i = this.parser,
            r = i.json.nodes[e],
            o = ((r.extensions && r.extensions[this.name]) || {}).light;
          return o === void 0
            ? null
            : this._loadLight(o).then(function (a) {
                return i._getNodeRef(t.cache, o, a);
              });
        }
      }
      class gy {
        constructor() {
          this.name = Ve.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return bs;
        }
        extendParams(e, t, i) {
          const s = [];
          (e.color = new Ue(1, 1, 1)), (e.opacity = 1);
          const r = t.pbrMetallicRoughness;
          if (r) {
            if (Array.isArray(r.baseColorFactor)) {
              const A = r.baseColorFactor;
              e.color.setRGB(A[0], A[1], A[2], on), (e.opacity = A[3]);
            }
            r.baseColorTexture !== void 0 && s.push(i.assignTexture(e, "map", r.baseColorTexture, Yt));
          }
          return Promise.all(s);
        }
      }
      class Py {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_MATERIALS_EMISSIVE_STRENGTH);
        }
        extendMaterialParams(e, t) {
          const s = this.parser.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = s.extensions[this.name].emissiveStrength;
          return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
        }
      }
      class vy {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_MATERIALS_CLEARCOAT);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : gi;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            s = i.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = [],
            A = s.extensions[this.name];
          if (
            (A.clearcoatFactor !== void 0 && (t.clearcoat = A.clearcoatFactor),
            A.clearcoatTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatMap", A.clearcoatTexture)),
            A.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = A.clearcoatRoughnessFactor),
            A.clearcoatRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatRoughnessMap", A.clearcoatRoughnessTexture)),
            A.clearcoatNormalTexture !== void 0 &&
              (r.push(i.assignTexture(t, "clearcoatNormalMap", A.clearcoatNormalTexture)), A.clearcoatNormalTexture.scale !== void 0))
          ) {
            const o = A.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new qe(o, o);
          }
          return Promise.all(r);
        }
      }
      class wy {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_MATERIALS_DISPERSION);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : gi;
        }
        extendMaterialParams(e, t) {
          const s = this.parser.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = s.extensions[this.name];
          return (t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0), Promise.resolve();
        }
      }
      class _y {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_MATERIALS_IRIDESCENCE);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : gi;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            s = i.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = [],
            A = s.extensions[this.name];
          return (
            A.iridescenceFactor !== void 0 && (t.iridescence = A.iridescenceFactor),
            A.iridescenceTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceMap", A.iridescenceTexture)),
            A.iridescenceIor !== void 0 && (t.iridescenceIOR = A.iridescenceIor),
            t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
            A.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = A.iridescenceThicknessMinimum),
            A.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = A.iridescenceThicknessMaximum),
            A.iridescenceThicknessTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceThicknessMap", A.iridescenceThicknessTexture)),
            Promise.all(r)
          );
        }
      }
      class xy {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_MATERIALS_SHEEN);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : gi;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            s = i.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = [];
          (t.sheenColor = new Ue(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
          const A = s.extensions[this.name];
          if (A.sheenColorFactor !== void 0) {
            const o = A.sheenColorFactor;
            t.sheenColor.setRGB(o[0], o[1], o[2], on);
          }
          return (
            A.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = A.sheenRoughnessFactor),
            A.sheenColorTexture !== void 0 && r.push(i.assignTexture(t, "sheenColorMap", A.sheenColorTexture, Yt)),
            A.sheenRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "sheenRoughnessMap", A.sheenRoughnessTexture)),
            Promise.all(r)
          );
        }
      }
      class yy {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_MATERIALS_TRANSMISSION);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : gi;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            s = i.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = [],
            A = s.extensions[this.name];
          return (
            A.transmissionFactor !== void 0 && (t.transmission = A.transmissionFactor),
            A.transmissionTexture !== void 0 && r.push(i.assignTexture(t, "transmissionMap", A.transmissionTexture)),
            Promise.all(r)
          );
        }
      }
      class Ty {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_MATERIALS_VOLUME);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : gi;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            s = i.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = [],
            A = s.extensions[this.name];
          (t.thickness = A.thicknessFactor !== void 0 ? A.thicknessFactor : 0),
            A.thicknessTexture !== void 0 && r.push(i.assignTexture(t, "thicknessMap", A.thicknessTexture)),
            (t.attenuationDistance = A.attenuationDistance || 1 / 0);
          const o = A.attenuationColor || [1, 1, 1];
          return (t.attenuationColor = new Ue().setRGB(o[0], o[1], o[2], on)), Promise.all(r);
        }
      }
      class Ey {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_MATERIALS_IOR);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : gi;
        }
        extendMaterialParams(e, t) {
          const s = this.parser.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = s.extensions[this.name];
          return (t.ior = r.ior !== void 0 ? r.ior : 1.5), Promise.resolve();
        }
      }
      class Dy {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_MATERIALS_SPECULAR);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : gi;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            s = i.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = [],
            A = s.extensions[this.name];
          (t.specularIntensity = A.specularFactor !== void 0 ? A.specularFactor : 1),
            A.specularTexture !== void 0 && r.push(i.assignTexture(t, "specularIntensityMap", A.specularTexture));
          const o = A.specularColorFactor || [1, 1, 1];
          return (
            (t.specularColor = new Ue().setRGB(o[0], o[1], o[2], on)),
            A.specularColorTexture !== void 0 && r.push(i.assignTexture(t, "specularColorMap", A.specularColorTexture, Yt)),
            Promise.all(r)
          );
        }
      }
      class My {
        constructor(e) {
          (this.parser = e), (this.name = Ve.EXT_MATERIALS_BUMP);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : gi;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            s = i.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = [],
            A = s.extensions[this.name];
          return (
            (t.bumpScale = A.bumpFactor !== void 0 ? A.bumpFactor : 1),
            A.bumpTexture !== void 0 && r.push(i.assignTexture(t, "bumpMap", A.bumpTexture)),
            Promise.all(r)
          );
        }
      }
      class Cy {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_MATERIALS_ANISOTROPY);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : gi;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            s = i.json.materials[e];
          if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
          const r = [],
            A = s.extensions[this.name];
          return (
            A.anisotropyStrength !== void 0 && (t.anisotropy = A.anisotropyStrength),
            A.anisotropyRotation !== void 0 && (t.anisotropyRotation = A.anisotropyRotation),
            A.anisotropyTexture !== void 0 && r.push(i.assignTexture(t, "anisotropyMap", A.anisotropyTexture)),
            Promise.all(r)
          );
        }
      }
      class Sy {
        constructor(e) {
          (this.parser = e), (this.name = Ve.KHR_TEXTURE_BASISU);
        }
        loadTexture(e) {
          const t = this.parser,
            i = t.json,
            s = i.textures[e];
          if (!s.extensions || !s.extensions[this.name]) return null;
          const r = s.extensions[this.name],
            A = t.options.ktx2Loader;
          if (!A) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
              throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null;
          }
          return t.loadTextureImage(e, r.source, A);
        }
      }
      class Iy {
        constructor(e) {
          (this.parser = e), (this.name = Ve.EXT_TEXTURE_WEBP);
        }
        loadTexture(e) {
          const t = this.name,
            i = this.parser,
            s = i.json,
            r = s.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const A = r.extensions[t],
            o = s.images[A.source];
          let a = i.textureLoader;
          if (o.uri) {
            const c = i.options.manager.getHandler(o.uri);
            c !== null && (a = c);
          }
          return i.loadTextureImage(e, A.source, a);
        }
      }
      class by {
        constructor(e) {
          (this.parser = e), (this.name = Ve.EXT_TEXTURE_AVIF);
        }
        loadTexture(e) {
          const t = this.name,
            i = this.parser,
            s = i.json,
            r = s.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const A = r.extensions[t],
            o = s.images[A.source];
          let a = i.textureLoader;
          if (o.uri) {
            const c = i.options.manager.getHandler(o.uri);
            c !== null && (a = c);
          }
          return i.loadTextureImage(e, A.source, a);
        }
      }
      class zy {
        constructor(e) {
          (this.name = Ve.EXT_MESHOPT_COMPRESSION), (this.parser = e);
        }
        loadBufferView(e) {
          const t = this.parser.json,
            i = t.bufferViews[e];
          if (i.extensions && i.extensions[this.name]) {
            const s = i.extensions[this.name],
              r = this.parser.getDependency("buffer", s.buffer),
              A = this.parser.options.meshoptDecoder;
            if (!A || !A.supported) {
              if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
              return null;
            }
            return r.then(function (o) {
              const a = s.byteOffset || 0,
                c = s.byteLength || 0,
                l = s.count,
                u = s.byteStride,
                h = new Uint8Array(o, a, c);
              return A.decodeGltfBufferAsync
                ? A.decodeGltfBufferAsync(l, u, h, s.mode, s.filter).then(function (d) {
                    return d.buffer;
                  })
                : A.ready.then(function () {
                    const d = new ArrayBuffer(l * u);
                    return A.decodeGltfBuffer(new Uint8Array(d), l, u, h, s.mode, s.filter), d;
                  });
            });
          } else return null;
        }
      }
      class Ry {
        constructor(e) {
          (this.name = Ve.EXT_MESH_GPU_INSTANCING), (this.parser = e);
        }
        createNodeMesh(e) {
          const t = this.parser.json,
            i = t.nodes[e];
          if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0) return null;
          const s = t.meshes[i.mesh];
          for (const c of s.primitives)
            if (c.mode !== Un.TRIANGLES && c.mode !== Un.TRIANGLE_STRIP && c.mode !== Un.TRIANGLE_FAN && c.mode !== void 0) return null;
          const A = i.extensions[this.name].attributes,
            o = [],
            a = {};
          for (const c in A) o.push(this.parser.getDependency("accessor", A[c]).then((l) => ((a[c] = l), a[c])));
          return o.length < 1
            ? null
            : (o.push(this.parser.createNodeMesh(e)),
              Promise.all(o).then((c) => {
                const l = c.pop(),
                  u = l.isGroup ? l.children : [l],
                  h = c[0].count,
                  d = [];
                for (const m of u) {
                  const g = new ke(),
                    p = new R(),
                    f = new fs(),
                    E = new R(1, 1, 1),
                    T = new Vv(m.geometry, m.material, h);
                  for (let _ = 0; _ < h; _++)
                    a.TRANSLATION && p.fromBufferAttribute(a.TRANSLATION, _),
                      a.ROTATION && f.fromBufferAttribute(a.ROTATION, _),
                      a.SCALE && E.fromBufferAttribute(a.SCALE, _),
                      T.setMatrixAt(_, g.compose(p, f, E));
                  for (const _ in a)
                    if (_ === "_COLOR_0") {
                      const b = a[_];
                      T.instanceColor = new Il(b.array, b.itemSize, b.normalized);
                    } else _ !== "TRANSLATION" && _ !== "ROTATION" && _ !== "SCALE" && m.geometry.setAttribute(_, a[_]);
                  It.prototype.copy.call(T, m), this.parser.assignFinalMaterial(T), d.push(T);
                }
                return l.isGroup ? (l.clear(), l.add(...d), l) : d[0];
              }));
        }
      }
      const xg = "glTF",
        rA = 12,
        Fd = { JSON: 1313821514, BIN: 5130562 };
      class By {
        constructor(e) {
          (this.name = Ve.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
          const t = new DataView(e, 0, rA),
            i = new TextDecoder();
          if (
            ((this.header = { magic: i.decode(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }),
            this.header.magic !== xg)
          )
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
          if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const s = this.header.length - rA,
            r = new DataView(e, rA);
          let A = 0;
          for (; A < s; ) {
            const o = r.getUint32(A, !0);
            A += 4;
            const a = r.getUint32(A, !0);
            if (((A += 4), a === Fd.JSON)) {
              const c = new Uint8Array(e, rA + A, o);
              this.content = i.decode(c);
            } else if (a === Fd.BIN) {
              const c = rA + A;
              this.body = e.slice(c, c + o);
            }
            A += o;
          }
          if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class Oy {
        constructor(e, t) {
          if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
          (this.name = Ve.KHR_DRACO_MESH_COMPRESSION), (this.json = e), (this.dracoLoader = t), this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const i = this.json,
            s = this.dracoLoader,
            r = e.extensions[this.name].bufferView,
            A = e.extensions[this.name].attributes,
            o = {},
            a = {},
            c = {};
          for (const l in A) {
            const u = Rl[l] || l.toLowerCase();
            o[u] = A[l];
          }
          for (const l in e.attributes) {
            const u = Rl[l] || l.toLowerCase();
            if (A[l] !== void 0) {
              const h = i.accessors[e.attributes[l]],
                d = fr[h.componentType];
              (c[u] = d.name), (a[u] = h.normalized === !0);
            }
          }
          return t.getDependency("bufferView", r).then(function (l) {
            return new Promise(function (u, h) {
              s.decodeDracoFile(
                l,
                function (d) {
                  for (const m in d.attributes) {
                    const g = d.attributes[m],
                      p = a[m];
                    p !== void 0 && (g.normalized = p);
                  }
                  u(d);
                },
                o,
                c,
                on,
                h
              );
            });
          });
        }
      }
      class Ly {
        constructor() {
          this.name = Ve.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (
            ((t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0) ||
              ((e = e.clone()),
              t.texCoord !== void 0 && (e.channel = t.texCoord),
              t.offset !== void 0 && e.offset.fromArray(t.offset),
              t.rotation !== void 0 && (e.rotation = t.rotation),
              t.scale !== void 0 && e.repeat.fromArray(t.scale),
              (e.needsUpdate = !0)),
            e
          );
        }
      }
      class Uy {
        constructor() {
          this.name = Ve.KHR_MESH_QUANTIZATION;
        }
      }
      class yg extends OA {
        constructor(e, t, i, s) {
          super(e, t, i, s);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            i = this.sampleValues,
            s = this.valueSize,
            r = e * s * 3 + s;
          for (let A = 0; A !== s; A++) t[A] = i[r + A];
          return t;
        }
        interpolate_(e, t, i, s) {
          const r = this.resultBuffer,
            A = this.sampleValues,
            o = this.valueSize,
            a = o * 2,
            c = o * 3,
            l = s - t,
            u = (i - t) / l,
            h = u * u,
            d = h * u,
            m = e * c,
            g = m - c,
            p = -2 * d + 3 * h,
            f = d - h,
            E = 1 - p,
            T = f - h + u;
          for (let _ = 0; _ !== o; _++) {
            const b = A[g + _ + o],
              S = A[g + _ + a] * l,
              D = A[m + _ + o],
              O = A[m + _] * l;
            r[_] = E * b + T * S + p * D + f * O;
          }
          return r;
        }
      }
      const Fy = new fs();
      class Ny extends yg {
        interpolate_(e, t, i, s) {
          const r = super.interpolate_(e, t, i, s);
          return Fy.fromArray(r).normalize().toArray(r), r;
        }
      }
      const Un = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6 },
        fr = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array },
        Nd = { 9728: sn, 9729: Tn, 9984: jm, 9985: xo, 9986: aA, 9987: Ii },
        kd = { 33071: es, 33648: Uo, 10497: Cr },
        wc = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
        Rl = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex",
        },
        Xi = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" },
        ky = { CUBICSPLINE: void 0, LINEAR: CA, STEP: MA },
        _c = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
      function Gy(n) {
        return (
          n.DefaultMaterial === void 0 &&
            (n.DefaultMaterial = new Ju({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: ki })),
          n.DefaultMaterial
        );
      }
      function ys(n, e, t) {
        for (const i in t.extensions)
          n[i] === void 0 && ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}), (e.userData.gltfExtensions[i] = t.extensions[i]));
      }
      function Di(n, e) {
        e.extras !== void 0 &&
          (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
      }
      function jy(n, e, t) {
        let i = !1,
          s = !1,
          r = !1;
        for (let c = 0, l = e.length; c < l; c++) {
          const u = e[c];
          if ((u.POSITION !== void 0 && (i = !0), u.NORMAL !== void 0 && (s = !0), u.COLOR_0 !== void 0 && (r = !0), i && s && r)) break;
        }
        if (!i && !s && !r) return Promise.resolve(n);
        const A = [],
          o = [],
          a = [];
        for (let c = 0, l = e.length; c < l; c++) {
          const u = e[c];
          if (i) {
            const h = u.POSITION !== void 0 ? t.getDependency("accessor", u.POSITION) : n.attributes.position;
            A.push(h);
          }
          if (s) {
            const h = u.NORMAL !== void 0 ? t.getDependency("accessor", u.NORMAL) : n.attributes.normal;
            o.push(h);
          }
          if (r) {
            const h = u.COLOR_0 !== void 0 ? t.getDependency("accessor", u.COLOR_0) : n.attributes.color;
            a.push(h);
          }
        }
        return Promise.all([Promise.all(A), Promise.all(o), Promise.all(a)]).then(function (c) {
          const l = c[0],
            u = c[1],
            h = c[2];
          return (
            i && (n.morphAttributes.position = l), s && (n.morphAttributes.normal = u), r && (n.morphAttributes.color = h), (n.morphTargetsRelative = !0), n
          );
        });
      }
      function Hy(n, e) {
        if ((n.updateMorphTargets(), e.weights !== void 0)) for (let t = 0, i = e.weights.length; t < i; t++) n.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const t = e.extras.targetNames;
          if (n.morphTargetInfluences.length === t.length) {
            n.morphTargetDictionary = {};
            for (let i = 0, s = t.length; i < s; i++) n.morphTargetDictionary[t[i]] = i;
          } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
      }
      function Qy(n) {
        let e;
        const t = n.extensions && n.extensions[Ve.KHR_DRACO_MESH_COMPRESSION];
        if (
          (t ? (e = "draco:" + t.bufferView + ":" + t.indices + ":" + xc(t.attributes)) : (e = n.indices + ":" + xc(n.attributes) + ":" + n.mode),
          n.targets !== void 0)
        )
          for (let i = 0, s = n.targets.length; i < s; i++) e += ":" + xc(n.targets[i]);
        return e;
      }
      function xc(n) {
        let e = "";
        const t = Object.keys(n).sort();
        for (let i = 0, s = t.length; i < s; i++) e += t[i] + ":" + n[t[i]] + ";";
        return e;
      }
      function Bl(n) {
        switch (n) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
        }
      }
      function Vy(n) {
        return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
          ? "image/jpeg"
          : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
          ? "image/webp"
          : n.search(/\.ktx2($|\?)/i) > 0 || n.search(/^data\:image\/ktx2/) === 0
          ? "image/ktx2"
          : "image/png";
      }
      const Wy = new ke();
      class Ky {
        constructor(e = {}, t = {}) {
          (this.json = e),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = t),
            (this.cache = new py()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.nodeCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.sourceCache = {}),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {});
          let i = !1,
            s = -1,
            r = !1,
            A = -1;
          if (typeof navigator < "u") {
            const o = navigator.userAgent;
            i = /^((?!chrome|android).)*safari/i.test(o) === !0;
            const a = o.match(/Version\/(\d+)/);
            (s = i && a ? parseInt(a[1], 10) : -1), (r = o.indexOf("Firefox") > -1), (A = r ? o.match(/Firefox\/([0-9]+)\./)[1] : -1);
          }
          typeof createImageBitmap > "u" || (i && s < 17) || (r && A < 98)
            ? (this.textureLoader = new fw(this.options.manager))
            : (this.textureLoader = new ww(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new pg(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const i = this,
            s = this.json,
            r = this.extensions;
          this.cache.removeAll(),
            (this.nodeCache = {}),
            this._invokeAll(function (A) {
              return A._markDefs && A._markDefs();
            }),
            Promise.all(
              this._invokeAll(function (A) {
                return A.beforeRoot && A.beforeRoot();
              })
            )
              .then(function () {
                return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")]);
              })
              .then(function (A) {
                const o = { scene: A[0][s.scene || 0], scenes: A[0], animations: A[1], cameras: A[2], asset: s.asset, parser: i, userData: {} };
                return (
                  ys(r, o, s),
                  Di(o, s),
                  Promise.all(
                    i._invokeAll(function (a) {
                      return a.afterRoot && a.afterRoot(o);
                    })
                  ).then(function () {
                    for (const a of o.scenes) a.updateMatrixWorld();
                    e(o);
                  })
                );
              })
              .catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [],
            t = this.json.skins || [],
            i = this.json.meshes || [];
          for (let s = 0, r = t.length; s < r; s++) {
            const A = t[s].joints;
            for (let o = 0, a = A.length; o < a; o++) e[A[o]].isBone = !0;
          }
          for (let s = 0, r = e.length; s < r; s++) {
            const A = e[s];
            A.mesh !== void 0 && (this._addNodeRef(this.meshCache, A.mesh), A.skin !== void 0 && (i[A.mesh].isSkinnedMesh = !0)),
              A.camera !== void 0 && this._addNodeRef(this.cameraCache, A.camera);
          }
        }
        _addNodeRef(e, t) {
          t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, i) {
          if (e.refs[t] <= 1) return i;
          const s = i.clone(),
            r = (A, o) => {
              const a = this.associations.get(A);
              a != null && this.associations.set(o, a);
              for (const [c, l] of A.children.entries()) r(l, o.children[c]);
            };
          return r(i, s), (s.name += "_instance_" + e.uses[t]++), s;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let i = 0; i < t.length; i++) {
            const s = e(t[i]);
            if (s) return s;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const i = [];
          for (let s = 0; s < t.length; s++) {
            const r = e(t[s]);
            r && i.push(r);
          }
          return i;
        }
        getDependency(e, t) {
          const i = e + ":" + t;
          let s = this.cache.get(i);
          if (!s) {
            switch (e) {
              case "scene":
                s = this.loadScene(t);
                break;
              case "node":
                s = this._invokeOne(function (r) {
                  return r.loadNode && r.loadNode(t);
                });
                break;
              case "mesh":
                s = this._invokeOne(function (r) {
                  return r.loadMesh && r.loadMesh(t);
                });
                break;
              case "accessor":
                s = this.loadAccessor(t);
                break;
              case "bufferView":
                s = this._invokeOne(function (r) {
                  return r.loadBufferView && r.loadBufferView(t);
                });
                break;
              case "buffer":
                s = this.loadBuffer(t);
                break;
              case "material":
                s = this._invokeOne(function (r) {
                  return r.loadMaterial && r.loadMaterial(t);
                });
                break;
              case "texture":
                s = this._invokeOne(function (r) {
                  return r.loadTexture && r.loadTexture(t);
                });
                break;
              case "skin":
                s = this.loadSkin(t);
                break;
              case "animation":
                s = this._invokeOne(function (r) {
                  return r.loadAnimation && r.loadAnimation(t);
                });
                break;
              case "camera":
                s = this.loadCamera(t);
                break;
              default:
                if (
                  ((s = this._invokeOne(function (r) {
                    return r != this && r.getDependency && r.getDependency(e, t);
                  })),
                  !s)
                )
                  throw new Error("Unknown type: " + e);
                break;
            }
            this.cache.add(i, s);
          }
          return s;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const i = this,
              s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            (t = Promise.all(
              s.map(function (r, A) {
                return i.getDependency(e, A);
              })
            )),
              this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e],
            i = this.fileLoader;
          if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
          if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[Ve.KHR_BINARY_GLTF].body);
          const s = this.options;
          return new Promise(function (r, A) {
            i.load(pA.resolveURL(t.uri, s.path), r, void 0, function () {
              A(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function (i) {
            const s = t.byteLength || 0,
              r = t.byteOffset || 0;
            return i.slice(r, r + s);
          });
        }
        loadAccessor(e) {
          const t = this,
            i = this.json,
            s = this.json.accessors[e];
          if (s.bufferView === void 0 && s.sparse === void 0) {
            const A = wc[s.type],
              o = fr[s.componentType],
              a = s.normalized === !0,
              c = new o(s.count * A);
            return Promise.resolve(new rn(c, A, a));
          }
          const r = [];
          return (
            s.bufferView !== void 0 ? r.push(this.getDependency("bufferView", s.bufferView)) : r.push(null),
            s.sparse !== void 0 &&
              (r.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", s.sparse.values.bufferView))),
            Promise.all(r).then(function (A) {
              const o = A[0],
                a = wc[s.type],
                c = fr[s.componentType],
                l = c.BYTES_PER_ELEMENT,
                u = l * a,
                h = s.byteOffset || 0,
                d = s.bufferView !== void 0 ? i.bufferViews[s.bufferView].byteStride : void 0,
                m = s.normalized === !0;
              let g, p;
              if (d && d !== u) {
                const f = Math.floor(h / d),
                  E = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + f + ":" + s.count;
                let T = t.cache.get(E);
                T || ((g = new c(o, f * d, (s.count * d) / l)), (T = new kv(g, d / l)), t.cache.add(E, T)), (p = new Ku(T, a, (h % d) / l, m));
              } else o === null ? (g = new c(s.count * a)) : (g = new c(o, h, s.count * a)), (p = new rn(g, a, m));
              if (s.sparse !== void 0) {
                const f = wc.SCALAR,
                  E = fr[s.sparse.indices.componentType],
                  T = s.sparse.indices.byteOffset || 0,
                  _ = s.sparse.values.byteOffset || 0,
                  b = new E(A[1], T, s.sparse.count * f),
                  S = new c(A[2], _, s.sparse.count * a);
                o !== null && (p = new rn(p.array.slice(), p.itemSize, p.normalized)), (p.normalized = !1);
                for (let D = 0, O = b.length; D < O; D++) {
                  const x = b[D];
                  if ((p.setX(x, S[D * a]), a >= 2 && p.setY(x, S[D * a + 1]), a >= 3 && p.setZ(x, S[D * a + 2]), a >= 4 && p.setW(x, S[D * a + 3]), a >= 5))
                    throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                }
                p.normalized = m;
              }
              return p;
            })
          );
        }
        loadTexture(e) {
          const t = this.json,
            i = this.options,
            r = t.textures[e].source,
            A = t.images[r];
          let o = this.textureLoader;
          if (A.uri) {
            const a = i.manager.getHandler(A.uri);
            a !== null && (o = a);
          }
          return this.loadTextureImage(e, r, o);
        }
        loadTextureImage(e, t, i) {
          const s = this,
            r = this.json,
            A = r.textures[e],
            o = r.images[t],
            a = (o.uri || o.bufferView) + ":" + A.sampler;
          if (this.textureCache[a]) return this.textureCache[a];
          const c = this.loadImageSource(t, i)
            .then(function (l) {
              (l.flipY = !1),
                (l.name = A.name || o.name || ""),
                l.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (l.name = o.uri);
              const h = (r.samplers || {})[A.sampler] || {};
              return (
                (l.magFilter = Nd[h.magFilter] || Tn),
                (l.minFilter = Nd[h.minFilter] || Ii),
                (l.wrapS = kd[h.wrapS] || Cr),
                (l.wrapT = kd[h.wrapT] || Cr),
                (l.generateMipmaps = !l.isCompressedTexture && l.minFilter !== sn && l.minFilter !== Tn),
                s.associations.set(l, { textures: e }),
                l
              );
            })
            .catch(function () {
              return null;
            });
          return (this.textureCache[a] = c), c;
        }
        loadImageSource(e, t) {
          const i = this,
            s = this.json,
            r = this.options;
          if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((u) => u.clone());
          const A = s.images[e],
            o = self.URL || self.webkitURL;
          let a = A.uri || "",
            c = !1;
          if (A.bufferView !== void 0)
            a = i.getDependency("bufferView", A.bufferView).then(function (u) {
              c = !0;
              const h = new Blob([u], { type: A.mimeType });
              return (a = o.createObjectURL(h)), a;
            });
          else if (A.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
          const l = Promise.resolve(a)
            .then(function (u) {
              return new Promise(function (h, d) {
                let m = h;
                t.isImageBitmapLoader === !0 &&
                  (m = function (g) {
                    const p = new Kt(g);
                    (p.needsUpdate = !0), h(p);
                  }),
                  t.load(pA.resolveURL(u, r.path), m, void 0, d);
              });
            })
            .then(function (u) {
              return c === !0 && o.revokeObjectURL(a), Di(u, A), (u.userData.mimeType = A.mimeType || Vy(A.uri)), u;
            })
            .catch(function (u) {
              throw (console.error("THREE.GLTFLoader: Couldn't load texture", a), u);
            });
          return (this.sourceCache[e] = l), l;
        }
        assignTexture(e, t, i, s) {
          const r = this;
          return this.getDependency("texture", i.index).then(function (A) {
            if (!A) return null;
            if ((i.texCoord !== void 0 && i.texCoord > 0 && ((A = A.clone()), (A.channel = i.texCoord)), r.extensions[Ve.KHR_TEXTURE_TRANSFORM])) {
              const o = i.extensions !== void 0 ? i.extensions[Ve.KHR_TEXTURE_TRANSFORM] : void 0;
              if (o) {
                const a = r.associations.get(A);
                (A = r.extensions[Ve.KHR_TEXTURE_TRANSFORM].extendTexture(A, o)), r.associations.set(A, a);
              }
            }
            return s !== void 0 && (A.colorSpace = s), (e[t] = A), A;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let i = e.material;
          const s = t.attributes.tangent === void 0,
            r = t.attributes.color !== void 0,
            A = t.attributes.normal === void 0;
          if (e.isPoints) {
            const o = "PointsMaterial:" + i.uuid;
            let a = this.cache.get(o);
            a || ((a = new ug()), ci.prototype.copy.call(a, i), a.color.copy(i.color), (a.map = i.map), (a.sizeAttenuation = !1), this.cache.add(o, a)),
              (i = a);
          } else if (e.isLine) {
            const o = "LineBasicMaterial:" + i.uuid;
            let a = this.cache.get(o);
            a || ((a = new lg()), ci.prototype.copy.call(a, i), a.color.copy(i.color), (a.map = i.map), this.cache.add(o, a)), (i = a);
          }
          if (s || r || A) {
            let o = "ClonedMaterial:" + i.uuid + ":";
            s && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), A && (o += "flat-shading:");
            let a = this.cache.get(o);
            a ||
              ((a = i.clone()),
              r && (a.vertexColors = !0),
              A && (a.flatShading = !0),
              s && (a.normalScale && (a.normalScale.y *= -1), a.clearcoatNormalScale && (a.clearcoatNormalScale.y *= -1)),
              this.cache.add(o, a),
              this.associations.set(a, this.associations.get(i))),
              (i = a);
          }
          e.material = i;
        }
        getMaterialType() {
          return Ju;
        }
        loadMaterial(e) {
          const t = this,
            i = this.json,
            s = this.extensions,
            r = i.materials[e];
          let A;
          const o = {},
            a = r.extensions || {},
            c = [];
          if (a[Ve.KHR_MATERIALS_UNLIT]) {
            const u = s[Ve.KHR_MATERIALS_UNLIT];
            (A = u.getMaterialType()), c.push(u.extendParams(o, r, t));
          } else {
            const u = r.pbrMetallicRoughness || {};
            if (((o.color = new Ue(1, 1, 1)), (o.opacity = 1), Array.isArray(u.baseColorFactor))) {
              const h = u.baseColorFactor;
              o.color.setRGB(h[0], h[1], h[2], on), (o.opacity = h[3]);
            }
            u.baseColorTexture !== void 0 && c.push(t.assignTexture(o, "map", u.baseColorTexture, Yt)),
              (o.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1),
              (o.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1),
              u.metallicRoughnessTexture !== void 0 &&
                (c.push(t.assignTexture(o, "metalnessMap", u.metallicRoughnessTexture)),
                c.push(t.assignTexture(o, "roughnessMap", u.metallicRoughnessTexture))),
              (A = this._invokeOne(function (h) {
                return h.getMaterialType && h.getMaterialType(e);
              })),
              c.push(
                Promise.all(
                  this._invokeAll(function (h) {
                    return h.extendMaterialParams && h.extendMaterialParams(e, o);
                  })
                )
              );
          }
          r.doubleSided === !0 && (o.side = ai);
          const l = r.alphaMode || _c.OPAQUE;
          if (
            (l === _c.BLEND
              ? ((o.transparent = !0), (o.depthWrite = !1))
              : ((o.transparent = !1), l === _c.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)),
            r.normalTexture !== void 0 &&
              A !== bs &&
              (c.push(t.assignTexture(o, "normalMap", r.normalTexture)), (o.normalScale = new qe(1, 1)), r.normalTexture.scale !== void 0))
          ) {
            const u = r.normalTexture.scale;
            o.normalScale.set(u, u);
          }
          if (
            (r.occlusionTexture !== void 0 &&
              A !== bs &&
              (c.push(t.assignTexture(o, "aoMap", r.occlusionTexture)),
              r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)),
            r.emissiveFactor !== void 0 && A !== bs)
          ) {
            const u = r.emissiveFactor;
            o.emissive = new Ue().setRGB(u[0], u[1], u[2], on);
          }
          return (
            r.emissiveTexture !== void 0 && A !== bs && c.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, Yt)),
            Promise.all(c).then(function () {
              const u = new A(o);
              return r.name && (u.name = r.name), Di(u, r), t.associations.set(u, { materials: e }), r.extensions && ys(s, u, r), u;
            })
          );
        }
        createUniqueName(e) {
          const t = ct.sanitizeNodeName(e || "");
          return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : ((this.nodeNamesUsed[t] = 0), t);
        }
        loadGeometries(e) {
          const t = this,
            i = this.extensions,
            s = this.primitiveCache;
          function r(o) {
            return i[Ve.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function (a) {
              return Gd(a, o, t);
            });
          }
          const A = [];
          for (let o = 0, a = e.length; o < a; o++) {
            const c = e[o],
              l = Qy(c),
              u = s[l];
            if (u) A.push(u.promise);
            else {
              let h;
              c.extensions && c.extensions[Ve.KHR_DRACO_MESH_COMPRESSION] ? (h = r(c)) : (h = Gd(new mi(), c, t)),
                (s[l] = { primitive: c, promise: h }),
                A.push(h);
            }
          }
          return Promise.all(A);
        }
        loadMesh(e) {
          const t = this,
            i = this.json,
            s = this.extensions,
            r = i.meshes[e],
            A = r.primitives,
            o = [];
          for (let a = 0, c = A.length; a < c; a++) {
            const l = A[a].material === void 0 ? Gy(this.cache) : this.getDependency("material", A[a].material);
            o.push(l);
          }
          return (
            o.push(t.loadGeometries(A)),
            Promise.all(o).then(function (a) {
              const c = a.slice(0, a.length - 1),
                l = a[a.length - 1],
                u = [];
              for (let d = 0, m = l.length; d < m; d++) {
                const g = l[d],
                  p = A[d];
                let f;
                const E = c[d];
                if (p.mode === Un.TRIANGLES || p.mode === Un.TRIANGLE_STRIP || p.mode === Un.TRIANGLE_FAN || p.mode === void 0)
                  (f = r.isSkinnedMesh === !0 ? new jv(g, E) : new En(g, E)),
                    f.isSkinnedMesh === !0 && f.normalizeSkinWeights(),
                    p.mode === Un.TRIANGLE_STRIP ? (f.geometry = Ud(f.geometry, Xm)) : p.mode === Un.TRIANGLE_FAN && (f.geometry = Ud(f.geometry, Cl));
                else if (p.mode === Un.LINES) f = new qv(g, E);
                else if (p.mode === Un.LINE_STRIP) f = new Xu(g, E);
                else if (p.mode === Un.LINE_LOOP) f = new Xv(g, E);
                else if (p.mode === Un.POINTS) f = new Jv(g, E);
                else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
                Object.keys(f.geometry.morphAttributes).length > 0 && Hy(f, r),
                  (f.name = t.createUniqueName(r.name || "mesh_" + e)),
                  Di(f, r),
                  p.extensions && ys(s, f, p),
                  t.assignFinalMaterial(f),
                  u.push(f);
              }
              for (let d = 0, m = u.length; d < m; d++) t.associations.set(u[d], { meshes: e, primitives: d });
              if (u.length === 1) return r.extensions && ys(s, u[0], r), u[0];
              const h = new zs();
              r.extensions && ys(s, h, r), t.associations.set(h, { meshes: e });
              for (let d = 0, m = u.length; d < m; d++) h.add(u[d]);
              return h;
            })
          );
        }
        loadCamera(e) {
          let t;
          const i = this.json.cameras[e],
            s = i[i.type];
          if (!s) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          return (
            i.type === "perspective"
              ? (t = new nn(lv.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6))
              : i.type === "orthographic" && (t = new $u(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)),
            i.name && (t.name = this.createUniqueName(i.name)),
            Di(t, i),
            Promise.resolve(t)
          );
        }
        loadSkin(e) {
          const t = this.json.skins[e],
            i = [];
          for (let s = 0, r = t.joints.length; s < r; s++) i.push(this._loadNodeShallow(t.joints[s]));
          return (
            t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null),
            Promise.all(i).then(function (s) {
              const r = s.pop(),
                A = s,
                o = [],
                a = [];
              for (let c = 0, l = A.length; c < l; c++) {
                const u = A[c];
                if (u) {
                  o.push(u);
                  const h = new ke();
                  r !== null && h.fromArray(r.array, c * 16), a.push(h);
                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
              }
              return new Yu(o, a);
            })
          );
        }
        loadAnimation(e) {
          const t = this.json,
            i = this,
            s = t.animations[e],
            r = s.name ? s.name : "animation_" + e,
            A = [],
            o = [],
            a = [],
            c = [],
            l = [];
          for (let u = 0, h = s.channels.length; u < h; u++) {
            const d = s.channels[u],
              m = s.samplers[d.sampler],
              g = d.target,
              p = g.node,
              f = s.parameters !== void 0 ? s.parameters[m.input] : m.input,
              E = s.parameters !== void 0 ? s.parameters[m.output] : m.output;
            g.node !== void 0 &&
              (A.push(this.getDependency("node", p)),
              o.push(this.getDependency("accessor", f)),
              a.push(this.getDependency("accessor", E)),
              c.push(m),
              l.push(g));
          }
          return Promise.all([Promise.all(A), Promise.all(o), Promise.all(a), Promise.all(c), Promise.all(l)]).then(function (u) {
            const h = u[0],
              d = u[1],
              m = u[2],
              g = u[3],
              p = u[4],
              f = [];
            for (let E = 0, T = h.length; E < T; E++) {
              const _ = h[E],
                b = d[E],
                S = m[E],
                D = g[E],
                O = p[E];
              if (_ === void 0) continue;
              _.updateMatrix && _.updateMatrix();
              const x = i._createAnimationTracks(_, b, S, D, O);
              if (x) for (let w = 0; w < x.length; w++) f.push(x[w]);
            }
            return new Aw(r, void 0, f);
          });
        }
        createNodeMesh(e) {
          const t = this.json,
            i = this,
            s = t.nodes[e];
          return s.mesh === void 0
            ? null
            : i.getDependency("mesh", s.mesh).then(function (r) {
                const A = i._getNodeRef(i.meshCache, s.mesh, r);
                return (
                  s.weights !== void 0 &&
                    A.traverse(function (o) {
                      if (o.isMesh) for (let a = 0, c = s.weights.length; a < c; a++) o.morphTargetInfluences[a] = s.weights[a];
                    }),
                  A
                );
              });
        }
        loadNode(e) {
          const t = this.json,
            i = this,
            s = t.nodes[e],
            r = i._loadNodeShallow(e),
            A = [],
            o = s.children || [];
          for (let c = 0, l = o.length; c < l; c++) A.push(i.getDependency("node", o[c]));
          const a = s.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", s.skin);
          return Promise.all([r, Promise.all(A), a]).then(function (c) {
            const l = c[0],
              u = c[1],
              h = c[2];
            h !== null &&
              l.traverse(function (d) {
                d.isSkinnedMesh && d.bind(h, Wy);
              });
            for (let d = 0, m = u.length; d < m; d++) l.add(u[d]);
            return l;
          });
        }
        _loadNodeShallow(e) {
          const t = this.json,
            i = this.extensions,
            s = this;
          if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
          const r = t.nodes[e],
            A = r.name ? s.createUniqueName(r.name) : "",
            o = [],
            a = s._invokeOne(function (c) {
              return c.createNodeMesh && c.createNodeMesh(e);
            });
          return (
            a && o.push(a),
            r.camera !== void 0 &&
              o.push(
                s.getDependency("camera", r.camera).then(function (c) {
                  return s._getNodeRef(s.cameraCache, r.camera, c);
                })
              ),
            s
              ._invokeAll(function (c) {
                return c.createNodeAttachment && c.createNodeAttachment(e);
              })
              .forEach(function (c) {
                o.push(c);
              }),
            (this.nodeCache[e] = Promise.all(o).then(function (c) {
              let l;
              if ((r.isBone === !0 ? (l = new ag()) : c.length > 1 ? (l = new zs()) : c.length === 1 ? (l = c[0]) : (l = new It()), l !== c[0]))
                for (let u = 0, h = c.length; u < h; u++) l.add(c[u]);
              if ((r.name && ((l.userData.name = r.name), (l.name = A)), Di(l, r), r.extensions && ys(i, l, r), r.matrix !== void 0)) {
                const u = new ke();
                u.fromArray(r.matrix), l.applyMatrix4(u);
              } else r.translation !== void 0 && l.position.fromArray(r.translation), r.rotation !== void 0 && l.quaternion.fromArray(r.rotation), r.scale !== void 0 && l.scale.fromArray(r.scale);
              if (!s.associations.has(l)) s.associations.set(l, {});
              else if (r.mesh !== void 0 && s.meshCache.refs[r.mesh] > 1) {
                const u = s.associations.get(l);
                s.associations.set(l, { ...u });
              }
              return (s.associations.get(l).nodes = e), l;
            })),
            this.nodeCache[e]
          );
        }
        loadScene(e) {
          const t = this.extensions,
            i = this.json.scenes[e],
            s = this,
            r = new zs();
          i.name && (r.name = s.createUniqueName(i.name)), Di(r, i), i.extensions && ys(t, r, i);
          const A = i.nodes || [],
            o = [];
          for (let a = 0, c = A.length; a < c; a++) o.push(s.getDependency("node", A[a]));
          return Promise.all(o).then(function (a) {
            for (let l = 0, u = a.length; l < u; l++) r.add(a[l]);
            const c = (l) => {
              const u = new Map();
              for (const [h, d] of s.associations) (h instanceof ci || h instanceof Kt) && u.set(h, d);
              return (
                l.traverse((h) => {
                  const d = s.associations.get(h);
                  d != null && u.set(h, d);
                }),
                u
              );
            };
            return (s.associations = c(r)), r;
          });
        }
        _createAnimationTracks(e, t, i, s, r) {
          const A = [],
            o = e.name ? e.name : e.uuid,
            a = [];
          Xi[r.path] === Xi.weights
            ? e.traverse(function (h) {
                h.morphTargetInfluences && a.push(h.name ? h.name : h.uuid);
              })
            : a.push(o);
          let c;
          switch (Xi[r.path]) {
            case Xi.weights:
              c = br;
              break;
            case Xi.rotation:
              c = zr;
              break;
            case Xi.translation:
            case Xi.scale:
              c = Rr;
              break;
            default:
              switch (i.itemSize) {
                case 1:
                  c = br;
                  break;
                case 2:
                case 3:
                default:
                  c = Rr;
                  break;
              }
              break;
          }
          const l = s.interpolation !== void 0 ? ky[s.interpolation] : CA,
            u = this._getArrayFromAccessor(i);
          for (let h = 0, d = a.length; h < d; h++) {
            const m = new c(a[h] + "." + Xi[r.path], t.array, u, l);
            s.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m), A.push(m);
          }
          return A;
        }
        _getArrayFromAccessor(e) {
          let t = e.array;
          if (e.normalized) {
            const i = Bl(t.constructor),
              s = new Float32Array(t.length);
            for (let r = 0, A = t.length; r < A; r++) s[r] = t[r] * i;
            t = s;
          }
          return t;
        }
        _createCubicSplineTrackInterpolant(e) {
          (e.createInterpolant = function (i) {
            const s = this instanceof zr ? Ny : yg;
            return new s(this.times, this.values, this.getValueSize() / 3, i);
          }),
            (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
        }
      }
      function Yy(n, e, t) {
        const i = e.attributes,
          s = new ji();
        if (i.POSITION !== void 0) {
          const o = t.json.accessors[i.POSITION],
            a = o.min,
            c = o.max;
          if (a !== void 0 && c !== void 0) {
            if ((s.set(new R(a[0], a[1], a[2]), new R(c[0], c[1], c[2])), o.normalized)) {
              const l = Bl(fr[o.componentType]);
              s.min.multiplyScalar(l), s.max.multiplyScalar(l);
            }
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return;
          }
        } else return;
        const r = e.targets;
        if (r !== void 0) {
          const o = new R(),
            a = new R();
          for (let c = 0, l = r.length; c < l; c++) {
            const u = r[c];
            if (u.POSITION !== void 0) {
              const h = t.json.accessors[u.POSITION],
                d = h.min,
                m = h.max;
              if (d !== void 0 && m !== void 0) {
                if (
                  (a.setX(Math.max(Math.abs(d[0]), Math.abs(m[0]))),
                  a.setY(Math.max(Math.abs(d[1]), Math.abs(m[1]))),
                  a.setZ(Math.max(Math.abs(d[2]), Math.abs(m[2]))),
                  h.normalized)
                ) {
                  const g = Bl(fr[h.componentType]);
                  a.multiplyScalar(g);
                }
                o.max(a);
              } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            }
          }
          s.expandByVector(o);
        }
        n.boundingBox = s;
        const A = new pi();
        s.getCenter(A.center), (A.radius = s.min.distanceTo(s.max) / 2), (n.boundingSphere = A);
      }
      function Gd(n, e, t) {
        const i = e.attributes,
          s = [];
        function r(A, o) {
          return t.getDependency("accessor", A).then(function (a) {
            n.setAttribute(o, a);
          });
        }
        for (const A in i) {
          const o = Rl[A] || A.toLowerCase();
          o in n.attributes || s.push(r(i[A], o));
        }
        if (e.indices !== void 0 && !n.index) {
          const A = t.getDependency("accessor", e.indices).then(function (o) {
            n.setIndex(o);
          });
          s.push(A);
        }
        return (
          Xe.workingColorSpace !== on &&
            "COLOR_0" in i &&
            console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Xe.workingColorSpace}" not supported.`),
          Di(n, e),
          Yy(n, e, t),
          Promise.all(s).then(function () {
            return e.targets !== void 0 ? jy(n, e.targets, t) : n;
          })
        );
      }
      const qy =
        "data:model/gltf-binary;base64,Z2xURgIAAAAgowEA3AgAAEpTT057CiJhc3NldCI6IHsKImdlbmVyYXRvciI6ICJGQlgyZ2xURiB2MC45LjciLAoidmVyc2lvbiI6ICIyLjAiCn0sCiJzY2VuZSI6IDAsCiJidWZmZXJzIjogWwp7CiJieXRlTGVuZ3RoIjogMTA1MDAwCn0KXSwKImJ1ZmZlclZpZXdzIjogWwp7CiJidWZmZXIiOiAwLAoiYnl0ZUxlbmd0aCI6IDUyNzYsCiJieXRlT2Zmc2V0IjogMAp9LAp7CiJidWZmZXIiOiAwLAoiYnl0ZUxlbmd0aCI6IDk2ODQsCiJieXRlT2Zmc2V0IjogNTI3NiwKInRhcmdldCI6IDM0OTYzCn0sCnsKImJ1ZmZlciI6IDAsCiJieXRlTGVuZ3RoIjogMjcwMTIsCiJieXRlT2Zmc2V0IjogMTQ5NjAsCiJ0YXJnZXQiOiAzNDk2Mgp9LAp7CiJidWZmZXIiOiAwLAoiYnl0ZUxlbmd0aCI6IDI3MDEyLAoiYnl0ZU9mZnNldCI6IDQxOTcyLAoidGFyZ2V0IjogMzQ5NjIKfSwKewoiYnVmZmVyIjogMCwKImJ5dGVMZW5ndGgiOiAxODAwOCwKImJ5dGVPZmZzZXQiOiA2ODk4NCwKInRhcmdldCI6IDM0OTYyCn0sCnsKImJ1ZmZlciI6IDAsCiJieXRlTGVuZ3RoIjogMTgwMDgsCiJieXRlT2Zmc2V0IjogODY5OTIsCiJ0YXJnZXQiOiAzNDk2Mgp9Cl0sCiJzY2VuZXMiOiBbCnsKIm5hbWUiOiAiUm9vdCBTY2VuZSIsCiJub2RlcyI6IFsKMApdCn0KXSwKImFjY2Vzc29ycyI6IFsKewoiY29tcG9uZW50VHlwZSI6IDUxMjMsCiJ0eXBlIjogIlNDQUxBUiIsCiJjb3VudCI6IDQ4NDIsCiJidWZmZXJWaWV3IjogMSwKImJ5dGVPZmZzZXQiOiAwCn0sCnsKImNvbXBvbmVudFR5cGUiOiA1MTI2LAoidHlwZSI6ICJWRUMzIiwKImNvdW50IjogMjI1MSwKImJ1ZmZlclZpZXciOiAyLAoiYnl0ZU9mZnNldCI6IDAsCiJtaW4iOiBbCi0wLjA0OTc0NDE4MTMzNDk3MjQsCi0wLjAwNDEyNTMxNjE2MTY2MjM0LAotMC4wNDEyMTkwNzgwMDQzNjAyCl0sCiJtYXgiOiBbCjAuMDQ5NzQ0MTgxMzM0OTcyNCwKMC4wMTkzNzQ4NjIzMTMyNzA2LAowLjA3MDQ0MjU2NDc4NTQ4MDUKXQp9LAp7CiJjb21wb25lbnRUeXBlIjogNTEyNiwKInR5cGUiOiAiVkVDMyIsCiJjb3VudCI6IDIyNTEsCiJidWZmZXJWaWV3IjogMywKImJ5dGVPZmZzZXQiOiAwCn0sCnsKImNvbXBvbmVudFR5cGUiOiA1MTI2LAoidHlwZSI6ICJWRUMyIiwKImNvdW50IjogMjI1MSwKImJ1ZmZlclZpZXciOiA0LAoiYnl0ZU9mZnNldCI6IDAKfSwKewoiY29tcG9uZW50VHlwZSI6IDUxMjYsCiJ0eXBlIjogIlZFQzIiLAoiY291bnQiOiAyMjUxLAoiYnVmZmVyVmlldyI6IDUsCiJieXRlT2Zmc2V0IjogMAp9Cl0sCiJpbWFnZXMiOiBbCnsKIm5hbWUiOiAiQXRsYXMucG5nIiwKImJ1ZmZlclZpZXciOiAwLAoibWltZVR5cGUiOiAiaW1hZ2UvcG5nIgp9Cl0sCiJzYW1wbGVycyI6IFsKe30KXSwKInRleHR1cmVzIjogWwp7CiJuYW1lIjogImJhc2VfY29sb3JfdGV4dHVyZSIsCiJzYW1wbGVyIjogMCwKInNvdXJjZSI6IDAKfQpdLAoibWF0ZXJpYWxzIjogWwp7CiJuYW1lIjogIkF0bGFzIiwKImFscGhhTW9kZSI6ICJPUEFRVUUiLAoiZXh0cmFzIjogewoiZnJvbUZCWCI6IHsKInNoYWRpbmdNb2RlbCI6ICJQaG9uZyIsCiJpc1RydWVQQlIiOiBmYWxzZQp9Cn0sCiJwYnJNZXRhbGxpY1JvdWdobmVzcyI6IHsKImJhc2VDb2xvclRleHR1cmUiOiB7CiJpbmRleCI6IDAsCiJ0ZXhDb29yZCI6IDAKfSwKImJhc2VDb2xvckZhY3RvciI6IFsKMS4wLAoxLjAsCjEuMCwKMS4wCl0sCiJtZXRhbGxpY0ZhY3RvciI6IDAuNDAwMDAwMDA1OTYwNDY0LAoicm91Z2huZXNzRmFjdG9yIjogMS4wCn0KfQpdLAoibWVzaGVzIjogWwp7CiJuYW1lIjogIlNwYWNlc2hpcF9S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AAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIzLTAyLTI4VDIzOjM1OjI2LTAzOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMy0wMy0wMVQyMjoxOToyNy0wMzowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMy0wMy0wMVQyMjoxOToyNy0wMzowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSIqIHdzUkdCIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmM3NGQ5Y2ZmLThkZTYtMmY0My05ZjUwLTE4MDUwNmIwMjNjOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpjNzRkOWNmZi04ZGU2LTJmNDMtOWY1MC0xODA1MDZiMDIzYzkiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpjNzRkOWNmZi04ZGU2LTJmNDMtOWY1MC0xODA1MDZiMDIzYzkiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmM3NGQ5Y2ZmLThkZTYtMmY0My05ZjUwLTE4MDUwNmIwMjNjOSIgc3RFdnQ6d2hlbj0iMjAyMy0wMi0yOFQyMzozNToyNi0wMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKFdpbmRvd3MpIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PmKUdPoAAAppSURBVHic7d3fy951Hcfx3eueRGI6HdYMf2WtkxyDNRxEplQEaQUbaqRREOWBKKRQYKlMO8iEdAdFYBLR1g9GBgkRSjYLVBJ0zKCYbetu/oBSND1YrezuX9hb0JnPx+P49bmuL9fB/eRzHdzXwq5du1ZM3HfffaP96tWrR/vdu3eP9vfee+9o/+KP1o3253/zLaP9gQMHRnuAY2XlsX4AAI4NAQCIEgCAKAEAiBIAgCgBAIgSAIAoAQCIEgCAKAEAiBIAgCgBAIgSAIAoAQCIEgCAqIWvX3zO6MBXrjxttN98z19H+xvuenK0P3z1O0b7T92+NNoDvFG5AQBECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARC08sv2y0YG9S/8c7dcuHB7tzzl//Wj/wMmz53/Xm0fzFbsOHhztT9771Gj/97+9ONqv/PC+0X7LSZ8d7X+745TR/rin9472a966drRf8ehVo/n7zzh+tP/4X14Y7ZeW/J4EbxxuAABRAgAQJQAAUQIAECUAAFECABAlAABRAgAQJQAAUQIAECUAAFECABAlAABRAgAQJQAAUQsXf23d6MAzv1w12q9/5gOj/edv+dlo/7nD3x7tP3j1ttH+imtmv2dwwfb9oz3AseIGABAlAABRAgAQJQAAUQIAECUAAFECABAlAABRAgAQJQAAUQIAECUAAFECABAlAABRAgAQtXjJ2beMDtz43JdH+39d+OJof813Th/tN7579vsBVz36w9F+y9ZLR/uD20dzgGPGDQAgSgAAogQAIEoAAKIEACBKAACiBAAgSgAAogQAIEoAAKIEACBKAACiBAAgSgAAogQAIGrh6W/cPzrw5/VLo/13d9w32u/cuXO0B+CVcQMAiBIAgCgBAIgSAIAoAQCIEgCAKAEAiBIAgCgBAIgSAIAoAQCIEgCAKAEAiBIAgCgBAIhafODlS0YHbr3+9NH+scceG+0BeG24AQBECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARC2e+scTRgcuW/v0aP/4I7tH+3M3XTDaA/DKuAEARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQt3n7WcaMD1508a4b/7w/w+uQGABAlAABRAgAQJQAAUQIAECUAAFECABAlAABRAgAQJQAAUQIAECUAAFECABAlAABRswCcePwpr9JzAPAaW9z3p7cd/XrdGe/8wae3j95gx8pzVywvH/3+imsOj15/1fqXRvu7btg62u9d+7vR/u37joz2T645b7S/4xMPjvZ33bMw2r9w+ZtG+z88f+1o/6EfPzzaf++574/2wNHzFRBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQNTCR7/wnqNfrz5xzZVHnhm9wc2Pn7m0tHT0+82bN49ef+fOnaP9R764cbT/974TRvtNmzaN9hcduXu0v/PZ2efz4EO/H+1/fveu0X7Dhg2jPfD6MbsBPP+PZ6dvMPrrD8BrxldAAFECABAlAABRAgAQJQAAUQIAECUAAFECABAlAABRAgAQJQAAUQIAECUAAFECABC18OsrzhoduPnQmaP9oUOHRvv9+/eP9q+2+z9z9mj/i1M+Odrv2bNntN+2bdto/9Ctl472F2376Wj/n8UTR/stW2fPc/DAE6M9cPTcAACiBAAgSgAAogQAIEoAAKIEACBKAACiBAAgSgAAogQAIEoAAKIEACBKAACiBAAgSgAAohYPL351eGTHaL2wsDDa33zhl0b7l963ONrfdttto/3089mzZ/b5nHfue0f7dQ//d7RfefWto/3Lq04a7bf6//7wf8sNACBKAACiBAAgSgAAogQAIEoAAKIEACBKAACiBAAgSgAAogQAIEoAAKIEACBKAACiBAAganFxwx2jA09tvGm0f/lb14/2N/7m9tH+1Tb9fFYcXDOaH1lcNdp/7CfXjvZnn37LaH/TabPfb1heXh7tgdcPNwCAKAEAiBIAgCgBAIgSAIAoAQCIEgCAKAEAiBIAgCgBAIgSAIAoAQCIEgCAKAEAiBIAgKiFjZefOjpw53W/Gu23bL10tD944InRHoBXxg0AIEoAAKIEACBKAACiBAAgSgAAogQAIEoAAKIEACBKAACiBAAgSgAAogQAIEoAAKIEACBqYXl5+Vg/AwDHgBsAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQJQAAEQJAECUAABECQBAlAAARAkAQNT/AKs71lYO1w58AAAAAElFTkSuQmCCAAABAAIAAAADAAEAAwAEAAUAAwAFAAEABgAHAAgABgAIAAkABgAJAAoACwAMAA0ADAALAA4ADwAQABEAEAAPABIAEwAUABUAFQAWABMAFwAVABQAGAAZABoAGQAYABsAHAAdAB4AHQAcAB8AIAAhACIAIQAgACMAJAAlACYAJgAlACcAKAApACoAKAArACwAKQAoAC0AKQAuAC8AMAAxADIAMQAwADMAMwAwADQANQA2ADcANQA3ADgANQA5ADYAOQA1ADoAOgA7ADwAPQA+AD8APgA9AEAALwAuAEEALgApAC0AQQAuAEIAQwBEAEUAQwBGAEcARgA7AEcARwBEAEMASABJAEoASQBIAEsAFgAVAEwATABNABYATgBPAFAATgBRAE8AUQBSAE8AUQBTAFIAVABVAFYAVQBUAFcAWABZAFoAWABbAFwAWwBYAFoAXQBeAF8AXQBgAGEAYABiAGMAYABdAF8AZAAGAAoAZQBmAGcAZQBnAGgAaABpAGoAaABnAGkAaQBrAGwAaQBnAGsAaQBtAGoAbgBvAHAAbgBxAHIAcQBzAHQAcgB1AG4AdgB3AHgAdwB2AHkAegB7AHwAewB6AH0AfAB7AH4AfwCAAIEAgAB/AIIAgQCDAH8AggCEAIAAggCFAIYAhQCCAH8AhQB/AIMAhgCHAIIAiACJAIoAiQCLAIoAigCMAIgAjQCOAI8AjQCQAJEAkACNAJIAkQCTAJQAjgCVAJYAjgCNAJEAlQCOAJEAlQCUAJcAlQCRAJQAmACZAIkAmQCYAJoAmgCbAJwAmgCcAJ0AngCfAKAAnwCeAKEAoACiAKMApAClAKYApQCnAKYAqACpAKoAqQCoAKsAqgCsAK0AqgCtAKgAqwCuAKkArwCwALEAsACvALIAswC0ALUAtACzALYAtwC4ALkAuAC3ALoAugC7ALgAogCgAJ8AvAC9AL4AvQC8AL8AvgDAAMEAvgDBALwAvwADAAAAvwC8AAMAwgDDAMQAxADFAMYAxADDAMUAxwDIAMkAyADHAMoAywDMAM0AzADLAM4AzwDQANEA0ADSANEA0ADPANMA0QDSANQA0wDVANYA1wDYANkA2ADXANoA2wDcAN0A3ADbAN4A3wDgAOEA4ADfAOIA4wDkAOUA5QDkAOYA5wDoAOkA6QDoAOoA6wDsAO0A7QDuAOsA7wDwAPEA8ADvAPIA8gDzAPQA9QD2APcA9gD1APgA+QDwAEUA+QBFAEQA+QDxAPAA+gD7APwA+wD6AP0A/QD+AP8AAAEBAQIBAQEDAQIBAwEEAQUBKwAoACoALAAGAQcBBgEsACsACAEJAQoBCQEIAQsBDAENAQ4BDQEPAQ4BEAERARIBEgETARABFAEVARYBFQEUARcBTQBMABgBGQEaARsBGgEZARwBHQEeAR8BHwEgASEBHwEeASABIgEjASQBIwEiASUBIwEmASQBJQEnASgBKQEqASsBKgEsASsBKgEpAS0BLQEuASoBLQEvATABMQEyATMBMgExATQBMwE1ATEBMwEyATYBNwE4ATkBOAE3AToBOwE8AT0BOwE+AT8BPAE7AUABQQFCAUMBQgFEAUMBQgFFAUQBQgFBAUYBQwFEAUcBSAFJAUoBSQFIAUsBSgFMAUgBSwFNAUkBTgFPAVABTwFOAVEBUgFTAVQBUwFSAVUBVAE1AVIBVgFXAVgBVwFWAVkBWgFbAVwBWgFdAVsBXQFeAVsBXQFaAV8BXgFdAWABYQFiAWMBYgFhAWQBZQFmAWcBZgFlAWgBaQFqAWsBagFpAWwBawFtAW4BbwFwAXEBbwFyAXMBcgFvAXQBdQF2AXcBdgF1AXgBeQF6AXsBegF5AXwBfQF+AX8BfgF9AYABgQGCAYMBggGBAYQB1QDTAM8AOwBGADwAOwA6ADUA/gD9APoAhQGGAYcBhwGGAYgBiQGKAYsBigGJAYwBjQGOAY8BjgGNAZABkQGSAZMBlAGTAZIBlQGWAZcBlwGYAZUBBAEDAQEBBAGZAQUBmQGaAQUBmwGcAZ0BnAGbAZ4BnQGfAZsBoAGhAaIBoQGjAaIBpAGlAaYBpQGkAacBpQGoAaYBpwGpAaoBqQGrAaoBqQGnAaQBrAGtAa4BrQGsAa8BrgGwAawBuwC6AKgBqAGlAbsAmwCaAJgAmwCxAZwAnQCyAbMBnQCcALEBtAG1AbYBtQG0AbcBtwG4AbkBfgC6AXwArAB8ALoBrAC6Aa0AuwG8Ab0BvAG+Ab8BvQG8Ab8BiwCJAJkAwAGSAI8AwAHBAcIBwQHAAY8AjwCSAI0AwwHEAYMAxAHDAcUBgwCBAMMBxgHHAcgByAHHAckBygHLAcwBywHKAc0BzgHPAdABzwHOAdEB0gHTAdQB0wHSAdUB1gHXAdgB1wHWAdkB2gHbAdwB2wHaAd0B3gHfAeAB3wHeAeEB4gHjAeQB4wHlAeYB5QHjAeIB5wHoAekB6QHoAeoB6wHsAe0B7AHrAe4B7wHwAfEB8gHzAfQB9AHzAfUB9AH1AfYB9wH4AfkB+AH3AfoB+wH8Af0B/AH7Af4B/wEAAgEC/wEBAgICAQIDAgQCBQIGAgcCBgIFAggCBwIJAgoCTAFKAQsCDAIIAg0CDQIIAgUCDgIPAhACDwIOAhECEAISAhMCFAIVAhYCFAIWAhcCFwIWAhgCGQIaAhsCGQIcAhoCHQIeAh8CHQIgAh4CHgIhAh8CHgIiAiMCJAIlAiYCJAInAigCJQIkAigCKQIqAisCKgIpAiwCLAItAi4CYwBhAGAALwJwAG8ALwJjAGIALwJiADACcAAvAjACbwBuAHUAMQIyAjMCMQIzAjQCMQI1AjICMgI2AjcCMwIyAjgCOAI5AjoCOQI4AjICOQIyAjcCOgI5AjsCPAI9Aj4CPQI8Aj8CQAInAiQCQQJCAkMCQQJEAkICQQJFAkYCRwJIAkkCSAJHAkoCSwJMAk0CTAJLAk4CTwI5AFACTwL0APMATwI2ADkAUQJSAlMCUgJRAlQCVQJWAlcCVgJVAlgCWQJaAlsCWgJZAlwCXQJeAl8CXgJdAmACYQJiAmMCYwJkAmECZQL7AGYCZQL8APsAZwJoAmkCaQJqAmcCawJsAm0CbAJrAp8BnwGdAWwCbgJvAnACbwJuAnECcgJzAjQAcwJyAnQCcwJ1AnYCNABzAjMAdwJ4AnkCeAJ3AnoCewJ8An0CfAJ7An4CfwKAAoECgAJ/AoIC9ABPAlAC8wDyAO8AgwKEAoUChAKDAoYCdgKHAnMCiAKJAooCiQKIAosCjAKNAo4CjQKPAo4CkAKRApICkQKQApMCkgKUApACNgGVAjMBlgKXApgClwKWApQCmAKZApYClAKSApcCmgKbApwCmgI1AVQBNQEzAVIBPwFAATsBnQJrAJ4CawCfAmwAawCdAp8CoAKhAqICoAKjAqQCoQKgAqUCogKmAqcCpAKlAqACbACoAqkCbACfAqgCqgJmAGUAqwKsAq0CrAKrAq4CLQIsAikCLQKvAi4CEgIQAg8CEgKwAhMCbQFrAWoBbQGxArICbgFtAbICLwEtASkBMAGzAi0BJwElASIBIQG0ArUCIQEgAbQCxgC2ArcCxgDFALYCdAC4ArkCdAByAHEAugK7ArwCugK8Ar0CvgK/AsACvwK+AsECwgLDAsQCwgLEAsUCxgLHAsgCxwLJAsoCxwLGAssCygLIAscCzALKAskCzALJAs0CzgLPAtACzwLOAtECpgKiAqECmQKYAtIC0wLUAtUC1ALTAtYC1QLXAtgCswIwAdkCswLaAi4B2gLbAi4B2gKzAtwCLgHdAioBLgEtAbMC3ALZAt4C3wLgAuEC4ALfAuIC4wLkAuUC4wLmAucC5ALjAugC5ALpAuUC6ALnAuoC1wLrAtgC1wLVAtQC2QLcArMCIQIjAuwCIQLtAh8C7QLuAu8C7QIhAu4CCQIHAgYCCgLwAvECTQFLAfIC8gLzAk0BRQH0AvUCRQH2AvQCRAFFAfUC9wL4AvkC+AL3AvoCRwH2AkMB9gL7AvwC9gJHAfQC/QL+Av8C/gL9AgADAAMBA/4CAgMDAwQDAgMFAwYDAwMCAwYDmwKaAlQB8AIKAgkC5wLoAuMCBwMIAwkDCAMKAwkDCAMHAwsDCwMMAw0DDgMPAxADDwMOAxEDEgMTAxQDEwMSAxUDFAMWAxIDAQMAAxcDGAMZAxoDGAMbAxkDGwMcAxkDDAMLAwcDHQO+AL0AHQMeA74A7gLsAh8DFgMUAyADIAMhAxYD8wLyAiIDIwMkAyUDJAMjAyEDIQMgAyQD+wL2AkUB5gLjAiYDJgMnA+YCKAMpAyoDKAMqAysDKgMFAysDKwMFAywDLQMuAy8DLgMtAzADLgMxAzIDMwPpAjQDMwM1AzYDMwMmA+MCMwM3AyYDMwPjAuUCOAM5AzoDOQM4AzsDMQM8AzIDMQMuAzADPQM+Az8DPgNAA0EDPwM+A0IDQwNEA0UDQwNFA0YDRgNFA0cDJwMmAzcDNwMzAzYDSANJA0oDSgNJA0sDBQMCAywDTANNA04DTgNNA08DUANRA1IDUANTA1QDUwNQA1IDVQNWA1cDVgNVA1gDWQNaA1sDWwNcA10DWwNeA1kDuAG3AbQBuQGzAbIBvgG8AV8DsAGuAWADYANhA7ABYgNjA2QDYwNiA2UDZgNnA2gDZwNmA2kDaANqA2YDawNsA20DawNtA24DbQNvA24DbANrA3ADcANrA5MAcQNyA3MDcgNxA3QDcwN1A4QAcwN2A3UDcwN3A3EDdgNzA3IDqwGpAWEDYQNgA6sBsgGdALEBswG5AbgBeAN5A3oDeQN4A3sDrgCrAGoDagNoA64AlwCUAGsDlwBrA24DkwCRAJAAkwBrA5QAhwCGAHcDdwNzA4cAhACCAIcAhACHAHMDfAN9A34DfQN8A38DgAMBAAUAgQOCA4MDgwOEA4EDhQODA4IDhgOHA4gDhwOGA4kDigOLA4wDiwOKA40DjgOPA5ADjgORA5IDjgOSA5MDlAOVA5YDlQOUA5cDmAOZA5oDmgObA5gDnAOdA54DnQOcA58DoAOhA6IDogOjA6ADpAOlA6YDpAOnA6gDpwOpA6gDpwOkA6YDqgOrA6wDqgOtA64DqgOuA6sDrwOwA7EDrwOyA7MDsgO0A7MDsgOvA7UDtQO2A7IDtwO4A7kDuQO4A7oDuwO8A6UDvAO9A6UDpQOkA7sDvgO/A8ADwAO2A8EDwgO/A74DwgO+A8MDxAPFA8YDxAPHA8UDjwOOA5MDkAPIA8kDygPLA8wDywPKA80DzAPOA88D0APRA9ID0APTA9EDWQBYANQDXgDVA9YDXgBdANcD2AOEA4MDagDZA2gA2QNqANoDuAJ0AHMAuALbA7kC2wPcA90DuQLbA90D3gPfA+AD3wPeA+ED4gPjA+QD4wPlA+YD5APnA+ID6APpA+oD6QPoA+sD6gPsA+0D6wPuA+8D8APuA+gD8APqA/ED8APoA+oD8QPtA/ID8QPqA+0D8wP0A/UD9AP2A/UD9APzA/cD+AP5A/oD+AP7A/wD+wP4A/0D/AP5A/gD/QP+A/sD+gP/A/0D+gP9A/gD/wP6AwAE/wMBBP0DAgQDBAQEAwT1A/YDAwQCBPUDBAQFBAIEBgQHBAgEBgQIBAkEBwQKBAgEBwQLBAoEDAQNBA4EDgQNBA8EEAQRBBIEEAQTBBEEEAQUBBMEEQQVBBIEFgQXBBgEFwQWBBkEGgQbBBwEGwQaBB0EHgQfBCAEHwQeBCEEIAQiBCMEwQAEALwABAADALwAJAQlBCYEJgTGALcCJgS3AiQEJwQoBCkEJwQqBCgEKwQsBC0ELAQrBC4ELwQwBDEEMAQvBDIEMQQzBC8EMgQ0BDUENgQ3BDgENwQ2BDkEtAOyAzoEOwQ8BD0EPQQ8BD4EPwRABEEEQARCBEEEQwREBEUERQRGBEMENQQwBDIERwRIBEkESQRKBEcESwRMBE0ETQRMBE4ETwRQBFEEUARPBFIEUARTBMMDUQRUBE8EVQRWBFcEVgRVBFgEUwTCA8MDUwRQBFIEWQRaBFsEWgRZBFwEWwRdBFkEXAReBFoEXwRgBGEEYQRiBGMEYQRgBGIEqQOnA2QEZARlBKkDZQRkBGYEZwRoBGkEaARnBGoEawRsBG0EbQRsBG4EbwRwBHEEcQRwBHIEcwR0BHUEcwR2BHQEzgPMA8sDyAOQA48DdwR4BHkEdwR5BHoEewR8BH0EfQS1AnsEfQQhAbUCJgEjAX4EfgR/BCYBLAEqAd0C3QKABCwB3QIuAdsCgQSCBIMEggSBBIQEgwSFBIYEgwSHBIEEiASJBIoEiQSIBIsEjASNBI4EjQSMBI8EjQSQBJEEjwSQBI0EkgSTBJQEkwSSBJUEkwSVBJYElQSXBJYEmASZBJoEmASbBJwEmQSdBJ4EmgSZBJ4EnwSgBKEEoASfBKIEhgSjBKQEowSGBKUEpQSGBIUEpgSnBKgEpwSmBKkEqgSrBF4BqgReAWABqwSqBKwEqwSsBK0ErASqBK4ErwSwBLEEsASvBLIEswS0BLUEtgS1BLQEtwS4BLECsgKxArgEcAFvAXMBuQS6BLsEugS5BLwEvQS+BL8EvgS9BMAEwQTCBMMEwwTCBMQExQTGBMcExgTFBMgEMwQxBMkEtgO1A8EDtgPAA78DXQRbBMoEywTMBM0EzQTOBMsEzwTQBNEE0ATPBNIE0wTUBNUE1ATTBNYE1wTYBNkE2ATXBNoE2wTcBN0E3QTcBN4EYwRiBN8EYwTfBOAE4ATfBOEE4gTjBOQE4wTiBOUE5QTmBOcE6ATpBOoE6gTpBOsE7ATtBO4E7gQjBCIE7gTvBOwE7wTwBPEE8QTyBPME8QTsBO8E9AT1BPYE9QT0BPcE9wT4BPkEIgQgBB8EIwTuBO0EBQQEBPoE+gQEBPsE+gT8BAUE+wT9BPwE/gT/BAAF/wT+BAEFAAUCBf4E5gMDBeMDAwXkA+MDFATmA+UD5QMTBBQEBAUFBQYFBAUHBQgFBQUEBQkFCgULBfkDCwUKBQwF+QP8AwoF7wMNBQ4FDQXvA+4D7gPrA+gDDwUQBREFEAUPBRIFEwUUBRUFFQUUBRYFFwUYBRkFGAUXBRoFGwUcBR0FHAUbBR4FHwUgBSEFIQUgBSIFIwUkBSUFJAUjBSYFJwUoBSkFKAUnBSoF5gErBeMBLAUtBS4FLgUvBSwFMAUxBTIFMQUwBTMFNAU1BTYF9gE3BfQBOAU5BToFOQU4BTsFPAU9BT4FPQU8BT8FAwIBAgACQAVBBUIFQQVABUMFQwVEBUEFmwSYBJoERQVGBUIFRgVABUIFRwVIBUkFSAVHBbACsAISAkgFFQJKBRYCSwVMBU0FTgVNBUwFIgIeAiACIwIhAh4CTwVQBVEFTwVSBVMFUgVPBVQFVQVWBa8CVgVVBVcFrwItAlUF1QNeANcD1QNYBdYDWAVZBVoFWQVYBdwDWgXWA1gF3APbA1kFNQIxAlsFNQJcBTICXAU2AjICNgJdBV4FXQU2AlwFXwVgBWEFYAVfBWIFUAVPBVMFRQJBAkMCYwVkBWUFZAVjBWYFZwVoBWkFaAVnBWoFsANUBGsFsAOvA7MDbAVtBW4FbQVsBW8FcAVxBXIFcQVwBXMFdAV1BXYFdQV0BXcFeAV5BXoFeQV4BXsFfAV9BX4FfgV9BX8FgAVaBF4EgQWCBYMFgwWCBYQFhQXnBOYE5wSFBYYF5gTlBOIEhwWIBYkFiQWIBYoFiwWMBY0FiwWsA4wFrAOrA4wFjgWPBZAFjwWOBZEFkgWTBZQFkwWSBZUFlgWXBZgFlwWWBZkFawWxA7ADVARRBGsFmgWbBZwFmwWaBZ0FngWfBaAFoAWfBaEFogWjBaQFpAWjBaUFpgWnBagFpwWmBakFqgWrBawFqgWtBa4FrAWrBa8FsAWHBIMEsQWuBbIFrgWtBbIFrQWqBawFswW0BaUEswWlBIUEhQSDBIIEtQVtALYFbQBpAGwAbQCpArYFbQBsAKkCtwW4BbkFuAW3BboFugW7BbgFvAW3Bb0FvQW3BbkF2gO+BdkDvwXABcEFwAW/BcIFgATdAsMFwwXbAsQFfwR+BMUFxgXHBcgFxwXGBckFygXLBcwFywXKBc0FzgXPBdAFzwXOBdEF0gXTBdQF0gXVBdYF0wXSBdcF1QXYBdYF1QXSBdQF1gXYBdkF2gXbBdwF2wXaBd0FuwW6Bd4F3wWxBeAF4AWxBbIF4QXiBeMF4gXhBesC6wLXAuIF2wLDBd0C2wLaAuQF5AXEBdsC5QXmBecF5gXoBecF6QLpBTQD6QLkAuoF6QIzA+UC6gXrBekCxAXkBewF7ALuAiECRAVDBe0F7QXuBUQFnQTvBZ4EnQTwBe8F8QWTBJYE8QWWBPIF8QXzBfQF9QX2BfcF9gX1BfgF9AX5BfEF9AWXBJUElwT0BfMF8wXxBfIF+gX7BfwF+wX9BfwF/QX+Bf8FAAYBBgIGAAYDBgQGAwYABgUGtAWzBQYG7gXtBQcG6wXqBQgGCgMIAwkGCQYKBgoDCwYMBg0GDAYLBg4GDwYQBhEGEAYPBhIGEgYPBhMG/gX9BfsFFAYZAxwDCgYJBhUGwAC+AB4DFgYSBhMGFgYXBhgG8AUZBu8FGgYYBhcGGAYaBhsGFwYWBhMG+QX0BRwG6QXpAusFNAMdBjUDHgYfBiAGHgYCBgEGHwYeBgEGIQYgBh8GIgYjBjwDPAMxAyIGJAY8AyMGJQYmBicGJgYoBicGQAM+Az0DRAMpBkUDHQY0A+kFNQMzAzQDKgYrBiwGLAYtBioGAQYABgQGLgYvBjAGLwYxBjAGUQNQAzIGMwY0BjUGNAYzBjYGXANbA1oDAgUABTcGNwY4BgIF/AT6BPsEBwUEBQYF+AT3BPQE+QTzBPIEOQY6BjsGOgY5BjwGPQY+Bj8GPgZABj8GQQZCBkMGQgZBBkQGQwZFBv4DQwZGBkEGQwZHBkUGRwZDBkIGSAZJBkoGSAZLBkkGSQZMBkoGSwZIBk0GTQZIBuwD8gTxBPAE8wT5BPgE/QT7BDgGOAY3Bv0ETgZPBlAGTwZOBlEGFQRSBhIEUgY9Bj8GUgYVBD0GAQT/A0YGRgZDBgEE/gMBBEMG/gP9AwEE8gNIBkoG8gPtA0gG7ANIBu0D7APqA+kDUwZUBlUGVAZTBlYGVwZYBlkGWAZXBloGWwZcBl0GXAZbBl4GXAZfBmAGXgZhBlwGYgZjBmQGYwZiBmUGYwZmBmcGZQZoBmkGZQZiBmgGagZrBmwGawZqBm0GbgZvBnAGbgZxBnIGcQZuBnMGYQZ0Bl8GYQZeBnUGdQZ2BmEGdgZ1BncGeAZ5BnoGeQZ4BnsGegZ8Bn0GZgZjBmUGZgZ+BmcGfgZmBn8GfwaABoEGggZkBoMGggZiBmQGggaBBoAGgQZ+Bn8GgQaCBoMGhAaFBoYGhQaEBocGhQaIBoYGhQaHBokGigaLBowGiwaKBo0GjgaPBpAGjwaOBpEGkgaTBpQGkwaVBpYGkwaSBpcGlQaTBpcGmAaZBpoGmQaYBpsGnAadBp4GnQacBp8GoAahBqIGoQajBqIGpAalBqYGpQakBqcGqAapBqoGqQaoBqsGqgasBqgGqwatBqkGrgavBrAGrwauBrEGsAayBrMGtAa1BrYGtQa0BrcGuAa5BroGuQa4BrsGvAa9Br4GvAa/BsAGvwa8Br4GvQa8BsEGwgbDBsQGwwbCBsUGxgbHBsgGxwbGBskGygbLBswGywbKBs0GzgbPBtAG0QbQBs8G0gbTBtQG0wbSBtUG0wbVBtYG1QbSBtcG2AbZBtoG2QbYBtsG2wbcBt0GbwbaBtkGbwbZBnAGcAZzBm4G3QbcBnEG3AbbBtgG3AZyBnEGrQarBt4GsgawBq8GswbfBrAG4AbhBuIG4QbgBuMG3wazBuQG5QbmBucG5gblBugG6QbqBusG6QbrBuwG6QbtBu4G7QbpBuwG7wbwBvEG7wbyBvAG8wb0BvUG9AbzBvYG9wb4BvkG9wb5BvoG+wb8Bv0G/Ab7Bv4G/wYABwEHAAf/BgIHAQcDBwQHBQcGBwcHBgcFBwgHCQcKBwsHCgcJBwwHDQcOBw8HDgcNBxAHEQeuBhIHEQcTB64GEwexBq4GFAexBhMHFAcVBxYHFAcXBxgHGQcaBxsHGQccBxoHrAaqBh0HHQceB6wGHwcgByEHIAcfByIHIgcjByAHXwZcBmEGYAYWBxUHJAclByYHJQckBycHJwcoBykHfAZ6BnkGfQYeByoHKwcsBy0HLAcuBy0HLwcwBzEHMAcvBzIHMQczBzQHMgc1BzYHNwc4BzkHOAc6BzkHdAZhBnYGdAYWB18GFwcUBxYHFgdgBl8GFgd0BhcHNAc7BzwHOwc0BzMHMwcxBzAHPQc+BysHPgcsBysHHgd9BnwGHgcdByoHKAc/B0AHKAcnByQHFQcUBxMHQQdCByMHQgdBB0MHIwciB0EHBAdEB0UHRAcEBwMHAwcBBwAHQAcpBygHRgdHBz0HRwc+Bz0HNQcyBy8HSAdJBz8HSQdABz8HSgdLB0wHSwdKB00HTgdPB1AHTwdOB1EHTwdSB1MHUAdTB1QHVQdWB1cHVgdYB1kHVgdVB1oHVwdWB1kHVwdbB1UHXAddB14HXQdcB18HYAdhB2IHYAdjB2QHYwdgB2UHYwdmB2cHUwdQB08HUwdoB2kHVAdpB2oHaQdUB1MHawdsB20HbAdrB24HbgdvB2wHWwdXB3AHcQdbB3AHcgdbB3EHWAdzB3QHcwdyB3EHcwdYB3UHdAdZB1gHdQdyB3MHdgd3B3gHdgd4B3kHdwd2B3oHegd2B3sHfAd9B34Hfgd/B3wHgAeBB4IHgQeDB4IHhAeFB4YHhQeHB4gHhQeIB4YHhweFB4kHigeLB4wHiweKB40HjgePB5AHjweOB5EHkgeTB5QHlAeTB5UHlgeXB5gHlweWB5kHmgebB5wHmgecB50HmweeB58HnQecB6AHnQegB6EHogejB6QHoweiB6UHpQemB6MHpweoB6kHqAenB6oHqwesB60HrAerB64HrwewB7EHrwexB7IHsAevB7MHtAevB7IHtQe2B7cHtge4B7cHuQe6B7sHuge8B7sHvQe+B78Hvge9B8AHwQfCB8MHwQfEB8IHxQfGB8cHxgfIB8kHyAfFB8oHyAfGB8UHywfMB80HzAfLB84HzQdnB8sHzgdhB8wHZgdjB2UHZgfLB2cHYQfOB2IHYQdgB2QHpgelB88HzwfQB9EH0gfTB9QH0wfSB9UH0AfPB6UH1gfXB9gH1wfWB9kH2gfbB9wH2gfdB94H3QfaB98H4AfhB+IH4QfgB+MH5AflB+YH5QfkB+cH6AfpB+oH6QfoB+sH2wfaB94H7AftB+4H7QfsB+8H8AfxB/IH8QfwB/MH8wf0B/EH9Qf2B/cH9gf1B/gH+Qf6B/sH+gf5B/wH/Qf+B/8H/gf9BwAIAQiiBwIIAwgCCKIHAwiiB6QHBAgDCKQHBAgFCAMIBggHCAgICQgICAcIngebB5oHCggLCAwICggMCA0IDQgOCA8IDQgMCA4IUgdPBxAIUgcRCGgHEAgRCFIHEggTCBQIEwgSCBUIFAgWCBIIbwduBxcIFwgYCG8HGQgaCBsIGwgaCBwIHQgeCB8IHggdCCAIHwghCB0IIAgiCB4IIwgkCCUIJAgjCCYIaAdTB1IHJwgRCAQIJwgECCgIEQgnCGgHEQgQCAUIKQgqCCIIKggpCCsIIgggCCkILAgZCC0ILQgZCBsILgifBxgIGAgXCC4IGAifB54HFggUCC8IBQgECBEIDwgwCDEIDwgOCDAIMggzCPQHMwgyCDQI9AfzBzIINQgWCDYINggWCC8INwgsCDgIOAgsCC0IIQgfCDkIOgg1CDsIOwg1CDYIWgdVBzwIPQg+CD8IPgg9CEAIPwhBCEIIPwhDCEQIRQhGCEcIRghFCEgIRwhJCEUISAhKCEYISghICEsISwhMCEoITQhOCE8ITQhQCFEITQhSCFMITQhTCE4ITghUCFUITghWCE8IVghVCFcIWAhBCEQIWAhZCEEIQQg/CEQIQQhaCEIIWwhcCF0IXAhZCF4IXAhbCF8IXQhgCFsIXQhhCGIIXwhaCFkIYwhkCGUIYwhmCGcIZghjCGUIZQhkCGgIaAhpCGoIYAhdCGsIawhiCGwIbQhuCG8IbghtCHAIbwhxCHIIcwh0CHUIdAhzCHYIdQh3CHMIdwh4CHkIdgh6CHQIewh8CH0Iewh+CHwIewh9CH8IfQiACH8IWQhYCF4IWQhcCF8IaQhoCGQISQhHCIEIggiDCIQIgwiCCIUIhgiHCIgIiQiICIcIiQh4CIgIeAh3CHUIeAiJCHkIigiLCIwIjAiLCI0IjgiPCJAIjwiOCJEIkQiSCJMIlAiVCJYIlAiXCJUIlAiWCJgImAiWCJkIcQhvCG4IcghxCJoImwhyCJoImwicCJ0IVQiXCJQIVQhUCJcIVQiUCFcIVQhWCE4IVwiUCJgIngifCKAInwihCKAIoAiiCJ4IogijCJ4IoQifCKQIUQhSCE0IUQilCKYIUghRCKcIpwimCKgIpQhRCFAIUAhNCE8IpginCFEIqQiqCKsIqQirCKwIrQisCKsIrgivCLAIrwixCLAIsQiyCLMIqgipCLQI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N7I8PaHOITyBDzO8F7s2PbB0TDyBic28Bc47PWtAHzyBic281bo3PVXCSjyCDzO8ykFBPU3yIzw90PO7hdQ8PVthITw90PO7RRhFPfAauTuBDzO8cAQ/PW+hAjyBic28XRdEPVbaqjuAic284iBAPSyBBTyBDzO8aaVEPebWCTyBDzO8jsBLPVwVqjuAic283mhEPQlxCzyBic28HaZLPR6npDuBDzO8q61EPW+fBzw80PO7HaZLPR6npDuBDzO8aaVEPebWCTyBDzO8vZ5LPSpQnDs50PO7yhk6PbhvXTyCDzO8cKxAPSAfJzyBic28wVQ5PXmFXTyBic28fRpBPWLsJTyBDzO8KKYfPZYvBjyBic28G/wePeb3CTyBDzO82VkZPWtbxDuBDzO8CWsaPZwPtDuAic28AvodPRnxKjyBic289O4iPeToITyBic28EiooPawQTjyBic2892UoPfNzTDyCDzO8tcMiPcKpJDyBDzO89O4iPeToITyBic28p20oPfc+TDw90PO7tcMiPcKpJDyBDzO892UoPfNzTDyCDzO8+3caPcJFDzyBDzO8e8MSPfWstjuAic28pKoSPU8OszuBDzO8vjIaPT4eEDyBic28hlYmPaqeXzw+0PO7d1UePcflKTyBDzO8zyImPWGkXzyEDzO8AvodPRnxKjyBic28vjIaPT4eEDyBic28ykFBPU3yIzw90PO7aaVEPebWCTyBDzO8fRpBPWLsJTyBDzO8q61EPW+fBzw80PO74iBAPSyBBTyBDzO8Bc47PWtAHzyBic28cAQ/PW+hAjyBic28N7I8PaHOITyBDzO8cAQ/PW+hAjyBic28cKxAPSAfJzyBic283mhEPQlxCzyBic28Bc47PWtAHzyBic28fRpBPWLsJTyBDzO83mhEPQlxCzyBic28cKxAPSAfJzyBic28aaVEPebWCTyBDzO8+3caPcJFDzyBDzO8G/wePeb3CTyBDzO89O4iPeToITyBic28tcMiPcKpJDyBDzO8KKYfPZYvBjyBic28vjIaPT4eEDyBic28AvodPRnxKjyBic28KKYfPZYvBjyBic289O4iPeToITyBic28hOQPPPBGcbvArQG9zZokPIuBHLvw9Qu9zZokPDufE7vGrQG9hOQPPFgYeruOoQu9hOQPPPJnbLu7+fe8Ad4PPKoHWDzQrQG9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AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPwAAAAAAAIA/AAAAAAAAgD8AAAAAAACAPw==";
      function Xy(n) {
        const e = new fy({ canvas: n, antialias: !0 }),
          t = new Nv();
        t.background = new Ue(0);
        const i = new nn(72, 1, 0.1, 100);
        i.position.set(0, 4, 12), t.add(new vw(16777215));
        const s = new mg(16777215, 1);
        s.position.set(5, 10, 7.5), t.add(s);
        function r() {
          const u = n.clientWidth,
            h = n.clientHeight;
          (n.width !== u || n.height !== h) && (e.setSize(u, h, !1), (i.aspect = u / h), i.updateProjectionMatrix());
        }
        window.addEventListener("resize", r);
        const A = new dy();
        let o = null;
        A.load(
          qy,
          (u) => {
            (o = u.scene), o.scale.setScalar(0.5), o.position.set(0, 0, 0), t.add(o);
          },
          (u) => {},
          (u) => console.error("Error loading spaceship:", u)
        );
        function a(u) {
          const { pitch: h, roll: d, yaw: m } = u;
          o && ((o.rotation.x = h), (o.rotation.y = Math.PI + m), (o.rotation.z = -d));
        }
        function c() {
          r(), e.render(t, i);
        }
        function l() {
          window.removeEventListener("resize", r), e.dispose(), t.clear();
        }
        return { setOrientation: a, render: c, stop: l };
      }
      let jo,
        So = "IMAGE",
        Ol,
        Io = !1;
      async function Jy() {
        const n = await Ts.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        jo = await Ct.createFromOptions(n, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
            delegate: "GPU",
          },
          outputFaceBlendshapes: !0,
          runningMode: So,
          numFaces: 1,
        });
      }
      Jy();
      const mA = document.getElementById("webcam"),
        Zy = new i0(0.3);
      function $y() {
        return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
      }
      $y()
        ? ((Ol = document.getElementById("webcamButton")), Ol.addEventListener("click", e3))
        : console.warn("getUserMedia() is not supported by your browser");
      function e3() {
        if (!jo) {
          console.log("Wait! faceLandmarker not loaded yet.");
          return;
        }
        (Io = !Io), (Ol.innerText = Io ? "DISABLE PREDICTIONS" : "ENABLE PREDICTIONS");
        const n = { video: !0 };
        navigator.mediaDevices.getUserMedia(n).then((e) => {
          (mA.srcObject = e),
            mA.addEventListener("loadeddata", () => {
              Zy.reset?.(), Tg();
            });
        });
      }
      let jd = -1,
        yc;
      const t3 = {
          NOSE_BRIDGE: 6,
          FOREHEAD: 10,
          LEFT_CHEEK: 280,
          RIGHT_CHEEK: 50,
          LEFT_EYE_CORNER_OUTER: 263,
          RIGHT_EYE_CORNER_OUTER: 33,
          LEFT_EYE_CORNER_INNER: 362,
          RIGHT_EYE_CORNER_INNER: 133,
          LEFT_TEMPLE: 284,
          RIGHT_TEMPLE: 54,
          LEFT_EAR: 34,
          RIGHT_EAR: 264,
        },
        n3 = Object.values(t3),
        i3 = document.getElementById("three-canvas"),
        Hd = Xy(i3);
      async function Tg() {
        So === "IMAGE" && ((So = "VIDEO"), await jo.setOptions({ runningMode: So }));
        const n = performance.now();
        if ((jd !== mA.currentTime && ((jd = mA.currentTime), (yc = jo.detectForVideo(mA, n))), yc.faceLandmarks))
          for (const e of yc.faceLandmarks) {
            const i = n3.map((o) => e[o]).map(s3),
              { pitch: s, roll: r, yaw: A } = s0([1, 2, 3].map((o) => i[o]));
            Hd.setOrientation({ pitch: s, roll: r, yaw: A }), Hd.render();
          }
        Io && window.requestAnimationFrame(Tg);
      }
      function s3(n) {
        return { x: n.x - 0.5, y: n.y - 0.5, z: n.z };
      }
    </script>
    <style rel="stylesheet" crossorigin>
      html{background-color:#000}body{margin:0}video{display:block;position:fixed;opacity:.25;filter:grayscale(1);top:0;left:0;width:100%;height:100%;object-fit:contain;pointer-events:none;transform:rotateY(180deg);-webkit-transform:rotateY(180deg);-moz-transform:rotateY(180deg)}canvas{transform:rotateY(180deg);-webkit-transform:rotateY(180deg);-moz-transform:rotateY(180deg);display:block;top:0;left:0;width:100%;height:100%;object-fit:contain;pointer-events:none}button{position:absolute;z-index:100}
    </style>
  </head>
  <body>
    <button id="webcamButton" class="mdc-button mdc-button--raised">
      <span class="mdc-button__ripple"></span>
      <span class="mdc-button__label">ENABLE WEBCAM</span>
    </button>

    <video id="webcam" style="position: abso" autoplay playsinline></video>
    <canvas id="three-canvas"></canvas>
  </body>
</html>
