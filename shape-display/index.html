<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shape Display REPL</title>
    <style>
      :root {
        --bg-dark: #282c34;
        --bg-darker: #21252b;
        --bg-lighter: #2c313a;
        --text-primary: #abb2bf;
        --text-secondary: #5c6370;
        --text-bright: #e6e6e6;
        --border: #3e4451;
        --accent: #61afef;
        --accent-hover: #528bff;
        --error: #e06c75;
      }

      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { overflow: hidden; background: #000; font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace; height: 100vh; }

      #menu-toggle { position: fixed; top: 12px; left: 12px; z-index: 200; }
      #menu-toggle.hidden { display: none; }

      #left {
        position: fixed; top: 0; left: 0; bottom: 0;
        width: 420px; max-width: 100vw;
        display: none; flex-direction: column;
        background: var(--bg-dark); z-index: 300;
      }
      #left.open { display: flex; }

      #header {
        padding: 12px 16px 8px;
        display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center;
        gap: 8px;
        flex-shrink: 0;
        border-bottom: 1px solid var(--border);
      }
      #header h1 { font-size: 11px; font-weight: 400; letter-spacing: 3px; text-transform: uppercase; color: var(--text-secondary); }
      #header-right { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
      .header-btn {
        background: var(--bg-lighter); border: 1px solid var(--border); padding: 4px 10px;
        font: 10px/1 monospace; letter-spacing: 1px; text-transform: uppercase;
        color: var(--text-primary); cursor: pointer;
        text-decoration: none;
      }
      .header-btn:hover { background: var(--bg-darker); color: var(--text-bright); border-color: var(--accent); }
      .header-btn.active { background: var(--accent); color: var(--bg-darker); border-color: var(--accent); }
      .header-btn.primary { background: var(--accent); color: var(--bg-darker); border-color: var(--accent); }
      .header-btn.primary:hover { background: var(--accent-hover); border-color: var(--accent-hover); }

      #api-ref {
        padding: 10px 16px; border-bottom: 1px solid var(--border);
        font-size: 12px; color: var(--text-secondary); line-height: 1.7;
        flex-shrink: 0; overflow-y: auto;
        display: none;
      }
      #api-ref.visible { display: block; }
      #api-ref code { color: var(--text-primary); }

      #editor-wrap { flex: 1; position: relative; overflow: hidden; min-height: 0; }
      .cm-editor { height: 100%; }
      .cm-editor .cm-scroller { overflow: auto; }
      .cm-editor.cm-focused { outline: none; }

      #console { max-height: 80px; overflow-y: auto; padding: 8px 16px; border-top: 1px solid var(--border); font-size: 10px; color: var(--error); flex-shrink: 0; }
      #console:empty { display: none; }

      #right { position: fixed; top: 0; left: 0; right: 0; bottom: 0; }

      #start-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        display: flex; align-items: center; justify-content: center;
        z-index: 50; pointer-events: none;
      }
      #start-overlay span {
        font: 11px/1 monospace; letter-spacing: 3px; text-transform: uppercase;
        color: var(--text-primary); border: 1px solid var(--border); padding: 12px 24px;
        background: var(--bg-darker); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        pointer-events: auto; cursor: pointer;
      }
      #start-overlay:hover span { background: var(--accent); color: var(--bg-darker); border-color: var(--accent); }
      #start-overlay.hidden { display: none; }
    </style>
  </head>
  <body>
    <button id="menu-toggle" class="header-btn">Show Menu</button>

    <div id="left">
      <div id="header">
        <h1>Shape Display</h1>
        <div id="header-right">
          <button class="header-btn primary" id="run-btn" title="Ctrl+Enter">Run</button>
          <button class="header-btn" id="ref-btn">Ref</button>
          <a class="header-btn" id="help-link" href="https://code.chuanqisun.com/shape-display/programming-manual" target="_blank" rel="noopener noreferrer"
            >Help</a
          >
          <button class="header-btn" id="hide-btn">Hide</button>
        </div>
      </div>
      <div id="api-ref">
        <code>wave(freqX, freqZ)</code> · <code>ripple(cx, cz, freq)</code> · <code>checker(size)</code> · <code>grid(spacing)</code> ·
        <code>pyramid()</code> · <code>flat(h)</code> · <code>noise(scale)</code><br />
        <code>pat((x,z,t,n)=>h)</code> x,z∈[0,1] t=time h∈[0,1]<br />
        <code>.blend(b, mix)</code> · <code>.add(b)</code> · <code>.mul(b)</code> · <code>.inv()</code> · <code>.ease()</code><br />
        <code>seq(dur, ...patterns)</code> sequence with crossfade<br />
        <code>.slow(factor)</code> · <code>.fast(factor)</code><br />
        <code>.rotate(angle)</code> · <code>.scale(sx, sz)</code> · <code>.offset(ox, oz)</code><br />
        <code>sin cos abs sqrt floor PI clamp lerp smoothstep</code>
      </div>
      <div id="editor-wrap"></div>
      <div id="console"></div>
    </div>

    <div id="right"></div>

    <div id="start-overlay"><span>Click to start</span></div>

    <script type="importmap">
      { "imports": { "three": "https://esm.sh/three@0.160.0", "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // CodeMirror imports
      import { EditorState } from "https://esm.sh/@codemirror/state";
      import { EditorView, keymap, highlightActiveLine } from "https://esm.sh/@codemirror/view";
      import { defaultHighlightStyle, syntaxHighlighting, indentOnInput, bracketMatching } from "https://esm.sh/@codemirror/language";
      import { javascript } from "https://esm.sh/@codemirror/lang-javascript";
      import { defaultKeymap, indentWithTab } from "https://esm.sh/@codemirror/commands";
      import { oneDark } from "https://esm.sh/@codemirror/theme-one-dark";
      import { closeBrackets } from "https://esm.sh/@codemirror/autocomplete";

      // --- URL Compression ---
      async function compressToURL(code) {
        const bytes = new TextEncoder().encode(code);
        const cs = new CompressionStream("deflate");
        const writer = cs.writable.getWriter();
        writer.write(bytes);
        writer.close();
        const reader = cs.readable.getReader();
        const chunks = [];
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(value);
        }
        const totalLen = chunks.reduce((s, c) => s + c.length, 0);
        const result = new Uint8Array(totalLen);
        let offset = 0;
        for (const c of chunks) {
          result.set(c, offset);
          offset += c.length;
        }
        let b64 = btoa(String.fromCharCode(...result));
        b64 = b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
        return b64;
      }

      async function decompressFromURL(encoded) {
        let b64 = encoded.replace(/-/g, "+").replace(/_/g, "/");
        while (b64.length % 4) b64 += "=";
        const binary = atob(b64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const ds = new DecompressionStream("deflate");
        const writer = ds.writable.getWriter();
        writer.write(bytes);
        writer.close();
        const reader = ds.readable.getReader();
        const chunks = [];
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(value);
        }
        const totalLen = chunks.reduce((s, c) => s + c.length, 0);
        const result = new Uint8Array(totalLen);
        let offset = 0;
        for (const c of chunks) {
          result.set(c, offset);
          offset += c.length;
        }
        return new TextDecoder().decode(result);
      }

      // --- Panel toggle ---
      const leftPanel = document.getElementById("left");
      const menuToggle = document.getElementById("menu-toggle");

      function openPanel() {
        leftPanel.classList.add("open");
        menuToggle.classList.add("hidden");
      }
      function closePanel() {
        leftPanel.classList.remove("open");
        menuToggle.classList.remove("hidden");
      }

      if (window.matchMedia("(min-width: 768px)").matches) openPanel();

      menuToggle.addEventListener("click", openPanel);
      document.getElementById("hide-btn").addEventListener("click", closePanel);

      // Ref toggle
      const refBtn = document.getElementById("ref-btn");
      const apiRef = document.getElementById("api-ref");
      refBtn.addEventListener("click", () => {
        apiRef.classList.toggle("visible");
        refBtn.classList.toggle("active", apiRef.classList.contains("visible"));
      });

      // --- Three.js setup ---
      const GRID = 30;
      const PIN_W = 10;
      const PIN_H = 200;
      const GAP = 2;
      const STEP = PIN_W + GAP;
      const TOTAL = GRID * GRID;
      const HALF = ((GRID - 1) * STEP) / 2;
      const MAX_P = 180;
      const VOICES = 16;

      const WALL = 10;
      const SHELL_GAP = GAP;
      const PIN_FIELD = (GRID - 1) * STEP + PIN_W;
      const INNER = PIN_FIELD + 2 * SHELL_GAP;
      const OUTER = INNER + 2 * WALL;
      const BASE_H = 200;
      const BASE_TOP = 0;

      const container = document.getElementById("right");
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(devicePixelRatio);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      const camera = new THREE.PerspectiveCamera(40, 1, 1, 5000);
      camera.position.set(600, 900, 600);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;

      renderer.domElement.addEventListener("pointerdown", () => {
        controls.autoRotate = false;
      });
      renderer.domElement.addEventListener("wheel", () => {
        controls.autoRotate = false;
      });

      scene.add(new THREE.AmbientLight(0xffffff, 1));
      const d1 = new THREE.DirectionalLight(0xffffff, 2.0);
      d1.position.set(-300, 600, -400);
      scene.add(d1);
      const d2 = new THREE.DirectionalLight(0xffffff, 1.0);
      d2.position.set(300, 400, 200);
      scene.add(d2);

      const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5, metalness: 0.0 });
      const shellMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.05, metalness: 0.0 });
      const edgeMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });

      const pinGeom = new THREE.BoxGeometry(PIN_W, PIN_H, PIN_W);
      const pins = new THREE.InstancedMesh(pinGeom, whiteMat, TOTAL);
      scene.add(pins);

      const edgeGeom = new THREE.EdgesGeometry(pinGeom);
      const edgePositions = edgeGeom.attributes.position.array;
      const edgeVertCount = edgePositions.length / 3;
      const mergedPos = new Float32Array(TOTAL * edgePositions.length);
      const pinIndex = new Float32Array(TOTAL * edgeVertCount);
      for (let i = 0; i < TOTAL; i++) {
        mergedPos.set(edgePositions, i * edgePositions.length);
        pinIndex.fill(i, i * edgeVertCount, (i + 1) * edgeVertCount);
      }
      const mergedEdgeGeom = new THREE.BufferGeometry();
      mergedEdgeGeom.setAttribute("position", new THREE.BufferAttribute(mergedPos, 3));
      mergedEdgeGeom.setAttribute("pinIdx", new THREE.BufferAttribute(pinIndex, 1));

      const texW = 1024;
      const texH = Math.ceil(TOTAL / texW);
      const heightData = new Float32Array(texW * texH * 4);
      const heightTex = new THREE.DataTexture(heightData, texW, texH, THREE.RGBAFormat, THREE.FloatType);

      const edgeShaderMat = new THREE.ShaderMaterial({
        transparent: true,
        uniforms: {
          offsets: { value: heightTex },
          opacity: { value: 0.06 },
          gridSize: { value: GRID },
          step: { value: STEP },
          half: { value: HALF },
          pinH: { value: PIN_H },
          texW: { value: texW },
        },
        vertexShader: `
          attribute float pinIdx;
          uniform sampler2D offsets;
          uniform float gridSize, step, half, pinH, texW;
          void main() {
            int idx = int(pinIdx);
            float ix = mod(pinIdx, gridSize);
            float iz = floor(pinIdx / gridSize);
            ivec2 tc = ivec2(idx % int(texW), idx / int(texW));
            float h = texelFetch(offsets, tc, 0).r;
            vec3 p = position;
            p.x += -half + ix * step;
            p.z += -half + iz * step;
            p.y += h;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
          }
        `,
        fragmentShader: `uniform float opacity; void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, opacity); }`,
      });
      const edgeLines = new THREE.LineSegments(mergedEdgeGeom, edgeShaderMat);
      scene.add(edgeLines);

      // Shell
      const shellGroup = new THREE.Group();
      const bottomGeom = new THREE.BoxGeometry(OUTER, WALL, OUTER);
      const bottom = new THREE.Mesh(bottomGeom, shellMat);
      bottom.position.y = BASE_TOP - BASE_H + WALL / 2;
      shellGroup.add(bottom);
      const bottomEdge = new THREE.LineSegments(new THREE.EdgesGeometry(bottomGeom), edgeMat);
      bottomEdge.position.copy(bottom.position);
      shellGroup.add(bottomEdge);

      function addWall(w, h, d, px, py, pz) {
        const g = new THREE.BoxGeometry(w, h, d);
        const m = new THREE.Mesh(g, shellMat);
        m.position.set(px, py, pz);
        shellGroup.add(m);
        const e = new THREE.LineSegments(new THREE.EdgesGeometry(g), edgeMat);
        e.position.set(px, py, pz);
        shellGroup.add(e);
      }

      const wallH = BASE_H - WALL;
      const wallCenterY = BASE_TOP - BASE_H + WALL + wallH / 2;
      addWall(OUTER, wallH, WALL, 0, wallCenterY, INNER / 2 + WALL / 2);
      addWall(OUTER, wallH, WALL, 0, wallCenterY, -(INNER / 2 + WALL / 2));
      addWall(WALL, wallH, INNER, -(INNER / 2 + WALL / 2), wallCenterY, 0);
      addWall(WALL, wallH, INNER, INNER / 2 + WALL / 2, wallCenterY, 0);
      scene.add(shellGroup);

      // Pin data
      const current = new Float32Array(TOTAL);
      const prevFrame = new Float32Array(TOTAL);
      const dummy = new THREE.Object3D();

      // Initialize pins at bottom (height 0)
      for (let i = 0; i < TOTAL; i++) {
        const x = -HALF + (i % GRID) * STEP;
        const zz = -HALF + ((i / GRID) | 0) * STEP;
        const centerY = BASE_TOP + 0 - PIN_H / 2;
        dummy.position.set(x, centerY, zz);
        dummy.updateMatrix();
        pins.setMatrixAt(i, dummy.matrix);
        heightData[i * 4] = centerY;
      }
      pins.instanceMatrix.needsUpdate = true;
      heightTex.needsUpdate = true;

      // Audio
      let audioCtx, masterGain;
      const voices = [];

      function initAudio() {
        audioCtx = new AudioContext();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.12;
        masterGain.connect(audioCtx.destination);
        const bufLen = audioCtx.sampleRate * 2;
        const buf = audioCtx.createBuffer(1, bufLen, audioCtx.sampleRate);
        const ch = buf.getChannelData(0);
        for (let i = 0; i < bufLen; i++) ch[i] = Math.random() * 2 - 1;
        for (let i = 0; i < VOICES; i++) {
          const osc = audioCtx.createOscillator();
          osc.type = "triangle";
          const baseFreq = 120 + Math.random() * 280;
          osc.frequency.value = baseFreq;
          const noise = audioCtx.createBufferSource();
          noise.buffer = buf;
          noise.loop = true;
          noise.playbackRate.value = 0.2 + Math.random() * 0.4;
          const filter = audioCtx.createBiquadFilter();
          filter.type = "lowpass";
          filter.frequency.value = 150;
          filter.Q.value = 0.5;
          const gain = audioCtx.createGain();
          gain.gain.value = 0;
          const lfo = audioCtx.createOscillator();
          lfo.frequency.value = 0.3 + Math.random() * 2.5;
          const lfoG = audioCtx.createGain();
          lfoG.gain.value = 0.15;
          lfo.connect(lfoG);
          lfoG.connect(osc.frequency);
          osc.connect(gain);
          noise.connect(filter);
          filter.connect(gain);
          gain.connect(masterGain);
          osc.start();
          noise.start();
          lfo.start();
          voices.push({ gain, filter, osc, baseFreq, vary: 0.5 + Math.random() * 0.8 });
        }
      }

      // Pattern API
      const _perm = new Uint8Array(512);
      {
        const p = [];
        for (let i = 0; i < 256; i++) p[i] = i;
        for (let i = 255; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [p[i], p[j]] = [p[j], p[i]];
        }
        for (let i = 0; i < 512; i++) _perm[i] = p[i & 255];
      }
      function _fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }
      function _grad(h, x, y) {
        const v = h & 3;
        return v === 0 ? x + y : v === 1 ? -x + y : v === 2 ? x - y : -x - y;
      }
      function _perlin2(x, y) {
        const X = Math.floor(x) & 255,
          Y = Math.floor(y) & 255;
        const xf = x - Math.floor(x),
          yf = y - Math.floor(y);
        const u = _fade(xf),
          v = _fade(yf);
        const aa = _perm[_perm[X] + Y],
          ab = _perm[_perm[X] + Y + 1],
          ba = _perm[_perm[X + 1] + Y],
          bb = _perm[_perm[X + 1] + Y + 1];
        const x1 = _grad(aa, xf, yf) * (1 - u) + _grad(ba, xf - 1, yf) * u;
        const x2 = _grad(ab, xf, yf - 1) * (1 - u) + _grad(bb, xf - 1, yf - 1) * u;
        return (x1 * (1 - v) + x2 * v) * 0.5 + 0.5;
      }

      // --- Pattern class (chainable AST) ---
      const { sin, cos, abs, sqrt, floor, PI } = Math;
      const clamp = (v) => Math.max(0, Math.min(1, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const smoothstep = (t) => { t = Math.max(0, Math.min(1, t)); return t * t * (3 - 2 * t); };

      function _val(v, x, z, t, n) {
        if (typeof v === "number") return v;
        if (v instanceof Pattern) return v._fn(x, z, t, n);
        if (typeof v === "function") return v(x, z, t, n);
        return 0;
      }
      function _pat(v) {
        if (v instanceof Pattern) return v;
        if (typeof v === "number") return flat(v);
        if (typeof v === "function") return new Pattern(v);
        return flat(0);
      }

      class Pattern {
        constructor(fn) { this._fn = fn; }
        query(x, z, t, n) { return Math.max(0, Math.min(1, this._fn(x, z, t, n) || 0)); }
        slow(factor) { return new Pattern((x, z, t, n) => this._fn(x, z, t / factor, n)); }
        fast(factor) { return new Pattern((x, z, t, n) => this._fn(x, z, t * factor, n)); }
        rotate(angle) {
          return new Pattern((x, z, t, n) => {
            const a = _val(angle, x, z, t, n), cx2 = x - 0.5, cz2 = z - 0.5;
            const ca = cos(a), sa = sin(a);
            return this._fn(cx2 * ca - cz2 * sa + 0.5, cx2 * sa + cz2 * ca + 0.5, t, n);
          });
        }
        scale(sx, sz) {
          const szz = sz !== undefined ? sz : sx;
          return new Pattern((x, z, t, n) => this._fn((x - 0.5) / sx + 0.5, (z - 0.5) / szz + 0.5, t, n));
        }
        offset(ox, oz) {
          return new Pattern((x, z, t, n) => {
            const fx2 = _val(ox, x, z, t, n), fz2 = _val(oz === undefined ? 0 : oz, x, z, t, n);
            return this._fn(x - fx2, z - fz2, t, n);
          });
        }
        ease() { return new Pattern((x, z, t, n) => smoothstep(this._fn(x, z, t, n))); }
        inv() { return new Pattern((x, z, t, n) => 1 - this._fn(x, z, t, n)); }
        add(other) { const o = _pat(other); return new Pattern((x, z, t, n) => clamp(this._fn(x, z, t, n) + o._fn(x, z, t, n))); }
        mul(other) { const o = _pat(other); return new Pattern((x, z, t, n) => this._fn(x, z, t, n) * o._fn(x, z, t, n)); }
        blend(other, mix = 0.5) {
          const o = _pat(other);
          return new Pattern((x, z, t, n) => {
            const m = _val(mix, x, z, t, n);
            return this._fn(x, z, t, n) * (1 - m) + o._fn(x, z, t, n) * m;
          });
        }
      }

      // --- Factory functions ---
      function wave(fx = 1, fz = 1) { return new Pattern((x, z, t) => (sin(x * fx * PI * 2) * 0.5 + 0.5) * (cos(z * fz * PI * 2) * 0.5 + 0.5)); }
      function ripple(cx = 0.5, cz = 0.5, freq = 3) { return new Pattern((x, z, t) => { const d = sqrt((x - cx) ** 2 + (z - cz) ** 2); return sin(d * freq * PI * 2) * 0.5 + 0.5; }); }
      function checker(sz = 5) { return new Pattern((x, z) => (floor(x * sz) + floor(z * sz)) % 2 === 0 ? 0.9 : 0.1); }
      function grid(sp = 5) { return new Pattern((x, z, t, n) => { const ix = Math.round(x * (n - 1)), iz = Math.round(z * (n - 1)); return ix % sp === 0 || iz % sp === 0 ? 1 : 0.05; }); }
      function pyramid() { return new Pattern((x, z) => 1 - Math.max(abs(x - 0.5), abs(z - 0.5)) * 2); }
      function flat(h = 0.5) { return new Pattern(() => h); }
      function noise(scale = 4) { return new Pattern((x, z, t) => _perlin2(x * scale + t * 0.3, z * scale + t * 0.2)); }
      function pat(fn) { return new Pattern(fn); }
      function seq(dur, ...rawPats) {
        const pats = rawPats.map((p) => _pat(p));
        const transTime = 0.8;
        const totalPerPat = dur + transTime;
        return new Pattern((x, z, t, n) => {
          const cycle = t % (pats.length * totalPerPat);
          const idx = floor(cycle / totalPerPat);
          const local = cycle - idx * totalPerPat;
          const cur = pats[idx % pats.length], nxt = pats[(idx + 1) % pats.length];
          if (local < dur) return cur._fn(x, z, t, n);
          const bl = smoothstep((local - dur) / transTime);
          return cur._fn(x, z, t, n) * (1 - bl) + nxt._fn(x, z, t, n) * bl;
        });
      }
      function blend(a, b, mix = 0.5) { return _pat(a).blend(b, mix); }
      function add(a, b) { return _pat(a).add(b); }
      function mul(a, b) { return _pat(a).mul(b); }
      function inv(a) { return _pat(a).inv(); }

      let activePattern = null;
      let globalTime = 0;
      let started = false;
      let autoRunTimer = null;

      // Auto-return: if no `return` keyword, prepend return before the last top-level expression
      function autoReturn(code) {
        if (/\breturn\b/.test(code)) return code;
        const lines = code.split("\n");
        let insertIdx = -1, parenDepth = 0, bracketDepth = 0, braceDepth = 0;
        for (let i = lines.length - 1; i >= 0; i--) {
          const trimmed = lines[i].trim();
          if (!trimmed || trimmed.startsWith("//")) continue;
          for (const ch of trimmed) {
            if (ch === "(") parenDepth--; else if (ch === ")") parenDepth++;
            else if (ch === "[") bracketDepth--; else if (ch === "]") bracketDepth++;
            else if (ch === "{") braceDepth--; else if (ch === "}") braceDepth++;
          }
          insertIdx = i;
          if (parenDepth <= 0 && bracketDepth <= 0 && braceDepth <= 0) break;
        }
        if (insertIdx >= 0) {
          const trimmed = lines[insertIdx].trim();
          if (/^(const |let |var |function )/.test(trimmed)) return code;
          const ws = lines[insertIdx].match(/^(\s*)/)[1];
          lines[insertIdx] = ws + "return " + trimmed;
        }
        return lines.join("\n");
      }

      // All names exposed to user code
      const _apiNames = [
        "Pattern", "wave", "ripple", "checker", "grid", "pyramid", "flat", "noise", "pat", "seq",
        "blend", "add", "mul", "inv",
        "sin", "cos", "abs", "sqrt", "floor", "PI", "clamp", "lerp", "smoothstep",
      ];
      const _apiValues = [
        Pattern, wave, ripple, checker, grid, pyramid, flat, noise, pat, seq,
        blend, add, mul, inv,
        sin, cos, abs, sqrt, floor, PI, clamp, lerp, smoothstep,
      ];

      function runProgram(code) {
        const consoleEl = document.getElementById("console");
        consoleEl.textContent = "";
        try {
          const wrapped = autoReturn(code);
          const fn = new Function(..._apiNames, `"use strict";\n${wrapped}`);
          const result = fn(..._apiValues);
          if (result instanceof Pattern) {
            activePattern = result;
            compressToURL(code).then((encoded) => {
              history.replaceState(null, "", "#" + encoded);
            });
          } else {
            consoleEl.textContent = "⚠ Last expression must be a Pattern";
          }
        } catch (e) {
          consoleEl.textContent = `✗ ${e.message}`;
        }
      }

      const defaultCode = `// Shape Display — x, z ∈ [0,1]  t = time  n = grid
// height ∈ [0,1] — Ctrl/Cmd + Enter to run

seq(0.5,
  flat(0),
  wave(1, 1),
  ripple(0.5, 0.5, 3),
  checker(5),
  grid(5),
  pyramid(),
  pat((x, z, t) =>
    sin((x + z) * 6) * 0.5 + 0.5
  ),
  noise(5),
  flat(0.05),
  wave(2, 0).blend(
    ripple(0.3, 0.7, 4),
    pat((x, z, t) => sin(t * 0.5) * 0.5 + 0.5)
  )
)`;

      // --- CodeMirror Editor Setup ---
      let editorView;

      // Custom keybinding for Ctrl/Cmd+Enter to run
      const runKeymap = keymap.of([
        {
          key: "Ctrl-Enter",
          mac: "Cmd-Enter",
          run: () => {
            runProgram(editorView.state.doc.toString());
            return true;
          },
        },
      ]);

      // Debounced auto-run: evaluate pattern on code change (keeps clock running)
      const autoRunListener = EditorView.updateListener.of((update) => {
        if (update.docChanged && started) {
          clearTimeout(autoRunTimer);
          autoRunTimer = setTimeout(() => runProgram(editorView.state.doc.toString()), 500);
        }
      });

      const commonExtensions = [
        highlightActiveLine(),
        syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
        keymap.of([...defaultKeymap, indentWithTab]),
        oneDark,
        indentOnInput(),
        bracketMatching(),
        closeBrackets(),
      ];

      async function initEditor() {
        const hash = location.hash.slice(1);
        let initialCode;
        if (hash) {
          try {
            initialCode = await decompressFromURL(hash);
          } catch (e) {
            initialCode = defaultCode;
          }
        } else {
          initialCode = defaultCode;
        }

        editorView = new EditorView({
          state: EditorState.create({
            doc: initialCode,
            extensions: [...commonExtensions, javascript(), runKeymap, autoRunListener],
          }),
          parent: document.getElementById("editor-wrap"),
        });
      }
      await initEditor();

      function getEditorCode() {
        return editorView.state.doc.toString();
      }

      document.getElementById("run-btn").addEventListener("click", () => runProgram(getEditorCode()));

      function resize() {
        const w = container.clientWidth,
          h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      }
      resize();
      addEventListener("resize", resize);

      document.getElementById("start-overlay").addEventListener("click", () => {
        if (!audioCtx) initAudio();
        document.getElementById("start-overlay").classList.add("hidden");
        started = true;
        runProgram(getEditorCode());
      });

      const clock = new THREE.Clock();

      function loop() {
        requestAnimationFrame(loop);
        const dt = Math.min(clock.getDelta(), 0.1);
        controls.update();

        if (started) {
          globalTime += dt;
        }

        prevFrame.set(current);

        if (activePattern && started) {
          for (let i = 0; i < TOTAL; i++) {
            const ix = i % GRID;
            const iz = (i / GRID) | 0;
            const x = ix / (GRID - 1);
            const z = iz / (GRID - 1);
            let h = activePattern.query(x, z, globalTime, GRID);
            current[i] = h * MAX_P;
          }
        }

        let intensity = 0;
        for (let i = 0; i < TOTAL; i++) {
          const x = -HALF + (i % GRID) * STEP;
          const zz = -HALF + ((i / GRID) | 0) * STEP;
          const centerY = BASE_TOP + current[i] - PIN_H / 2;
          dummy.position.set(x, centerY, zz);
          dummy.updateMatrix();
          pins.setMatrixAt(i, dummy.matrix);
          heightData[i * 4] = centerY;
          intensity += Math.abs(current[i] - prevFrame[i]);
        }
        intensity /= TOTAL;
        pins.instanceMatrix.needsUpdate = true;
        heightTex.needsUpdate = true;

        if (audioCtx) {
          const now = audioCtx.currentTime;
          for (const v of voices) {
            const g = Math.min(intensity * 0.6 * v.vary, 0.35);
            v.gain.gain.setTargetAtTime(g, now, 0.04);
            v.osc.frequency.setTargetAtTime(v.baseFreq + intensity * 180, now, 0.1);
            v.filter.frequency.setTargetAtTime(150 + intensity * 1500, now, 0.1);
          }
        }

        renderer.render(scene, camera);
      }
      loop();
    </script>
  </body>
</html>
