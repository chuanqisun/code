<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Color Anaylzer</title>
    <style>
      body {
          font-family: sans-serif;
          margin: 0;
          padding: 10px;
          display: flex;
          flex-direction: column;
          height: 100vh;
          overflow: hidden;
      }
      .controls {
          margin-bottom: 10px;
          padding: 10px;
          border: 1px solid #ccc;
          flex-shrink: 0;
      }
      .controls > div {
          margin: 5px 0;
      }
      label {
          display: inline-block;
          width: 120px;
      }
      input[type="text"], input[type="number"] {
          width: 100px;
      }
      .main-content {
          display: flex;
          flex: 1;
          min-height: 0;
          gap: 10px;
      }
      .canvas-wrapper {
          flex: 1;
          display: flex;
          align-items: center;
          justify-content: center;
          border: 1px solid #000;
          overflow: hidden;
          position: relative;
      }
      .canvas-container {
          position: relative;
          max-width: 100%;
          max-height: 100%;
      }
      canvas {
          position: absolute;
          top: 0;
          left: 0;
          max-width: 100%;
          max-height: 100%;
          object-fit: contain;
      }
      #sourceCanvas {
          z-index: 1;
      }
      #resultCanvas {
          z-index: 2;
      }
      .palette {
          width: 300px;
          padding: 10px;
          border: 1px solid #ccc;
          overflow-y: auto;
          flex-shrink: 0;
      }
      .palette-colors {
          display: flex;
          flex-direction: column;
          gap: 5px;
          margin-top: 10px;
      }
      .palette-item {
          cursor: pointer;
          padding: 5px;
          border: 2px solid transparent;
          display: flex;
          align-items: center;
          gap: 10px;
      }
      .palette-item:hover {
          border-color: #000;
      }
      .palette-item.active {
          border-color: #f00;
      }
      .color-box {
          width: 40px;
          height: 40px;
          border: 1px solid #000;
          flex-shrink: 0;
      }
      .color-info {
          flex: 1;
          font-size: 12px;
      }
      .dominance-bar {
          width: 100%;
          height: 8px;
          background: #eee;
          margin-top: 3px;
      }
      .dominance-fill {
          height: 100%;
          background: #4CAF50;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <div>
        <button id="pasteBtn">Paste Image (Ctrl+V)</button>
        <button id="downloadBtn" disabled>Download Result</button>
      </div>
      <div>
        <label>Override Color:</label>
        <input type="text" id="overrideColor" placeholder="#RRGGBB" />
        <span>Current: <span id="currentColor">#DE8878</span></span>
      </div>
      <div>
        <label>Tolerance:</label>
        <input type="number" id="tolerance" value="50" min="0" max="255" />
      </div>
      <div>
        <em>Hover over image to sample color. Hold SHIFT to see original.</em>
      </div>
    </div>

    <div class="main-content">
      <div class="canvas-wrapper">
        <div class="canvas-container" id="canvasContainer">
          <canvas id="sourceCanvas"></canvas>
          <canvas id="resultCanvas"></canvas>
        </div>
      </div>

      <div class="palette">
        <div>
          <label>Palette Colors:</label>
          <input type="number" id="paletteCount" value="8" min="2" max="32" />
        </div>
        <div style="margin-top: 5px;">
          <button id="extractBtn" disabled>Extract Palette</button>
        </div>
        <div style="margin-top: 5px;">
          <button id="applyPaletteBtn" disabled>Apply Palette to Image</button>
        </div>
        <div class="palette-colors" id="paletteColors"></div>
      </div>
    </div>

    <script>
      const sourceCanvas = document.getElementById("sourceCanvas");
      const resultCanvas = document.getElementById("resultCanvas");
      const sCtx = sourceCanvas.getContext("2d", { willReadFrequently: true });
      const rCtx = resultCanvas.getContext("2d");

      const toleranceInput = document.getElementById("tolerance");
      const overrideColorInput = document.getElementById("overrideColor");
      const currentColorSpan = document.getElementById("currentColor");
      const downloadBtn = document.getElementById("downloadBtn");
      const pasteBtn = document.getElementById("pasteBtn");
      const extractBtn = document.getElementById("extractBtn");
      const applyPaletteBtn = document.getElementById("applyPaletteBtn");
      const paletteCountInput = document.getElementById("paletteCount");
      const paletteColorsDiv = document.getElementById("paletteColors");
      const canvasContainer = document.getElementById("canvasContainer");

      let targetRGB = { r: 222, g: 136, b: 120 };
      let originalImageData = null;
      let shiftPressed = false;
      let extractedPalette = [];
      let currentImage = null;

      function handleImage(file) {
        if (!file.type.startsWith("image/")) return;

        const img = new Image();
        img.onload = () => {
          currentImage = img;
          resizeCanvas();
          downloadBtn.disabled = false;
          extractBtn.disabled = false;
        };
        img.src = URL.createObjectURL(file);
      }

      function resizeCanvas() {
        if (!currentImage) return;

        const containerWidth = canvasContainer.parentElement.clientWidth;
        const containerHeight = canvasContainer.parentElement.clientHeight;

        const imgAspect = currentImage.width / currentImage.height;
        const containerAspect = containerWidth / containerHeight;

        let displayWidth, displayHeight;

        if (imgAspect > containerAspect) {
          displayWidth = containerWidth;
          displayHeight = containerWidth / imgAspect;
        } else {
          displayHeight = containerHeight;
          displayWidth = containerHeight * imgAspect;
        }

        sourceCanvas.width = resultCanvas.width = currentImage.width;
        sourceCanvas.height = resultCanvas.height = currentImage.height;

        sourceCanvas.style.width = resultCanvas.style.width = displayWidth + "px";
        sourceCanvas.style.height = resultCanvas.style.height = displayHeight + "px";

        canvasContainer.style.width = displayWidth + "px";
        canvasContainer.style.height = displayHeight + "px";

        sCtx.drawImage(currentImage, 0, 0);
        originalImageData = sCtx.getImageData(0, 0, currentImage.width, currentImage.height);
        processImage();
      }

      window.addEventListener("resize", () => {
        if (currentImage) resizeCanvas();
      });

      window.addEventListener("paste", (e) => {
        const items = e.clipboardData.items;
        for (let item of items) {
          if (item.type.indexOf("image") !== -1) {
            handleImage(item.getAsFile());
          }
        }
      });

      pasteBtn.addEventListener("click", async () => {
        try {
          const clipboardItems = await navigator.clipboard.read();
          for (const item of clipboardItems) {
            for (const type of item.types) {
              if (type.startsWith("image/")) {
                const blob = await item.getType(type);
                handleImage(blob);
                return;
              }
            }
          }
        } catch (err) {
          alert("Please use Ctrl+V to paste.");
        }
      });

      // Shift key handling
      window.addEventListener("keydown", (e) => {
        if (e.key === "Shift" && !shiftPressed) {
          shiftPressed = true;
          resultCanvas.style.opacity = "0";
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.key === "Shift") {
          shiftPressed = false;
          resultCanvas.style.opacity = "1";
        }
      });

      // Hover to sample color
      resultCanvas.addEventListener("mousemove", (e) => {
        if (!originalImageData) return;

        const rect = resultCanvas.getBoundingClientRect();
        const scaleX = resultCanvas.width / rect.width;
        const scaleY = resultCanvas.height / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);

        if (x >= 0 && x < resultCanvas.width && y >= 0 && y < resultCanvas.height) {
          const pixel = sCtx.getImageData(x, y, 1, 1).data;

          if (pixel[3] > 10 && !overrideColorInput.value) {
            targetRGB = { r: pixel[0], g: pixel[1], b: pixel[2] };
            updateCurrentColor();
            processImage();
          }
        }
      });

      overrideColorInput.addEventListener("input", () => {
        const hex = overrideColorInput.value.trim();
        if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          targetRGB = { r, g, b };
          updateCurrentColor();
          processImage();
        }
      });

      toleranceInput.addEventListener("input", () => {
        processImage();
      });

      function updateCurrentColor() {
        const hex = "#" + ((1 << 24) + (targetRGB.r << 16) + (targetRGB.g << 8) + targetRGB.b).toString(16).slice(1).toUpperCase();
        currentColorSpan.innerText = hex;
      }

      function processImage() {
        if (!originalImageData) return;

        const tolerance = parseInt(toleranceInput.value);
        const outputData = new ImageData(new Uint8ClampedArray(originalImageData.data), originalImageData.width, originalImageData.height);
        const data = outputData.data;

        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const a = data[i + 3];

          const distance = Math.sqrt(Math.pow(r - targetRGB.r, 2) + Math.pow(g - targetRGB.g, 2) + Math.pow(b - targetRGB.b, 2));

          if (distance > tolerance || a < 10) {
            data[i] = 255;
            data[i + 1] = 255;
            data[i + 2] = 255;
            data[i + 3] = 255;
          }
        }
        rCtx.putImageData(outputData, 0, 0);
      }

      downloadBtn.addEventListener("click", () => {
        const link = document.createElement("a");
        link.download = "isolated-color.png";
        link.href = resultCanvas.toDataURL();
        link.click();
      });

      // Palette extraction using median cut algorithm
      extractBtn.addEventListener("click", () => {
        if (!originalImageData) return;

        const numColors = parseInt(paletteCountInput.value);
        extractedPalette = extractPalette(originalImageData, numColors);
        displayPalette();
        applyPaletteBtn.disabled = false;
      });

      function extractPalette(imageData, numColors) {
        const pixels = [];
        const data = imageData.data;

        // Collect all pixels
        for (let i = 0; i < data.length; i += 4) {
          if (data[i + 3] > 10) {
            pixels.push([data[i], data[i + 1], data[i + 2]]);
          }
        }

        const totalPixels = pixels.length;
        const depth = Math.ceil(Math.log2(numColors));
        const colors = medianCut(pixels, depth);

        // Calculate dominance percentage
        return colors.map((color) => ({
          ...color,
          dominance: ((color.count / totalPixels) * 100).toFixed(1),
        }));
      }

      function medianCut(pixels, depth) {
        if (depth === 0 || pixels.length === 0) {
          return [averageColor(pixels)];
        }

        // Find channel with greatest range
        let rMin = 255,
          rMax = 0,
          gMin = 255,
          gMax = 0,
          bMin = 255,
          bMax = 0;
        for (let p of pixels) {
          rMin = Math.min(rMin, p[0]);
          rMax = Math.max(rMax, p[0]);
          gMin = Math.min(gMin, p[1]);
          gMax = Math.max(gMax, p[1]);
          bMin = Math.min(bMin, p[2]);
          bMax = Math.max(bMax, p[2]);
        }

        const rRange = rMax - rMin;
        const gRange = gMax - gMin;
        const bRange = bMax - bMin;

        const channel = rRange >= gRange && rRange >= bRange ? 0 : gRange >= bRange ? 1 : 2;

        pixels.sort((a, b) => a[channel] - b[channel]);
        const mid = Math.floor(pixels.length / 2);

        return [...medianCut(pixels.slice(0, mid), depth - 1), ...medianCut(pixels.slice(mid), depth - 1)];
      }

      function averageColor(pixels) {
        if (pixels.length === 0) return { r: 0, g: 0, b: 0, count: 0 };
        let r = 0,
          g = 0,
          b = 0;
        for (let p of pixels) {
          r += p[0];
          g += p[1];
          b += p[2];
        }
        const len = pixels.length;
        return {
          r: Math.round(r / len),
          g: Math.round(g / len),
          b: Math.round(b / len),
          count: len,
        };
      }

      function displayPalette() {
        paletteColorsDiv.innerHTML = "";

        // Sort by dominance
        const sorted = [...extractedPalette].sort((a, b) => b.dominance - a.dominance);
        const maxDominance = Math.max(...sorted.map((c) => parseFloat(c.dominance)));

        sorted.forEach((color, idx) => {
          const hex = "#" + ((1 << 24) + (color.r << 16) + (color.g << 8) + color.b).toString(16).slice(1).toUpperCase();
          const item = document.createElement("div");
          item.className = "palette-item";

          const barWidth = (parseFloat(color.dominance) / maxDominance) * 100;

          item.innerHTML = `
                <div class="color-box" style="background-color: ${hex}"></div>
                <div class="color-info">
                    <div><strong>${hex}</strong></div>
                    <div>Dominance: ${color.dominance}%</div>
                    <div class="dominance-bar">
                        <div class="dominance-fill" style="width: ${barWidth}%"></div>
                    </div>
                </div>
            `;
          item.addEventListener("click", () => {
            document.querySelectorAll(".palette-item").forEach((el) => el.classList.remove("active"));
            item.classList.add("active");
            targetRGB = { r: color.r, g: color.g, b: color.b };
            overrideColorInput.value = hex;
            updateCurrentColor();
            processImage();
          });
          paletteColorsDiv.appendChild(item);
        });
      }

      applyPaletteBtn.addEventListener("click", () => {
        if (!originalImageData || extractedPalette.length === 0) return;

        const data = originalImageData.data;
        const newData = new Uint8ClampedArray(data);

        for (let i = 0; i < data.length; i += 4) {
          if (data[i + 3] > 10) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            // Find closest palette color
            let minDist = Infinity;
            let closest = extractedPalette[0];

            for (let color of extractedPalette) {
              const dist = Math.sqrt(Math.pow(r - color.r, 2) + Math.pow(g - color.g, 2) + Math.pow(b - color.b, 2));
              if (dist < minDist) {
                minDist = dist;
                closest = color;
              }
            }

            newData[i] = closest.r;
            newData[i + 1] = closest.g;
            newData[i + 2] = closest.b;
          }
        }

        originalImageData = new ImageData(newData, originalImageData.width, originalImageData.height);
        sCtx.putImageData(originalImageData, 0, 0);
        processImage();
      });
    </script>
  </body>
</html>
