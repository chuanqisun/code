<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Time Machine</title>
    <style>
      *,
      *::before,
      *::after {
          box-sizing: border-box;
      }

      body {
          margin: 0;
          overflow: hidden;
      }

      canvas {
          display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="Canvas"></canvas>
    <script type="module">
      import { Observable, share, Subscription, animationFrames } from "https://esm.sh/rxjs";

      // --- lib/utils/noise.ts ---
      const P = new Uint8Array(512);
      const DEFAULT_PERMUTATION = [
        151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
        234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134,
        139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1,
        216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124,
        123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154,
        163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
        242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
        50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
      ];

      function initPermutation() {
        for (let i = 0; i < 256; i++) {
          P[256 + i] = P[i] = DEFAULT_PERMUTATION[i];
        }
      }
      initPermutation();

      function fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }

      function lerp(t, a, b) {
        return a + t * (b - a);
      }

      function grad(hash, x, y, z) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
      }

      function perlinNoise(x, y = 0, z = 0) {
        const floorX = Math.floor(x);
        const floorY = Math.floor(y);
        const floorZ = Math.floor(z);

        const xi = floorX & 255;
        const yi = floorY & 255;
        const zi = floorZ & 255;

        const xf = x - floorX;
        const yf = y - floorY;
        const zf = z - floorZ;

        const u = fade(xf);
        const v = fade(yf);
        const w = fade(zf);

        const A = P[xi] + yi,
          AA = P[A] + zi,
          AB = P[A + 1] + zi;
        const B = P[xi + 1] + yi,
          BA = P[B] + zi,
          BB = P[B + 1] + zi;

        return lerp(
          w,
          lerp(v, lerp(u, grad(P[AA], xf, yf, zf), grad(P[BA], xf - 1, yf, zf)), lerp(u, grad(P[AB], xf, yf - 1, zf), grad(P[BB], xf - 1, yf - 1, zf))),
          lerp(
            v,
            lerp(u, grad(P[AA + 1], xf, yf, zf - 1), grad(P[BA + 1], xf - 1, yf, zf - 1)),
            lerp(u, grad(P[AB + 1], xf, yf - 1, zf - 1), grad(P[BB + 1], xf - 1, yf - 1, zf - 1))
          )
        );
      }

      const noise = perlinNoise;

      // --- lib/render/surface.ts ---
      class DrawSurface {
        constructor(canvas) {
          this.canvas = canvas;
          const context = canvas.getContext("2d");
          if (!context) {
            throw new Error("Could not get 2D context from canvas");
          }
          this.ctx = context;
          this.setupResize();
        }

        setupResize() {
          const resize = () => {
            const scale = window.devicePixelRatio || 1;
            this.canvas.style.width = window.innerWidth + "px";
            this.canvas.style.height = window.innerHeight + "px";
            this.canvas.width = Math.floor(window.innerWidth * scale);
            this.canvas.height = Math.floor(window.innerHeight * scale);
            this.ctx.scale(scale, scale);
          };

          window.addEventListener("resize", resize);
          resize();
        }

        get width() {
          return window.innerWidth;
        }
        get height() {
          return window.innerHeight;
        }
        get cx() {
          return this.width / 2;
        }
        get cy() {
          return this.height / 2;
        }

        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
      }

      // --- lib/primitives/polygon.ts ---
      class Path {
        constructor() {
          this.vertices = [];
          this.closed = false;
        }

        static of() {
          return new Path();
        }

        v(x, y) {
          this.vertices.push([x, y]);
          return this;
        }

        draw(ctx) {
          if (this.vertices.length < 2) {
            return this;
          }

          ctx.beginPath();
          ctx.moveTo(this.vertices[0][0], this.vertices[0][1]);
          for (let i = 1; i < this.vertices.length; i++) {
            ctx.lineTo(this.vertices[i][0], this.vertices[i][1]);
          }

          if (this.closed) {
            ctx.closePath();
          }
          ctx.stroke();

          return this;
        }

        close() {
          this.closed = true;
          return this;
        }
      }

      const path = () => Path.of();

      // --- lib/input/mouse.ts ---
      class Mouse extends Observable {
        constructor(canvas) {
          let _shared$;
          super((subscriber) => {
            return _shared$.subscribe(subscriber);
          });

          this._x = canvas.width / 2;
          this._y = canvas.height / 2;

          const internal$ = new Observable((subscriber) => {
            const mouseMoveHandler = (event) => {
              const rect = canvas.getBoundingClientRect();
              this._x = event.clientX - rect.left;
              this._y = event.clientY - rect.top;
              subscriber.next({ x: this._x, y: this._y });
            };

            canvas.addEventListener("mousemove", mouseMoveHandler);
            subscriber.next({ x: this._x, y: this._y });

            return () => {
              canvas.removeEventListener("mousemove", mouseMoveHandler);
            };
          });

          _shared$ = internal$.pipe(share());
          this._shared$ = _shared$;
          this._subscription = null;
        }

        get x() {
          this._ensureSubscription();
          return this._x;
        }

        get y() {
          this._ensureSubscription();
          return this._y;
        }

        _ensureSubscription() {
          if (!this._subscription) {
            this._subscription = this._shared$.subscribe();
          }
        }
      }

      // --- lib/input/mic.ts ---
      class Mic extends Observable {
        constructor() {
          let _shared$;
          super((subscriber) => {
            return _shared$.subscribe(subscriber);
          });

          this._intensity = 0;

          const internal$ = new Observable((subscriber) => {
            let audioContext;
            let analyser;
            let dataArray;
            let source;
            let stream;
            let animationId;

            const start = async () => {
              try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);

                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                const update = () => {
                  analyser.getByteFrequencyData(dataArray);
                  let sum = 0;
                  for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                  }
                  const average = sum / bufferLength;
                  this._intensity = average;
                  subscriber.next(average);
                  animationId = requestAnimationFrame(update);
                };

                update();
              } catch (err) {
                subscriber.error(err);
              }
            };

            start();

            return () => {
              if (animationId) cancelAnimationFrame(animationId);
              if (source) source.disconnect();
              if (audioContext) audioContext.close();
              if (stream) {
                stream.getTracks().forEach((track) => track.stop());
              }
            };
          });

          _shared$ = internal$.pipe(share());
          this._shared$ = _shared$;
          this._subscription = null;
        }

        get intensity() {
          this._ensureSubscription();
          return this._intensity;
        }

        _ensureSubscription() {
          if (!this._subscription) {
            this._subscription = this._shared$.subscribe();
          }
        }
      }

      // --- src/main.ts ---
      const surface = new DrawSurface(document.querySelector("canvas"));
      const mouse = new Mouse(surface.canvas);
      const mic = new Mic();

      animationFrames().subscribe(() => {
        surface.clear();
        draw(surface);
      });

      function draw(surface) {
        const { cx, cy, ctx } = surface;
        const boxAmp = mic.intensity * 1;
        const faceAmp = mic.intensity * 0.5;
        const freq = 10;

        path()
          .v(cx - 50 + noise(mouse.x * freq, boxAmp * freq, 100) * boxAmp, cy - 50 + noise(mouse.x * freq, mouse.y * boxAmp, 101) * boxAmp)
          .v(cx + 50 + noise(mouse.x * freq, boxAmp * freq, 200) * boxAmp, cy - 50 + noise(mouse.x * freq, mouse.y * boxAmp, 201) * boxAmp)
          .v(cx + 50 + noise(mouse.x * freq, boxAmp * freq, 300) * boxAmp, cy + 50 + noise(mouse.x * freq, mouse.y * boxAmp, 301) * boxAmp)
          .v(cx - 50 + noise(mouse.x * freq, boxAmp * freq, 400) * boxAmp, cy + 50 + noise(mouse.x * freq, mouse.y * boxAmp, 401) * boxAmp)
          .close()
          .draw(ctx);

        // Left Eye
        path()
          .v(cx - 20 + noise(mouse.x, faceAmp, 500) * faceAmp, cy - 20 + noise(mouse.y, faceAmp, 501) * faceAmp)
          .v(cx - 10 + noise(mouse.x, faceAmp, 502) * faceAmp, cy - 20 + noise(mouse.y, faceAmp, 503) * faceAmp)
          .draw(ctx);

        // Right Eye
        path()
          .v(cx + 10 + noise(mouse.x, faceAmp, 600) * faceAmp, cy - 20 + noise(mouse.y, faceAmp, 601) * faceAmp)
          .v(cx + 20 + noise(mouse.x, faceAmp, 602) * faceAmp, cy - 20 + noise(mouse.y, faceAmp, 603) * faceAmp)
          .draw(ctx);

        // Mouth
        path()
          .v(cx - 15 + noise(mouse.x, faceAmp, 700) * faceAmp, cy + 15 + noise(mouse.y, faceAmp, 701) * faceAmp)
          .v(cx + 15 + noise(mouse.x, faceAmp, 702) * faceAmp, cy + 15 + noise(mouse.y, faceAmp, 703) * faceAmp)
          .draw(ctx);
      }
    </script>
  </body>
</html>
