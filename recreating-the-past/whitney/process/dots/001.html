<!DOCTYPE html>
<html>
  <head>
    <title>Circle Dots</title>
  </head>
  <body style="margin: 0; overflow: hidden">
    <button id="playPause" type="button">Play</button>
    <button id="render" type="button">Render</button>
    <label>Duration <input id="duration" type="number" min="0.1" step="0.1" value="10" style="width: 60px" />s</label>
    <br />
    <input id="scrub" type="range" min="0" max="10000" value="0" step="1" style="width: 800px" />
    <br />
    <canvas id="c" width="800" height="800" style="border: 1px solid black; background: white"></canvas>
    <script>
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");
      const $ = (id) => document.getElementById(id);

      const W = 800,
        H = 800;
      const cx = 400,
        cy = 400;

      // ── parameters ──
      const N = 64;
      const R = 200;
      const amp = 8;
      const freq = 60;
      const phaseSpread = 10;
      const dotR = 2;

      // ── timeline ──
      function createTimeline(el) {
        const lo = +el.min,
          range = +el.max - lo;
        return {
          get u() {
            return (+el.value - lo) / range;
          },
          set u(v) {
            el.value = lo + Math.max(0, Math.min(1, v)) * range;
          },
        };
      }

      // ── player ──
      function createPlayer(el, tl, getDur) {
        let on = false,
          t0 = 0,
          u0 = 0,
          dur = 0;
        const rebase = () => {
          t0 = performance.now();
          u0 = tl.u;
          dur = getDur();
        };
        const set = (v) => {
          on = v;
          el.textContent = on ? "Pause" : "Play";
          if (on) rebase();
        };
        el.onclick = () => set(!on);
        return {
          rebase: () => on && rebase(),
          pause: () => on && set(false),
          tick(now) {
            if (!on) return;
            const next = u0 + (now - t0) / dur;
            next >= 1 ? ((tl.u = 1), set(false)) : (tl.u = next);
          },
        };
      }

      // ── recorder ──
      function createRecorder(el, canvas, tl, draw, getDur) {
        let active = false;
        const locked = [];
        el.onclick = async () => {
          if (active) {
            active = false;
            return;
          }
          active = true;
          el.textContent = "Cancel";
          locked.forEach((e) => (e.disabled = true));

          const totalFrames = (60 * getDur()) / 1000;
          const frameCount = Math.ceil(totalFrames);
          const stream = canvas.captureStream(0);
          const track = stream.getVideoTracks()[0];
          const mime = MediaRecorder.isTypeSupported("video/webm;codecs=vp9") ? "video/webm;codecs=vp9" : "video/webm";
          const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 8e6 });
          const chunks = [];
          rec.ondataavailable = (e) => e.data.size && chunks.push(e.data);
          rec.start();

          for (let f = 0; f <= frameCount && active; f++) {
            tl.u = Math.min(f / totalFrames, 1);
            draw();
            track.requestFrame();
            await new Promise((r) => requestAnimationFrame(r));
          }

          rec.stop();
          await new Promise((r) => (rec.onstop = r));

          if (active) {
            const a = Object.assign(document.createElement("a"), {
              href: URL.createObjectURL(new Blob(chunks, { type: mime })),
              download: "render.webm",
            });
            a.click();
            setTimeout(() => URL.revokeObjectURL(a.href), 1000);
          }

          stream.getTracks().forEach((t) => t.stop());
          active = false;
          el.textContent = "Render";
          locked.forEach((e) => (e.disabled = false));
        };
        return {
          get active() {
            return active;
          },
          lock(...els) {
            locked.push(...els);
          },
        };
      }

      // ── draw ──
      function draw() {
        const { u } = tl;

        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = "black";
        for (let i = 0; i < N; i++) {
          const angle = (i / N) * 2 * Math.PI;
          const phase = phaseSpread * 2 * Math.PI * (i / N);
          const r = R + amp * Math.sin(2 * Math.PI * freq * u + phase);
          const x = cx + r * Math.cos(angle);
          const y = cy + r * Math.sin(angle);

          ctx.beginPath();
          ctx.arc(x, y, dotR, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      // ── wiring ──
      const durInput = $("duration");
      const getDur = () => Math.max(100, +durInput.value * 1000);
      const tl = createTimeline($("scrub"));
      const player = createPlayer($("playPause"), tl, getDur);
      const recorder = createRecorder($("render"), canvas, tl, draw, getDur);

      recorder.lock($("playPause"), durInput);
      $("scrub").oninput = () => player.rebase();
      durInput.oninput = () => player.rebase();

      (function loop() {
        if (!recorder.active) {
          player.tick(performance.now());
          draw();
        }
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
