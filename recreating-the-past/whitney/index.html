<!DOCTYPE html>
<html>
  <head>
    <title>Permutations</title>
  </head>
  <body style="margin: 0; overflow: hidden">
    <button id="playPause" type="button">Play</button>
    <button id="render" type="button">Render</button>
    <button id="shareScreen" type="button">Share Screen</button>
    <button id="shareMic" type="button">Share Mic</button>
    <label>Duration <input id="duration" type="number" min="0.1" step="0.1" value="30" style="width: 60px" />s</label>
    <label>Volume <input id="volumeK" type="range" min="1" max="10" step="1" value="3" style="width: 100px" /><span id="volumeKVal">3</span></label>
    <br />
    <input id="scrub" type="range" min="0" max="10000" value="0" step="1" style="width: 800px" />
    <br />
    <canvas id="c" width="800" height="800" style="border: 1px solid black; background: black"></canvas>
    <script type="module">
      import { wire } from "../shared/timeline.js";

      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");
      const $ = (id) => document.getElementById(id);

      let k = 3;
      $("volumeK").addEventListener("input", (e) => {
        k = Number(e.target.value);
        $("volumeKVal").textContent = k;
      });

      const { tl } = wire({
        canvas,
        draw,
        deriveT: (u) => u * (redArc.maxAngle / (redArc.N - 1)),
        getAudioTracks: () => screenDestination?.stream.getAudioTracks() ?? [],
      });

      const W = 800,
        H = 800;
      const cx = 400,
        cy = 400;

      // ── dots config ──

      const rings = [
        {
          dotCount: 210,
          innerRadius: 290,
          ringWidth: 10,
          baseRotationSpeed: -Math.PI * 0.0171,
          rotationSpeed: -0.00189,
          radialSpeed: 0.000001,
          baseTime: 19500,
          timeRange: 200,
        },
        {
          dotCount: 31,
          innerRadius: 290,
          ringWidth: 10,
          baseRotationSpeed: -Math.PI * 0.0341,
          rotationSpeed: -0.00291,
          radialSpeed: 0.0000251,
          baseTime: 751,
          timeRange: 800,
        },
      ];

      // ── lines config ──

      const redArc = {
        N: 31,
        R: 100,
        showDots: false,
        outerRadiusMaxScale: 3,
        outerRadiusDuty: 0.1,
        spanDeg: 90,
        centerX: cx,
        centerY: cy,
        maxAngle: 29 * Math.PI,
        orbitRevolutions: 13,
        radiusOscillations: 3,
        radiusMaxScale: 2,
      };

      const blueArc = {
        N: 31,
        R: 100,
        showDots: false,
        outerRadiusMaxScale: 3,
        outerRadiusDuty: 0.1,
        spanDeg: 180,
        orbitRevolutions: 8,
        selfRevolutions: 6,
        radiusOscillations: 4,
        radiusMaxScale: 2,
      };

      const renderStyle = {
        canvasBackground: "#050000",
        lineColor: "#56fa58",
      };

      const lineColorConfig = {
        dimScale: 0.01,
        brightScale: 1.8,
        redArcPeriodMs: 3700,
        blueArcPeriodMs: 5300,
        minBlur: 1,
        maxBlur: 10,
      };

      const dotColorConfig = {
        colorDim: "#990000",
        colorBright: "#ffadad",
        periodMs: 12000, // full cycle: each color shown for half
        fadeMs: 500, // interpolation duration at each transition
      };

      // ── dot color helpers ──

      function hexToRgb(hex) {
        return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
      }

      function scaleColor(hex, scale) {
        const [r, g, b] = hexToRgb(hex);
        return `rgb(${Math.min(255, Math.round(r * scale))},${Math.min(255, Math.round(g * scale))},${Math.min(255, Math.round(b * scale))})`;
      }

      function getArcBrightness(periodMs) {
        const phase = (performance.now() % periodMs) / periodMs;
        return 0.5 - 0.5 * Math.cos(2 * Math.PI * phase);
      }

      function lerpColor(a, b, t) {
        const [ar, ag, ab] = hexToRgb(a);
        const [br, bg, bb] = hexToRgb(b);
        return `rgb(${Math.round(ar + (br - ar) * t)},${Math.round(ag + (bg - ag) * t)},${Math.round(ab + (bb - ab) * t)})`;
      }

      function getDotColor() {
        const { colorDim, colorBright, periodMs, fadeMs } = dotColorConfig;
        const phase = performance.now() % periodMs;
        const half = periodMs / 2;
        let f;
        if (phase < fadeMs) f = 1 - phase / fadeMs; // bright → dim
        else if (phase < half) f = 0; // solid dim
        else if (phase < half + fadeMs) f = (phase - half) / fadeMs; // dim → bright
        else f = 1; // solid bright
        return lerpColor(colorDim, colorBright, f);
      }

      // ── helpers ──

      function compressedDuty(t, K, duty) {
        if (t < duty) return 1 + ((K - 1) * (1 - Math.cos((Math.PI * t) / duty))) / 2;
        if (t < 1 - duty) return K;
        return 1 + ((K - 1) * (1 + Math.cos((Math.PI * (t - 1 + duty)) / duty))) / 2;
      }

      const oscScale = (osc, maxS, u) => {
        const s = 0.5 - 0.5 * Math.cos(2 * Math.PI * osc * u);
        return 1 + (maxS - 1) * s;
      };

      const redRadiusScale = (u) => oscScale(redArc.radiusOscillations, redArc.radiusMaxScale, u);
      const blueRadiusScale = (u) => oscScale(blueArc.radiusOscillations, blueArc.radiusMaxScale, u);
      const outerR = (max, duty, u) => compressedDuty(u, max, duty);

      // ── dots draw ──

      function drawRing(ring, u) {
        const time = ring.baseTime + u * ring.timeRange;
        const dotColor = getDotColor();
        ctx.fillStyle = dotColor;
        ctx.shadowColor = dotColor;
        ctx.shadowBlur = 6;
        const volume = currentVolume * 10 * k;
        for (let i = 1; i <= ring.dotCount; i++) {
          const volumeRingWidthIncrese = ring.ringWidth * volume;
          const r = Math.abs(Math.sin(i * time * ring.radialSpeed) * (ring.ringWidth + volumeRingWidthIncrese)) + ring.innerRadius - volumeRingWidthIncrese;
          const angle = i * time * ring.rotationSpeed + time * ring.baseRotationSpeed;
          const x = cx + Math.cos(angle) * r;
          const y = cy + Math.sin(angle) * r;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.shadowBlur = 0;
      }

      // ── lines positions ──

      function arcCenter(arc, u, rScale, sign) {
        const r = arc.R * rScale;
        const oR = arc.R * outerR(arc.outerRadiusMaxScale, arc.outerRadiusDuty, u);
        const ang = sign * 2 * Math.PI * arc.orbitRevolutions * u;
        const d = Math.max(0, oR - r);
        return { x: cx + d * Math.cos(ang), y: cy + d * Math.sin(ang) };
      }

      function redArcPos(i, t, rScale) {
        const ang = (-i / (redArc.N - 1)) * Math.PI - i * t;
        const r = redArc.R * rScale;
        return { x: redArc.centerX + r * Math.cos(ang), y: redArc.centerY + r * Math.sin(ang) };
      }

      function blueArcPos(i, ctr, u, rScale) {
        const ang = Math.PI * (1 + i / (blueArc.N - 1)) + 2 * Math.PI * blueArc.selfRevolutions * u;
        const r = blueArc.R * rScale;
        return { x: ctr.x + r * Math.cos(ang), y: ctr.y + r * Math.sin(ang) };
      }

      // ── draw ──

      function draw() {
        const { u, t } = tl;
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = renderStyle.canvasBackground;
        ctx.fillRect(0, 0, W, H);

        // dots
        for (const ring of rings) drawRing(ring, u);

        // lines
        const rrs = redRadiusScale(u),
          brs = blueRadiusScale(u);
        const rc = arcCenter(redArc, u, rrs, -1);
        const bc = arcCenter(blueArc, u, brs, 1);
        const rp = Array.from({ length: redArc.N }, (_, i) => {
          const p = redArcPos(i, t, rrs);
          return { x: p.x + rc.x - redArc.centerX, y: p.y + rc.y - redArc.centerY };
        });
        const bp = Array.from({ length: blueArc.N }, (_, i) => blueArcPos(i, bc, u, brs));

        ctx.lineWidth = 1;
        const { dimScale, brightScale, redArcPeriodMs, blueArcPeriodMs, minBlur, maxBlur } = lineColorConfig;
        const redBr = dimScale + (brightScale - dimScale) * getArcBrightness(redArcPeriodMs);
        const blueBr = dimScale + (brightScale - dimScale) * getArcBrightness(blueArcPeriodMs);
        const redLineColor = scaleColor(renderStyle.lineColor, redBr);
        const blueLineColor = scaleColor(renderStyle.lineColor, blueBr);
        const redNorm = (redBr - dimScale) / (brightScale - dimScale);
        const blueNorm = (blueBr - dimScale) / (brightScale - dimScale);
        const avgNorm = (redNorm + blueNorm) / 2;
        ctx.shadowColor = renderStyle.lineColor;
        ctx.shadowBlur = minBlur + (maxBlur - minBlur) * avgNorm;
        for (let i = 0; i < redArc.N; i++) {
          const grad = ctx.createLinearGradient(rp[i].x, rp[i].y, bp[i].x, bp[i].y);
          grad.addColorStop(0, redLineColor);
          grad.addColorStop(1, blueLineColor);
          ctx.strokeStyle = grad;
          ctx.beginPath();
          ctx.moveTo(rp[i].x, rp[i].y);
          ctx.lineTo(bp[i].x, bp[i].y);
          ctx.stroke();
        }

        // end-of-line dots
        ctx.shadowColor = renderStyle.lineColor;
        ctx.fillStyle = redLineColor;
        ctx.shadowBlur = minBlur + (maxBlur - minBlur) * redNorm;
        for (let i = 0; i < redArc.N; i++) {
          ctx.beginPath();
          ctx.arc(rp[i].x, rp[i].y, 1, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.fillStyle = blueLineColor;
        ctx.shadowBlur = minBlur + (maxBlur - minBlur) * blueNorm;
        for (let i = 0; i < blueArc.N; i++) {
          ctx.beginPath();
          ctx.arc(bp[i].x, bp[i].y, 1, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.shadowBlur = 0;
        const dot = (arr, last, rest) =>
          arr.forEach((p, i) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
            ctx.fillStyle = i === arr.length - 1 ? last : rest;
            ctx.fill();
          });
        if (redArc.showDots) dot(rp, "red", "pink");
        if (blueArc.showDots) dot(bp, "blue", "lightblue");
      }

      // ── screen share audio volume ──

      let screenAudioCtx = null;
      let screenAnalyser = null;
      let screenDestination = null;
      let screenVolumeRaf = null;
      let screenStream = null;
      let screenVolume = 0;

      // ── mic audio volume ──

      let micAudioCtx = null;
      let micAnalyser = null;
      let micVolumeRaf = null;
      let micStream = null;
      let micVolume = 0;

      let currentVolume = 0;

      function measureRms(analyser) {
        const buf = new Float32Array(analyser.fftSize);
        analyser.getFloatTimeDomainData(buf);
        let sum = 0;
        for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
        return Math.sqrt(sum / buf.length);
      }

      function startVolumeLogging(analyser) {
        function loop() {
          screenVolume = measureRms(analyser);
          currentVolume = Math.max(screenVolume, micVolume);
          screenVolumeRaf = requestAnimationFrame(loop);
        }
        loop();
      }

      function startMicVolumeLogging(analyser) {
        function loop() {
          micVolume = measureRms(analyser);
          currentVolume = Math.max(screenVolume, micVolume);
          micVolumeRaf = requestAnimationFrame(loop);
        }
        loop();
      }

      $("shareScreen").addEventListener("click", async () => {
        if (screenStream) {
          // Stop existing share
          screenStream.getTracks().forEach((t) => t.stop());
          screenStream = null;
          if (screenVolumeRaf) cancelAnimationFrame(screenVolumeRaf);
          if (screenAudioCtx) {
            screenAudioCtx.close();
            screenAudioCtx = null;
          }
          screenDestination = null;
          screenVolume = 0;
          currentVolume = Math.max(screenVolume, micVolume);
          $("shareScreen").textContent = "Share Screen";
          return;
        }

        try {
          screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
          $("shareScreen").textContent = "Stop Share";

          const audioTracks = screenStream.getAudioTracks();
          if (audioTracks.length === 0) {
            console.warn("No audio track in screen share — make sure to enable 'Share audio' in the picker.");
            return;
          }

          screenAudioCtx = new AudioContext();
          const source = screenAudioCtx.createMediaStreamSource(new MediaStream(audioTracks));
          screenAnalyser = screenAudioCtx.createAnalyser();
          screenAnalyser.fftSize = 2048;
          screenDestination = screenAudioCtx.createMediaStreamDestination();
          screenDestination.channelCount = 2;
          screenDestination.channelCountMode = "explicit";
          source.connect(screenAnalyser);
          source.connect(screenDestination);
          startVolumeLogging(screenAnalyser);

          screenStream.getVideoTracks()[0]?.addEventListener("ended", () => {
            if (screenVolumeRaf) cancelAnimationFrame(screenVolumeRaf);
            if (screenAudioCtx) {
              screenAudioCtx.close();
              screenAudioCtx = null;
            }
            screenDestination = null;
            screenVolume = 0;
            currentVolume = Math.max(screenVolume, micVolume);
            screenStream = null;
            $("shareScreen").textContent = "Share Screen";
          });
        } catch (err) {
          console.error("Screen share failed:", err);
        }
      });

      $("shareMic").addEventListener("click", async () => {
        if (micStream) {
          micStream.getTracks().forEach((t) => t.stop());
          micStream = null;
          if (micVolumeRaf) cancelAnimationFrame(micVolumeRaf);
          if (micAudioCtx) {
            micAudioCtx.close();
            micAudioCtx = null;
          }
          micVolume = 0;
          currentVolume = Math.max(screenVolume, micVolume);
          $("shareMic").textContent = "Share Mic";
          return;
        }

        try {
          micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          $("shareMic").textContent = "Stop Mic";

          micAudioCtx = new AudioContext();
          const source = micAudioCtx.createMediaStreamSource(micStream);
          micAnalyser = micAudioCtx.createAnalyser();
          micAnalyser.fftSize = 2048;
          source.connect(micAnalyser);
          startMicVolumeLogging(micAnalyser);

          micStream.getAudioTracks()[0]?.addEventListener("ended", () => {
            if (micVolumeRaf) cancelAnimationFrame(micVolumeRaf);
            if (micAudioCtx) {
              micAudioCtx.close();
              micAudioCtx = null;
            }
            micVolume = 0;
            currentVolume = Math.max(screenVolume, micVolume);
            micStream = null;
            $("shareMic").textContent = "Share Mic";
          });
        } catch (err) {
          console.error("Mic share failed:", err);
        }
      });
    </script>
  </body>
</html>
