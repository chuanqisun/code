<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini Video Lab</title>
    <style>
      :root {
        --color-text-primary: #333;
        --color-text-secondary: #555;
        --color-border-light: #eee;
        --color-border-medium: #ccc;
        --color-accent: #4285f4;
        --color-white: white;
        --color-drag-handle: #999;
        --color-drag-handle-hover: #666;
        --color-insert-indicator: #4285f4;
        --color-action-button-hover: #f1f3f4;
        --color-bg-app: #f9f9f9;
        --color-error: #d93025;
        --color-success: #188038;
      }

      * {
        font-size: inherit;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        max-width: 48rem;
        margin: 0 auto;
        padding: 20px;
        color: var(--color-text-primary);
        background-color: var(--color-bg-app);
        line-height: 1.5;
      }

      h1,
      h2 {
        margin-top: 0;
      }
      h1 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
      }
      h2 {
        font-size: 1.1rem;
        margin-bottom: 0.5rem;
        color: var(--color-text-secondary);
      }

      /* Inputs */
      input[type="text"],
      input[type="password"],
      select,
      textarea {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid var(--color-border-medium);
        border-radius: 6px;
        margin-bottom: 12px;
        font-family: inherit;
        background: var(--color-white);
      }

      textarea {
        field-sizing: content;
        resize: none;
        min-height: 60px;
      }

      /* Buttons */
      button {
        cursor: pointer;
        background-color: var(--color-white);
        border: 1px solid var(--color-border-medium);
        padding: 8px 16px;
        border-radius: 6px;
        color: var(--color-text-primary);
        font-weight: 500;
        transition: background 0.2s;
      }
      button:hover {
        background-color: var(--color-action-button-hover);
      }
      button.primary {
        background-color: var(--color-accent);
        color: white;
        border: none;
      }
      button.primary:hover {
        opacity: 0.9;
      }

      .action-bar {
        display: flex;
        gap: 8px;
        margin-bottom: 24px;
        flex-wrap: wrap;
      }

      /* Config Grid */
      .config-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
        margin-bottom: 16px;
        background: var(--color-white);
        padding: 16px;
        border-radius: 8px;
        border: 1px solid var(--color-border-medium);
      }
      .config-item label {
        display: block;
        font-size: 0.85rem;
        color: var(--color-text-secondary);
        margin-bottom: 4px;
      }
      .config-item select {
        margin-bottom: 0;
      }

      /* Input List */
      #input-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 24px;
      }

      .input-item {
        display: grid;
        grid-template-columns: 32px 1fr auto; /* Drag | Content | Controls */
        background: var(--color-white);
        border: 1px solid var(--color-border-medium);
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      }

      .input-item.has-media {
        grid-template-columns: 32px 100px 1fr auto; /* Drag | Thumb | Content | Controls */
      }

      /* Drag Handle */
      .drag-handle {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #f4f4f4;
        cursor: grab;
        color: var(--color-drag-handle);
        border-right: 1px solid var(--color-border-light);
      }
      .drag-handle:hover {
        color: var(--color-drag-handle-hover);
      }
      .input-item.dragging {
        opacity: 0.5;
      }
      .input-item.drag-over-top {
        border-top: 2px solid var(--color-insert-indicator);
      }
      .input-item.drag-over-bottom {
        border-bottom: 2px solid var(--color-insert-indicator);
      }

      /* Media Thumbnail */
      .media-preview {
        width: 100px;
        height: 100px;
        object-fit: cover;
        background: #000;
        border-right: 1px solid var(--color-border-light);
      }
      .video-icon-overlay {
        position: absolute;
        color: white;
        font-size: 24px;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        pointer-events: none;
      }

      /* Content Area */
      .item-content {
        padding: 12px;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      .item-content textarea {
        margin: 0;
        border: 1px solid var(--color-border-light);
      }
      .file-info {
        font-size: 0.85rem;
        color: var(--color-text-secondary);
        word-break: break-all;
      }

      /* Controls Area */
      .item-controls {
        padding: 12px;
        background: #fcfcfc;
        border-left: 1px solid var(--color-border-light);
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-width: 140px;
      }
      .role-select {
        font-size: 0.9rem;
        padding: 4px;
        margin: 0;
      }
      .role-select:has(option:checked:disabled) {
        border-color: var(--color-error);
        background-color: #fce8e6;
      }
      .delete-btn {
        color: var(--color-error);
        border-color: transparent;
        padding: 4px;
        align-self: flex-end;
        font-size: 0.9rem;
      }
      .delete-btn:hover {
        background: #fee;
      }

      /* Output Section */
      .output-card {
        background: var(--color-white);
        border: 1px solid var(--color-border-medium);
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
      }
      .status-bar {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 12px;
        font-size: 0.9rem;
        color: var(--color-text-secondary);
      }
      .status-right {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 4px;
      }
      .timer {
        font-family: monospace;
        font-weight: bold;
      }

      video {
        width: 100%;
        border-radius: 4px;
        background: #000;
        display: block;
      }

      .error-msg {
        color: var(--color-error);
        background: #fce8e6;
        padding: 12px;
        border-radius: 6px;
        font-size: 0.9rem;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <main>
      <!-- Configuration -->
      <section>
        <h2>Configuration</h2>
        <input type="password" id="api-key" placeholder="Enter Gemini API Key" />
        <div class="config-grid">
          <div class="config-item">
            <label>Model</label>
            <select id="cfg-model">
              <option value="veo-3.1-generate-preview">Veo 3.1</option>
              <option value="veo-3.1-fast-generate-preview" selected>Veo 3.1 Fast</option>
              <option value="veo-3.0-generate-001">Veo 3.0</option>
              <option value="veo-3.0-fast-generate-001">Veo 3.0 Fast</option>
            </select>
          </div>
          <div class="config-item">
            <label>Duration</label>
            <select id="cfg-duration">
              <option value="4" selected>4 Seconds</option>
              <option value="6">6 Seconds</option>
              <option value="8">8 Seconds</option>
            </select>
          </div>
          <div class="config-item">
            <label>Aspect Ratio</label>
            <select id="cfg-aspect">
              <option value="16:9">16:9 Landscape</option>
              <option value="9:16">9:16 Portrait</option>
            </select>
          </div>
          <div class="config-item">
            <label>Resolution</label>
            <select id="cfg-resolution">
              <option value="720p">720p</option>
              <option value="1080p">1080p</option>
            </select>
          </div>
        </div>
      </section>

      <!-- Inputs -->
      <section>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem">
          <h2 style="margin-bottom: 0">Inputs</h2>
          <button id="btn-clear-inputs">Clear input</button>
        </div>
        <div id="input-list"></div>

        <div class="action-bar">
          <button id="btn-add-text">+ Text</button>
          <button id="btn-add-image">+ Image</button>
          <button id="btn-add-video">+ Video</button>
          <span style="color: var(--color-text-secondary); font-size: 0.9rem; align-self: center">Drop or paste files</span>
        </div>
      </section>

      <!-- Generation Action -->
      <div class="action-bar">
        <button id="btn-generate" class="primary" style="width: 100%; padding: 12px">Generate Video</button>
      </div>

      <!-- Outputs -->
      <section>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem">
          <h2 style="margin-bottom: 0">Output</h2>
          <button id="btn-clear-outputs">Clear output</button>
        </div>
        <div id="output-list"></div>
      </section>
    </main>

    <!-- Hidden File Input -->
    <input type="file" id="file-picker" style="display: none" />

    <script type="module">
      import { GoogleGenAI } from "https://esm.sh/@google/genai";
      import { get, set, createStore } from "https://esm.sh/idb-keyval";

      class VeoApp {
        static DB_NAME = "veo-workbench";
        static STORE_NAME = "state";

        constructor() {
          this.store = createStore(VeoApp.DB_NAME, VeoApp.STORE_NAME);

          // State
          this.inputs = []; // { id, type: 'text'|'image'|'video', role, content, file: {blob, dataUrl, mimeType} }
          this.outputs = []; // { id, config, videoDataUrl, error }
          this.nextId = 1;
          this.isGenerating = false;
          this.activeGenerations = new Map(); // outputId -> AbortController

          // DOM
          this.dom = {
            apiKey: document.getElementById("api-key"),
            inputList: document.getElementById("input-list"),
            outputList: document.getElementById("output-list"),
            filePicker: document.getElementById("file-picker"),
            config: {
              model: document.getElementById("cfg-model"),
              duration: document.getElementById("cfg-duration"),
              aspect: document.getElementById("cfg-aspect"),
              resolution: document.getElementById("cfg-resolution"),
            },
          };

          this.bindEvents();
          this.loadState();
        }

        bindEvents() {
          // Add Buttons
          document.getElementById("btn-add-text").onclick = () => this.addInput("text");
          document.getElementById("btn-add-image").onclick = () => this.triggerFilePicker("image");
          document.getElementById("btn-add-video").onclick = () => this.triggerFilePicker("video");
          document.getElementById("btn-clear-inputs").onclick = () => {
            this.inputs = [];
            this.renderInputs();
            this.saveState();
          };

          // Generate
          document.getElementById("btn-generate").onclick = () => this.handleGenerate();

          // Global paste handler
          document.addEventListener("paste", (e) => this.handlePaste(e));

          // Global drag and drop handler
          document.body.addEventListener("dragover", (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          });
          document.body.addEventListener("drop", (e) => this.handleDrop(e));

          // Clear Outputs
          document.getElementById("btn-clear-outputs").onclick = () => {
            this.dom.outputList.innerHTML = "";
            this.outputs = [];
            this.saveOutputs();
          };

          // File Picker
          this.dom.filePicker.onchange = (e) => this.handleFileSelection(e);

          // Persistence
          this.dom.apiKey.oninput = (e) => set("apiKey", e.target.value, this.store);
          Object.values(this.dom.config).forEach((el) => {
            el.onchange = () => this.saveState();
          });

          // Re-render inputs when model changes to update available roles
          this.dom.config.model.onchange = () => {
            this.saveState();
            this.renderInputs();
          };
        }

        // --- Input Management ---

        addInput(type, fileData = null) {
          const id = String(this.nextId++);
          let role = "prompt"; // default

          if (type === "image") role = "image"; // Start frame
          if (type === "video") role = "video"; // Extension input

          this.inputs.push({
            id,
            type,
            role,
            content: "",
            file: fileData,
          });
          this.renderInputs();
          this.saveState();
        }

        triggerFilePicker(type) {
          this.dom.filePicker.accept = type === "image" ? "image/*" : "video/*";
          this.dom.filePicker.dataset.targetType = type;
          this.dom.filePicker.click();
        }

        async handleFileSelection(e) {
          const file = e.target.files[0];
          if (!file) return;

          const type = this.dom.filePicker.dataset.targetType;
          const dataUrl = await VeoUtils.blobToDataUrl(file);

          this.addInput(type, {
            blob: file,
            mimeType: file.type,
            dataUrl: dataUrl,
            name: file.name,
          });
          this.dom.filePicker.value = ""; // reset
        }

        async handlePaste(e) {
          // Don't intercept paste when user is typing in a text input
          const activeEl = document.activeElement;
          if (activeEl && (activeEl.tagName === "TEXTAREA" || activeEl.tagName === "INPUT")) {
            return;
          }

          const clipboardData = e.clipboardData;
          if (!clipboardData) return;

          // Check for files (images/videos)
          const files = clipboardData.files;
          if (files.length > 0) {
            e.preventDefault();
            for (const file of files) {
              if (file.type.startsWith("image/")) {
                const dataUrl = await VeoUtils.blobToDataUrl(file);
                this.addInput("image", {
                  blob: file,
                  mimeType: file.type,
                  dataUrl: dataUrl,
                  name: file.name || "pasted-image",
                });
              } else if (file.type.startsWith("video/")) {
                const dataUrl = await VeoUtils.blobToDataUrl(file);
                this.addInput("video", {
                  blob: file,
                  mimeType: file.type,
                  dataUrl: dataUrl,
                  name: file.name || "pasted-video",
                });
              }
            }
            return;
          }

          // Check for plain text
          const text = clipboardData.getData("text/plain");
          if (text && text.trim()) {
            e.preventDefault();
            this.addInput("text");
            // Set the content of the newly added text input
            const lastInput = this.inputs[this.inputs.length - 1];
            lastInput.content = text.trim();
            this.renderInputs();
            this.saveState();
          }
        }

        async handleDrop(e) {
          e.preventDefault();

          const files = e.dataTransfer.files;
          if (files.length === 0) return;

          for (const file of files) {
            if (file.type.startsWith("image/")) {
              const dataUrl = await VeoUtils.blobToDataUrl(file);
              this.addInput("image", {
                blob: file,
                mimeType: file.type,
                dataUrl: dataUrl,
                name: file.name,
              });
            } else if (file.type.startsWith("video/")) {
              const dataUrl = await VeoUtils.blobToDataUrl(file);
              this.addInput("video", {
                blob: file,
                mimeType: file.type,
                dataUrl: dataUrl,
                name: file.name,
              });
            }
          }
        }

        updateInput(id, updates) {
          const idx = this.inputs.findIndex((i) => i.id === id);
          if (idx !== -1) {
            this.inputs[idx] = { ...this.inputs[idx], ...updates };
            this.saveState();
          }
        }

        removeInput(id) {
          this.inputs = this.inputs.filter((i) => i.id !== id);
          this.renderInputs();
          this.saveState();
        }

        // --- Rendering ---

        renderInputs() {
          this.dom.inputList.innerHTML = "";
          this.inputs.forEach((item) => {
            const el = document.createElement("div");
            el.className = `input-item ${item.type !== "text" ? "has-media" : ""}`;
            el.draggable = true;
            el.dataset.id = item.id;

            // 1. Drag Handle
            const drag = document.createElement("div");
            drag.className = "drag-handle";
            drag.innerHTML = "⋮";
            el.appendChild(drag);

            // 2. Media Preview (if applicable)
            if (item.type !== "text") {
              const thumbContainer = document.createElement("div");
              thumbContainer.style.position = "relative";
              thumbContainer.style.display = "flex";
              thumbContainer.style.alignItems = "center";
              thumbContainer.style.justifyContent = "center";
              thumbContainer.style.background = "#000";

              if (item.type === "image") {
                const img = document.createElement("img");
                img.className = "media-preview";
                img.src = item.file.dataUrl;
                thumbContainer.appendChild(img);
              } else {
                const vid = document.createElement("video");
                vid.className = "media-preview";
                vid.src = item.file.dataUrl;
                vid.muted = true;
                thumbContainer.appendChild(vid);
                const icon = document.createElement("div");
                icon.className = "video-icon-overlay";
                icon.innerHTML = "▶";
                thumbContainer.appendChild(icon);
              }
              el.appendChild(thumbContainer);
            }

            // 3. Content
            const content = document.createElement("div");
            content.className = "item-content";
            if (item.type === "text") {
              const ta = document.createElement("textarea");
              ta.placeholder = "Enter text...";
              ta.value = item.content;
              ta.oninput = (e) => this.updateInput(item.id, { content: e.target.value });
              content.appendChild(ta);
            } else {
              const info = document.createElement("div");
              info.className = "file-info";
              info.textContent = item.file.name;
              content.appendChild(info);
            }
            el.appendChild(content);

            // 4. Controls
            const controls = document.createElement("div");
            controls.className = "item-controls";

            const roleSelect = document.createElement("select");
            roleSelect.className = "role-select";
            this.getRolesForType(item.type).forEach((opt) => {
              const option = document.createElement("option");
              option.value = opt.value;
              option.text = opt.label;
              option.selected = item.role === opt.value;
              option.disabled = opt.disabled || false;
              roleSelect.appendChild(option);
            });
            roleSelect.onchange = (e) => this.updateInput(item.id, { role: e.target.value });
            controls.appendChild(roleSelect);

            const delBtn = document.createElement("button");
            delBtn.className = "delete-btn";
            delBtn.textContent = "Remove";
            delBtn.onclick = () => this.removeInput(item.id);
            controls.appendChild(delBtn);

            el.appendChild(controls);

            // Drag Events
            this.setupDragEvents(el, item.id);
            this.dom.inputList.appendChild(el);
          });
        }

        getRolesForType(type) {
          const isVeo3 = this.dom.config.model.value.startsWith("veo-3.0");
          if (type === "text")
            return [
              { value: "prompt", label: "Positive Prompt" },
              { value: "negativePrompt", label: "Negative Prompt" },
            ];
          if (type === "image") {
            return [
              { value: "image", label: "Start Frame" },
              { value: "lastFrame", label: "End Frame" },
              { value: "reference_asset", label: "Reference content", disabled: isVeo3 },
              { value: "reference_style", label: "Reference style", disabled: isVeo3 },
            ];
          }
          if (type === "video") return [{ value: "video", label: "Input Video (Extend)", disabled: isVeo3 }];
          return [];
        }

        // --- Drag & Drop Logic ---
        setupDragEvents(el, id) {
          el.ondragstart = (e) => {
            e.dataTransfer.effectAllowed = "move";
            el.classList.add("dragging");
            this.draggedId = id;
          };
          el.ondragend = () => {
            el.classList.remove("dragging");
            document.querySelectorAll(".input-item").forEach((i) => i.classList.remove("drag-over-top", "drag-over-bottom"));
          };
          el.ondragover = (e) => {
            e.preventDefault();
            if (el.dataset.id === this.draggedId) return;
            const rect = el.getBoundingClientRect();
            const isTop = e.clientY < rect.top + rect.height / 2;
            el.classList.remove("drag-over-top", "drag-over-bottom");
            el.classList.add(isTop ? "drag-over-top" : "drag-over-bottom");
          };
          el.ondragleave = () => el.classList.remove("drag-over-top", "drag-over-bottom");
          el.ondrop = (e) => {
            e.preventDefault();
            el.classList.remove("drag-over-top", "drag-over-bottom");
            if (this.draggedId === id) return;

            const fromIdx = this.inputs.findIndex((i) => i.id === this.draggedId);
            const toIdx = this.inputs.findIndex((i) => i.id === id);
            const rect = el.getBoundingClientRect();
            const isTop = e.clientY < rect.top + rect.height / 2;

            const item = this.inputs.splice(fromIdx, 1)[0];
            let newIdx = toIdx;
            if (fromIdx < toIdx) newIdx = isTop ? toIdx - 1 : toIdx;
            else newIdx = isTop ? toIdx : toIdx + 1;

            this.inputs.splice(newIdx, 0, item);
            this.renderInputs();
            this.saveState();
          };
        }

        // --- Generation Logic ---

        async handleGenerate() {
          const apiKey = this.dom.apiKey.value.trim();
          if (!apiKey) return alert("Please enter an API Key");
          if (this.isGenerating) return;

          this.isGenerating = true;
          const outputId = Date.now();
          const abortController = new AbortController();
          this.activeGenerations.set(outputId, abortController);
          const outputConfig = {
            model: this.dom.config.model.value,
            duration: this.dom.config.duration.value,
            aspect: this.dom.config.aspect.value,
            resolution: this.dom.config.resolution.value,
          };
          this.addOutputItem(outputId, outputConfig);

          try {
            const ai = new GoogleGenAI({ apiKey });

            // 1. Construct Payload
            const params = {
              model: this.dom.config.model.value,
              config: {
                aspectRatio: this.dom.config.aspect.value,
                resolution: this.dom.config.resolution.value,
                durationSeconds: parseInt(this.dom.config.duration.value, 10),
                abortSignal: abortController.signal,
              },
            };

            // 2. Map Inputs to Params
            const prompts = [];
            const negativePrompts = [];
            const references = [];
            const isVeo3 = this.dom.config.model.value.startsWith("veo-3.0");

            for (const input of this.inputs) {
              if (input.type === "text") {
                if (input.role === "prompt") prompts.push(input.content);
                if (input.role === "negativePrompt") negativePrompts.push(input.content);
              } else if (input.type === "image") {
                const b64 = await VeoUtils.blobToBase64(input.file.blob);
                const imgObj = { imageBytes: b64, mimeType: input.file.mimeType };

                if (input.role === "image") params.image = imgObj;
                if (input.role === "lastFrame") params.config.lastFrame = imgObj;
                // Skip reference images for Veo 3.0 models
                if (!isVeo3 && input.role.startsWith("reference_")) {
                  references.push({
                    image: imgObj,
                    referenceType: input.role === "reference_style" ? "STYLE" : "ASSET",
                  });
                }
              } else if (input.type === "video") {
                // Skip video input for Veo 3.0 models
                if (!isVeo3) {
                  const b64 = await VeoUtils.blobToBase64(input.file.blob);
                  params.video = { videoBytes: b64, mimeType: input.file.mimeType };
                }
              }
            }

            if (prompts.length) params.prompt = prompts.join("\n");
            if (negativePrompts.length) params.config.negativePrompt = negativePrompts.join(", ");
            if (references.length) params.config.referenceImages = references;

            // 3. Validation (Basic)
            if (!params.prompt && !params.image && !params.video && !references.length) {
              throw new Error("At least one input (Prompt, Image, Video, or Reference) is required.");
            }

            // 4. Start Operation
            let operation = await ai.models.generateVideos(params);

            // 5. Poll
            this.updateOutputStatus(outputId, "generating");
            const startTime = Date.now();
            const pollInterval = setInterval(() => {
              const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
              this.updateOutputTimer(outputId, `${elapsed}s`);
            }, 100);

            while (!operation.done) {
              // Check if aborted before polling
              if (abortController.signal.aborted) {
                clearInterval(pollInterval);
                throw new DOMException("Generation cancelled", "AbortError");
              }
              await new Promise((r) => setTimeout(r, 5000)); // Poll every 5s
              operation = await ai.operations.getVideosOperation({ operation });
            }

            clearInterval(pollInterval);

            // 6. Handle Result
            if (operation.error) {
              throw new Error(JSON.stringify(operation.error, null, 2));
            }

            const vidData = operation.response.generatedVideos[0].video;

            if (vidData.videoBytes) {
              const blob = await (await fetch(`data:${vidData.mimeType};base64,${vidData.videoBytes}`)).blob();
              const url = URL.createObjectURL(blob);
              const dataUrl = await VeoUtils.blobToDataUrl(blob);
              this.renderOutputVideo(outputId, url);
              this.saveOutput(outputId, outputConfig, dataUrl);
            } else if (vidData.uri) {
              // Download the video using the URI with API key authentication
              this.updateOutputStatus(outputId, "downloading");
              const videoResponse = await fetch(vidData.uri, {
                headers: { "x-goog-api-key": apiKey },
                redirect: "follow",
              });
              if (!videoResponse.ok) {
                throw new Error(`Failed to download video: ${videoResponse.status} ${videoResponse.statusText}`);
              }
              const videoBlob = await videoResponse.blob();
              const url = URL.createObjectURL(videoBlob);
              const dataUrl = await VeoUtils.blobToDataUrl(videoBlob);
              this.renderOutputVideo(outputId, url);
              this.saveOutput(outputId, outputConfig, dataUrl);
            } else {
              throw new Error("No video data returned.");
            }
          } catch (e) {
            // Don't show error if it was an intentional cancellation
            if (e.name === "AbortError") {
              // Output was already removed by user, nothing to do
            } else {
              console.log("Generation error:", e);
              this.renderOutputError(outputId, e.message);
            }
          } finally {
            this.activeGenerations.delete(outputId);
            this.isGenerating = false;
          }
        }

        // --- Output Management ---

        addOutputItem(id, config) {
          const div = document.createElement("div");
          div.className = "output-card";
          div.id = `out-${id}`;
          div.innerHTML = `
            <div class="status-bar">
              <span class="config-info">${config.model} · ${config.duration}s · ${config.aspect} · ${config.resolution} · <span class="status-text">starting</span></span>
              <div class="status-right">
                <span class="timer">0.0s</span>
                <button class="delete-btn output-remove-btn">Remove</button>
              </div>
            </div>
            <div class="video-container"></div>
          `;
          div.querySelector(".output-remove-btn").onclick = () => this.removeOutput(id);
          this.dom.outputList.prepend(div);
        }

        updateOutputStatus(id, statusText) {
          const el = document.getElementById(`out-${id}`);
          if (!el) return;
          const status = el.querySelector(".status-text");
          if (status) status.textContent = statusText;
        }

        updateOutputTimer(id, timeText) {
          const el = document.getElementById(`out-${id}`);
          if (!el) return;
          const timer = el.querySelector(".timer");
          timer.textContent = timeText;
        }

        renderOutputVideo(id, url) {
          const el = document.getElementById(`out-${id}`);
          if (!el) return;
          const configInfo = el.querySelector(".config-info").cloneNode(true);
          const statusText = configInfo.querySelector(".status-text");
          if (statusText) statusText.remove();
          // Remove trailing " · " from config info
          const cleanConfigInfo = configInfo.textContent.replace(/ · $/, "");
          const finalTime = el.querySelector(".timer").textContent;
          el.querySelector(".status-bar").innerHTML =
            `<span class="config-info">${cleanConfigInfo}</span><div class="status-right"><span class="timer">${finalTime}</span><button class="delete-btn output-remove-btn">Remove</button></div>`;
          el.querySelector(".output-remove-btn").onclick = () => this.removeOutput(id);

          const container = el.querySelector(".video-container");
          container.innerHTML = `
            <video controls autoplay loop src="${url}"></video>
            <div style="margin-top:8px; text-align:right">
              <a href="${url}" download="veo_video_${id}.mp4"><button>Download MP4</button></a>
            </div>
          `;
        }

        renderOutputError(id, msg) {
          const el = document.getElementById(`out-${id}`);
          if (!el) return;
          const configInfo = el.querySelector(".config-info").cloneNode(true);
          const statusText = configInfo.querySelector(".status-text");
          if (statusText) statusText.remove();
          // Remove trailing " · " from config info
          const cleanConfigInfo = configInfo.textContent.replace(/ · $/, "");
          const finalTime = el.querySelector(".timer").textContent;
          el.querySelector(".status-bar").innerHTML =
            `<span class="config-info">${cleanConfigInfo}</span><div class="status-right"><span class="timer">${finalTime}</span><button class="delete-btn output-remove-btn">Remove</button></div>`;
          el.querySelector(".output-remove-btn").onclick = () => this.removeOutput(id);
          el.querySelector(".video-container").innerHTML = `<div class="error-msg">${msg}</div>`;
        }

        removeOutput(id) {
          // Cancel any active generation for this output
          const controller = this.activeGenerations.get(id);
          if (controller) {
            controller.abort();
            this.activeGenerations.delete(id);
          }
          const el = document.getElementById(`out-${id}`);
          if (el) el.remove();
          // Remove from saved outputs
          this.outputs = this.outputs.filter((o) => o.id !== id);
          this.saveOutputs();
        }

        // --- Output Persistence ---

        async saveOutput(id, config, videoDataUrl) {
          this.outputs.push({ id, config, videoDataUrl });
          await this.saveOutputs();
        }

        async saveOutputs() {
          await set("outputs", this.outputs, this.store);
        }

        async loadOutputs() {
          const savedOutputs = await get("outputs", this.store);
          if (savedOutputs && savedOutputs.length) {
            this.outputs = savedOutputs;
            // Render in reverse order so newer outputs appear on top
            for (let i = this.outputs.length - 1; i >= 0; i--) {
              this.renderSavedOutput(this.outputs[i]);
            }
          }
        }

        renderSavedOutput(output) {
          const { id, config, videoDataUrl } = output;
          const div = document.createElement("div");
          div.className = "output-card";
          div.id = `out-${id}`;
          div.innerHTML = `
            <div class="status-bar">
              <span class="config-info">${config.model} · ${config.duration}s · ${config.aspect} · ${config.resolution}</span>
              <div class="status-right">
                <button class="delete-btn output-remove-btn">Remove</button>
              </div>
            </div>
            <div class="video-container">
              <video controls loop src="${videoDataUrl}"></video>
              <div style="margin-top:8px; text-align:right">
                <a href="${videoDataUrl}" download="veo_video_${id}.mp4"><button>Download MP4</button></a>
              </div>
            </div>
          `;
          div.querySelector(".output-remove-btn").onclick = () => this.removeOutput(id);
          this.dom.outputList.prepend(div);
        }

        // --- Persistence ---

        async loadState() {
          const key = await get("apiKey", this.store);
          if (key) this.dom.apiKey.value = key;

          const savedInputs = await get("inputs", this.store);
          if (savedInputs) {
            // Rehydrate blobs from stored data (simplified for demo, usually store metadata)
            // Since we can't easily store Blobs in IDB across sessions reliably without re-creating them from DataURLs
            // We will rely on DataURLs stored in state.
            this.inputs = savedInputs.map((i) => {
              // Reconstruct file object structure if needed
              return i;
            });
            this.nextId = (Math.max(...this.inputs.map((i) => parseInt(i.id))) || 0) + 1;
            this.renderInputs();
          }

          const savedConfig = await get("config", this.store);
          if (savedConfig) {
            this.dom.config.model.value = savedConfig.model;
            this.dom.config.duration.value = savedConfig.duration;
            this.dom.config.aspect.value = savedConfig.aspect;
            this.dom.config.resolution.value = savedConfig.resolution;
          }

          // Load saved outputs
          await this.loadOutputs();
        }

        async saveState() {
          // We store inputs. For files, we store the DataURL which is heavy but works for a demo.
          // In prod, use FileSystem API or just don't persist heavy media.
          await set("inputs", this.inputs, this.store);
          await set(
            "config",
            {
              model: this.dom.config.model.value,
              duration: this.dom.config.duration.value,
              aspect: this.dom.config.aspect.value,
              resolution: this.dom.config.resolution.value,
            },
            this.store
          );
        }
      }

      class VeoUtils {
        static blobToBase64(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(",")[1]);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }
        static blobToDataUrl(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }
      }

      document.addEventListener("DOMContentLoaded", () => new VeoApp());
    </script>
  </body>
</html>
