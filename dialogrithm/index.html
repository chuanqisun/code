<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>The Loom of Time</title>
    <style>
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        background-color: #050505;
        color: #a3b8c7;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        overflow: hidden;
      }
      pre {
        font-family: 'Courier New', Courier, monospace;
        font-size: 12px;
        line-height: 1;
        letter-spacing: 0px;
        white-space: pre;
        margin: 0;
        padding: 0;
      }
      #start-btn {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: transparent;
        border: 1px solid #a3b8c7;
        color: #a3b8c7;
        font-family: 'Courier New', Courier, monospace;
        font-size: 13px;
        padding: 10px 24px;
        cursor: pointer;
        letter-spacing: 2px;
        z-index: 100;
      }
      #start-btn:hover {
        background: #a3b8c720;
      }
    </style>
  </head>
  <body>
    <pre id="loom"></pre>
    <button id="start-btn">[ ENGAGE ]</button>

    <script>
      const LAYOUT = {
        ASPECT_RATIO: 9 / 16,
        COLS_TARGET: 120,
        MARGIN_CH: 1,
      };

      const PARAMS = {
        CHAR_OUTSIDE: " ",
        CHAR_INSIDE_EMPTY: " ",
        THREAD_SYMBOLS_TOP: "IN THE BEGINNING THERE WAS THE COMMAND LINE. THE LOOM SPINS THE VOID INTO STRUCTURE. TIME WEAVES MEANING FROM THE ETHER. ",
        THREAD_SYMBOLS_BOT: "!#%&*+=|\\/<>[]{}^~?@$;:",
        THREADS: 24,
        ENVELOPE_POWER: 2.0,
        TOP_SWAY_AMP_1: 0.18,
        TOP_SWAY_FREQ_1: 1.3,
        TOP_SWAY_AMP_2: 0.1,
        TOP_SWAY_FREQ_2: 2.7,
        TOP_SWAY_SPACE_F: 3.5,
        BOT_SWAY_AMP_1: 0.12,
        BOT_SWAY_FREQ_1: 0.5,
        BOT_SWAY_AMP_2: 0.07,
        BOT_SWAY_FREQ_2: 1.1,
        BOT_SWAY_SPACE_F: 2.0,
        TOP_TIME_MULT: 2.5,
        TOP_FREQ_SPREAD: 0.08,
        BOT_TIME_MULT: 0.6,
        BOT_FREQ_SPREAD: 0.02,
        TOP_BASE_SPEED: 0.05,
        TOP_MOD_AMP: 0.4,
        TOP_MOD_FREQ: 0.17,
        TOP_MOD_PHASE: 0.0,
        BOT_BASE_SPEED: 0.05,
        BOT_MOD_AMP: 0.4,
        BOT_MOD_FREQ: 0.29,
        BOT_MOD_PHASE: 2.1,
      };

      const BPM = 126;
      const BEAT_SEC = 60 / BPM;
      const BURST_SIZE = 128;
      const SPEED_MIN = 0.28; // grid cells per frame
      const SPEED_MAX = 1.0;
      const FADE_FRAMES = Math.round(((BEAT_SEC * 1000) / 16) * 2.5); // ~2.5 beats
      const DUCK_DEPTH = 0.85;
      const DUCK_RELEASE = BEAT_SEC * 0.85;

      let COLS = LAYOUT.COLS_TARGET;
      let ROWS = 40;
      let cellW = 1,
        cellH = 1; // updated by measureCharCell

      // Grid origin in viewport pixels — needed to map particles to cells
      let gridOriginX = 0;
      let gridOriginY = 0;

      let wall = 100.0,
        timeTop = 100.0,
        timeBot = 100.0;

      const display = document.getElementById("loom");

      // ── GRID SIZING ───────────────────────────────────────

      function measureCharCell() {
        const probe = document.createElement("pre");
        probe.style.cssText = [
          "position:absolute",
          "visibility:hidden",
          "pointer-events:none",
          "margin:0",
          "padding:0",
          `font-family:${getComputedStyle(display).fontFamily}`,
          `font-size:${getComputedStyle(display).fontSize}`,
          `line-height:${getComputedStyle(display).lineHeight}`,
          `letter-spacing:${getComputedStyle(display).letterSpacing}`,
          "white-space:pre",
        ].join(";");
        probe.textContent = ("X".repeat(10) + "\n").repeat(10).trimEnd();
        document.body.appendChild(probe);
        const rect = probe.getBoundingClientRect();
        document.body.removeChild(probe);
        return { cellW: rect.width / 10, cellH: rect.height / 10 };
      }

      function recalcGrid() {
        ({ cellW, cellH } = measureCharCell());
        const marginPx = LAYOUT.MARGIN_CH * cellW;
        const availW = window.innerWidth - marginPx * 2;
        const availH = window.innerHeight - marginPx * 2;

        let cols = Math.min(LAYOUT.COLS_TARGET, Math.floor(availW / cellW));
        let rows = Math.floor((cols * cellW) / LAYOUT.ASPECT_RATIO / cellH);

        if (rows * cellH > availH) {
          rows = Math.floor(availH / cellH);
          cols = Math.floor((rows * cellH * LAYOUT.ASPECT_RATIO) / cellW);
        }

        COLS = Math.max(cols, 4);
        ROWS = Math.max(rows, 2);

        // The pre is centred by flexbox; compute its top-left corner
        gridOriginX = (window.innerWidth - COLS * cellW) / 2;
        gridOriginY = (window.innerHeight - ROWS * cellH) / 2;
      }

      // ── AUDIO ─────────────────────────────────────────────

      let ctx = null,
        masterGain = null,
        chordGain = null;
      let chordOscs = [];
      let beatSchedulerTimer = null;
      let nextBeatTime = 0;
      const SCHEDULE_AHEAD = 0.1;
      const SCHEDULER_TICK = 25;

      function playKick(time) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(150, time);
        osc.frequency.exponentialRampToValueAtTime(40, time + 0.12);
        gain.gain.setValueAtTime(0.7, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start(time);
        osc.stop(time + 0.35);
      }

      function duckChord(time) {
        chordGain.gain.cancelScheduledValues(time);
        chordGain.gain.setValueAtTime(1.0 - DUCK_DEPTH, time);
        chordGain.gain.linearRampToValueAtTime(1.0, time + DUCK_RELEASE);
      }

      function schedulerTick() {
        while (nextBeatTime < ctx.currentTime + SCHEDULE_AHEAD) {
          playKick(nextBeatTime);
          duckChord(nextBeatTime);
          pendingBursts.push(nextBeatTime);
          nextBeatTime += BEAT_SEC;
        }
      }

      // ── PARTICLES (grid-space) ────────────────────────────
      // Position and velocity are in fractional grid columns / rows.

      const textSource = `In the Beginning was the Command Line

by Neal Stephenson

About twenty years ago Jobs and Wozniak, the founders of Apple, came up with the very strange idea of selling information processing machines for use in the home. The business took off, and its founders made a lot of money and received the credit they deserved for being daring visionaries. But around the same time, Bill Gates and Paul Allen came up with an idea even stranger and more fantastical: selling computer operating systems. This was much weirder than the idea of Jobs and Wozniak. A computer at least had some sort of physical reality to it. It came in a box, you could open it up and plug it in and watch lights blink. An operating system had no tangible incarnation at all. It arrived on a disk, of course, but the disk was, in effect, nothing more than the box that the OS came in. The product itself was a very long string of ones and zeroes that, when properly installed and coddled, gave you the ability to manipulate other very long strings of ones and zeroes. Even those few who actually understood what a computer operating system was were apt to think of it as a fantastically arcane engineering prodigy, like a breeder reactor or a U-2 spy plane, and not something that could ever be (in the parlance of high-tech) "productized."`.trim();

      const printableChars = textSource.split("").filter((c) => c.trim().length > 0);
      let textIndex = 0;
      let particles = [];
      let pendingBursts = [];

      function spawnBurst() {
        // Centre of the grid in fractional cell coordinates
        const cx = COLS / 2;
        const cy = ROWS / 2;

        for (let i = 0; i < BURST_SIZE; i++) {
          const angle = Math.random() * Math.PI * 2;
          // Scale horizontal speed by cellH/cellW so the visual trajectory
          // looks circular despite non-square cells
          const speed = SPEED_MIN + Math.random() * (SPEED_MAX - SPEED_MIN);
          const vx = Math.cos(angle) * speed * (cellH / cellW);
          const vy = Math.sin(angle) * speed;

          particles.push({
            char: printableChars[textIndex++ % printableChars.length],
            x: cx,
            y: cy,
            vx,
            vy,
            age: 0,
          });
        }
      }

      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.age++;
          // Remove once fully faded or off-grid (with margin)
          if (p.age >= FADE_FRAMES || p.x < -2 || p.x > COLS + 2 || p.y < -2 || p.y > ROWS + 2) {
            particles.splice(i, 1);
          }
        }
      }

      // Write live particles into the 2-D grid buffer.
      // Brighter particles win when two land on the same cell.
      function paintParticles(grid) {
        // grid is an array of ROWS arrays, each COLS wide, holding { char, alpha }
        for (const p of particles) {
          const col = Math.round(p.x);
          const row = Math.round(p.y);
          if (col < 0 || col >= COLS || row < 0 || row >= ROWS) continue;
          const alpha = 1 - p.age / FADE_FRAMES;
          const cell = grid[row][col];
          // Only overwrite if this particle is brighter than whatever is there
          if (!cell.particle || alpha > cell.particleAlpha) {
            cell.particle = p.char;
            cell.particleAlpha = alpha;
          }
        }
      }

      // ── LOOM ──────────────────────────────────────────────

      function computeSway(ny, isBottom, t) {
        if (!isBottom) {
          return (
            Math.sin(t * PARAMS.TOP_SWAY_FREQ_1 + ny * PARAMS.TOP_SWAY_SPACE_F) * PARAMS.TOP_SWAY_AMP_1 +
            Math.sin(t * PARAMS.TOP_SWAY_FREQ_2 + ny * PARAMS.TOP_SWAY_SPACE_F * 1.7 + 1.3) * PARAMS.TOP_SWAY_AMP_2
          );
        } else {
          return (
            Math.sin(t * PARAMS.BOT_SWAY_FREQ_1 + ny * PARAMS.BOT_SWAY_SPACE_F + 0.9) * PARAMS.BOT_SWAY_AMP_1 +
            Math.sin(t * PARAMS.BOT_SWAY_FREQ_2 + ny * PARAMS.BOT_SWAY_SPACE_F * 2.1 + 2.4) * PARAMS.BOT_SWAY_AMP_2
          );
        }
      }

      let lastTimestamp = null;

      function render(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        lastTimestamp = timestamp;

        // ── audio-driven burst trigger ──
        if (ctx) {
          let i = 0;
          while (i < pendingBursts.length) {
            if (ctx.currentTime >= pendingBursts[i]) {
              spawnBurst();
              pendingBursts.splice(i, 1);
            } else {
              i++;
            }
          }
        }

        updateParticles();

        // ── loom tick ──
        const topSpeed = PARAMS.TOP_BASE_SPEED * (1 + PARAMS.TOP_MOD_AMP * Math.sin(PARAMS.TOP_MOD_FREQ * wall + PARAMS.TOP_MOD_PHASE));
        const botSpeed = PARAMS.BOT_BASE_SPEED * (1 + PARAMS.BOT_MOD_AMP * Math.sin(PARAMS.BOT_MOD_FREQ * wall + PARAMS.BOT_MOD_PHASE));
        wall += 0.016;
        timeTop += topSpeed;
        timeBot += botSpeed;

        // ── build cell grid ──
        // Each cell: { char: string, particle: string|null, particleAlpha: number }
        const grid = [];
        for (let y = 0; y < ROWS; y++) {
          grid[y] = [];
          for (let x = 0; x < COLS; x++) {
            grid[y][x] = { char: PARAMS.CHAR_OUTSIDE, particle: null, particleAlpha: 0 };
          }
        }

        let globalTopOffset = Math.floor(timeTop * 6);
        let globalBotOffset = Math.floor(timeBot * 14);

        for (let y = 0; y < ROWS; y++) {
          const ny = (y / ROWS) * 2 - 1;
          const isBottom = ny > 0;
          const t = isBottom ? timeBot : timeTop;
          const envelope = Math.pow(Math.abs(ny), PARAMS.ENVELOPE_POWER);
          const sway = computeSway(ny, isBottom, t) * Math.abs(ny);
          const leftBound = -envelope + sway;
          const rightBound = envelope + sway;

          // Fill inside/outside
          for (let x = 0; x < COLS; x++) {
            const nx = (x / COLS) * 2 - 1;
            grid[y][x].char = nx < leftBound || nx > rightBound ? PARAMS.CHAR_OUTSIDE : PARAMS.CHAR_INSIDE_EMPTY;
          }

          // Threads
          for (let th = 0; th < PARAMS.THREADS; th++) {
            const phase = th * ((Math.PI * 2) / PARAMS.THREADS);
            let wave;
            if (!isBottom) {
              wave = Math.sin(t * PARAMS.TOP_TIME_MULT * (1 + th * PARAMS.TOP_FREQ_SPREAD) + ny * Math.PI * 4 + phase);
            } else {
              wave = Math.sin(t * PARAMS.BOT_TIME_MULT * (1 + th * PARAMS.BOT_FREQ_SPREAD) + ny * Math.PI * 2 + phase);
            }
            const x = Math.floor(((wave * envelope + sway + 1) / 2) * COLS);
            if (x >= 0 && x < COLS) {
              const nx = (x / COLS) * 2 - 1;
              if (nx >= leftBound && nx <= rightBound) grid[y][x].char = "\x00";
            }
          }

          // Assign characters to thread markers
          if (!isBottom) {
            const text = PARAMS.THREAD_SYMBOLS_TOP;
            for (let x = 0; x < COLS; x++) {
              if (grid[y][x].char === "\x00") {
                grid[y][x].char = text[globalTopOffset++ % text.length];
              }
            }
          } else {
            const syms = PARAMS.THREAD_SYMBOLS_BOT;
            for (let x = 0; x < COLS; x++) {
              if (grid[y][x].char === "\x00") {
                const i1 = globalBotOffset;
                const i2 = Math.floor(Math.sin(x * 0.7 + timeBot * 3.1) * 7 + 7);
                const i3 = Math.floor(Math.cos(y * 1.3 + timeBot * 1.7) * 5 + 5);
                grid[y][x].char = syms[(i1 + i2 + i3) % syms.length];
                globalBotOffset++;
              }
            }
          }
        }

        // ── paint particles on top ──
        paintParticles(grid);

        // ── serialise to string ──
        // Particles use ANSI-style brightness via Unicode block — but since
        // we're in a plain <pre> we approximate fade with character choice.
        // Full-bright → the character itself; dim → '·'; nearly gone → '.'
        const DIM_CHARS = [".", "·", "+"];

        let out = "";
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const cell = grid[y][x];
            if (cell.particle !== null) {
              // Map alpha to a visible fade: above 0.5 show the real char,
              // below that degrade through dim stand-ins
              if (cell.particleAlpha > 0.05) {
                out += cell.particle;
              } else if (cell.particleAlpha > 0.01) {
                out += DIM_CHARS[0 + Math.floor((1 - cell.particleAlpha / 0.55) * 2)];
              } else {
                out += ".";
              }
            } else {
              out += cell.char;
            }
          }
          out += "\n";
        }

        display.textContent = out;
        requestAnimationFrame(render);
      }

      // ── BOOT ──────────────────────────────────────────────

      document.getElementById("start-btn").addEventListener("click", () => {
        document.getElementById("start-btn").remove();

        ctx = new (window.AudioContext || window.webkitAudioContext)();

        masterGain = ctx.createGain();
        masterGain.gain.value = 0.8;
        masterGain.connect(ctx.destination);

        chordGain = ctx.createGain();
        chordGain.gain.value = 1;
        [130.81, 155.56, 196.0, 233.08].forEach((f) => {
          const osc = ctx.createOscillator();
          osc.type = "sawtooth";
          osc.frequency.value = f;
          const g = ctx.createGain();
          g.gain.value = 0.08;
          osc.connect(g);
          g.connect(chordGain);
          osc.start();
          chordOscs.push(osc);
        });

        const lp = ctx.createBiquadFilter();
        lp.type = "lowpass";
        lp.frequency.value = 800;
        lp.Q.value = 1;
        chordGain.connect(lp);
        lp.connect(masterGain);

        nextBeatTime = ctx.currentTime + 0.05;
        beatSchedulerTimer = setInterval(schedulerTick, SCHEDULER_TICK);
        schedulerTick();
      });

      let resizeTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(recalcGrid, 100);
      });

      recalcGrid();
      requestAnimationFrame(render);
    </script>
  </body>
</html>
