<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Dialogrithm</title>
    <style>
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        background-color: #050505;
        color: #a3b8c7;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        overflow: hidden;
      }
      pre {
        font-family: 'Courier New', Courier, monospace;
        font-size: 12px;
        line-height: 1;
        letter-spacing: 0px;
        white-space: pre;
        margin: 0;
        padding: 0;
      }
      #start-btn {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #050505;
        border: 1px solid #a3b8c7;
        color: #a3b8c7;
        font-family: 'Courier New', Courier, monospace;
        font-size: 13px;
        padding: 10px 24px;
        cursor: pointer;
        letter-spacing: 2px;
        z-index: 100;
      }
      #start-btn:hover {
        background: #101010;
      }
    </style>
  </head>
  <body>
    <pre id="loom"></pre>
    <button id="start-btn">[ GENERATE ]</button>

    <script>
      // CONFIGURATION

      const GRID = {
        TARGET_COLS: 120,
        ASPECT_RATIO: 9 / 16,
        MARGIN_CHARS: 1,
      };

      const LOOM = {
        THREAD_COUNT: 24,
        ENVELOPE_POWER: 2.0,

        TOP_SWAY_AMP_1: 0.18,
        TOP_SWAY_FREQ_1: 1.3,
        TOP_SWAY_AMP_2: 0.1,
        TOP_SWAY_FREQ_2: 2.7,
        TOP_SWAY_SPATIAL: 3.5,

        BOT_SWAY_AMP_1: 0.12,
        BOT_SWAY_FREQ_1: 0.5,
        BOT_SWAY_AMP_2: 0.07,
        BOT_SWAY_FREQ_2: 1.1,
        BOT_SWAY_SPATIAL: 2.0,

        TOP_TIME_SCALE: 2.5,
        TOP_FREQ_SPREAD: 0.08,
        BOT_TIME_SCALE: 0.6,
        BOT_FREQ_SPREAD: 0.02,

        TOP_SPEED_BASE: 0.05,
        TOP_SPEED_MOD_AMP: 0.4,
        TOP_SPEED_MOD_FREQ: 0.17,
        TOP_SPEED_MOD_PHASE: 0.0,

        BOT_SPEED_BASE: 0.05,
        BOT_SPEED_MOD_AMP: 0.4,
        BOT_SPEED_MOD_FREQ: 0.29,
        BOT_SPEED_MOD_PHASE: 2.1,

        WALL_TICK_RATE: 0.016,

        CHAR_OUTSIDE: " ",
        CHAR_INSIDE_EMPTY: " ",
        BOT_THREAD_SYMBOLS: "!#%&*+=|\\/<>[]{}^~?@$;:",
      };

      const SOURCE_TEXT = {
        FETCH_URL: new URL("./command.txt", window.location.href).href,
        FALLBACK_TEXT: "IN THE BEGINNING WAS THE COMMAND LINE. ",
      };

      const PARTICLES = {
        BURST_SIZE: 128,
        SPEED_MIN: 0.28,
        SPEED_MAX: 1.0,
        DIM_CHARS: [".", "·", "+"],
        DIM_THRESHOLD_LO: 0.01,
        DIM_THRESHOLD_HI: 0.05,
        DIM_ALPHA_SCALE: 0.55,
      };

      const RHYTHM = {
        BPM: 126,
        SCHEDULER_LOOKAHEAD_SECS: 0.1,
        SCHEDULER_TICK_MS: 25,
      };

      const KICK = {
        FREQ_START: 150,
        FREQ_END: 40,
        FREQ_RAMP_SECS: 0.12,
        GAIN_PEAK: 0.7,
        GAIN_DECAY_SECS: 0.3,
        DURATION_SECS: 0.35,
      };

      const CHORD = {
        FREQUENCIES: [130.81, 155.56, 196.0, 233.08],
        OSC_TYPE: "sawtooth",
        VOICE_GAIN: 0.08,
        DUCK_DEPTH: 0.85,
        DUCK_RELEASE_BEATS: 0.85,
      };

      const FILTER = {
        TYPE: "lowpass",
        Q: 1,
        FREQ_LOW: 400,
        FREQ_HIGH: 3200,
        OSCILLATION_PERIOD_SECS: 8,
      };

      const MASTER = {
        GAIN: 0.8,
        STARTUP_OFFSET_SECS: 0.05,
      };

      // DERIVED CONSTANTS

      const BEAT_DURATION_SECS = 60 / RHYTHM.BPM;
      const PARTICLE_FADE_FRAMES = Math.round(((BEAT_DURATION_SECS * 1000) / 16) * 2.5);
      const DUCK_RELEASE_SECS = BEAT_DURATION_SECS * CHORD.DUCK_RELEASE_BEATS;

      // GRID STATE

      let gridCols = GRID.TARGET_COLS;
      let gridRows = 40;
      let charCellWidth = 1;
      let charCellHeight = 1;

      // LOOM STATE

      let wallClock = 100.0;
      let topTimeClock = 100.0;
      let botTimeClock = 100.0;

      // AUDIO STATE

      let audioCtx = null;
      let masterGainNode = null;
      let chordGainNode = null;
      let filterNode = null;
      let filterLfoNode = null;
      let nextBeatTime = 0;
      let beatSchedulerId = null;
      let pendingBeatTimes = [];

      // TEXT CURSORS
      // topThreadCursor starts with the fallback text and is replaced once the
      // fetch resolves, so the loom is never empty while loading.

      const display = document.getElementById("loom");

      function makeCyclicCharCursor(sourceString) {
        const printableChars = sourceString.split("").filter((c) => c.trim().length > 0);
        if (printableChars.length === 0) printableChars.push("?");
        let position = 0;
        return {
          next() {
            return printableChars[position++ % printableChars.length];
          },
          randomPick() {
            return printableChars[Math.floor(Math.random() * printableChars.length)];
          },
          advance(n) {
            position += n;
          },
          get position() {
            return position;
          },
        };
      }

      let topThreadCursor = makeCyclicCharCursor(SOURCE_TEXT.FALLBACK_TEXT);
      const botThreadCursor = makeCyclicCharCursor(LOOM.BOT_THREAD_SYMBOLS);

      function replaceTopThreadCursorWhenReady(fetchPromise) {
        fetchPromise.then((text) => {
          topThreadCursor = makeCyclicCharCursor(text);
        });
      }

      function fetchTopThreadSourceText() {
        return fetch(SOURCE_TEXT.FETCH_URL)
          .then((res) => {
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.text();
          })
          .catch(() => SOURCE_TEXT.FALLBACK_TEXT);
      }

      function pickBurstChar() {
        return Math.random() < 0.5 ? topThreadCursor.randomPick() : botThreadCursor.randomPick();
      }

      // PARTICLE STATE

      let activeParticles = [];

      // GRID SIZING

      function measureCharCellSize() {
        const probe = document.createElement("pre");
        probe.style.cssText = [
          "position:absolute",
          "visibility:hidden",
          "pointer-events:none",
          "margin:0",
          "padding:0",
          `font-family:${getComputedStyle(display).fontFamily}`,
          `font-size:${getComputedStyle(display).fontSize}`,
          `line-height:${getComputedStyle(display).lineHeight}`,
          `letter-spacing:${getComputedStyle(display).letterSpacing}`,
          "white-space:pre",
        ].join(";");
        probe.textContent = ("X".repeat(10) + "\n").repeat(10).trimEnd();
        document.body.appendChild(probe);
        const rect = probe.getBoundingClientRect();
        document.body.removeChild(probe);
        return { width: rect.width / 10, height: rect.height / 10 };
      }

      function recalcGridDimensions() {
        const cell = measureCharCellSize();
        charCellWidth = cell.width;
        charCellHeight = cell.height;

        const marginPx = GRID.MARGIN_CHARS * charCellWidth;
        const availableWidth = window.innerWidth - marginPx * 2;
        const availableHeight = window.innerHeight - marginPx * 2;

        let cols = Math.min(GRID.TARGET_COLS, Math.floor(availableWidth / charCellWidth));
        let rows = Math.floor((cols * charCellWidth) / GRID.ASPECT_RATIO / charCellHeight);

        if (rows * charCellHeight > availableHeight) {
          rows = Math.floor(availableHeight / charCellHeight);
          cols = Math.floor((rows * charCellHeight * GRID.ASPECT_RATIO) / charCellWidth);
        }

        gridCols = Math.max(cols, 4);
        gridRows = Math.max(rows, 2);
      }

      // LOOM GEOMETRY

      function computeRowSway(normalisedY, isBottomHalf, timeClock) {
        if (!isBottomHalf) {
          return (
            Math.sin(timeClock * LOOM.TOP_SWAY_FREQ_1 + normalisedY * LOOM.TOP_SWAY_SPATIAL) * LOOM.TOP_SWAY_AMP_1 +
            Math.sin(timeClock * LOOM.TOP_SWAY_FREQ_2 + normalisedY * LOOM.TOP_SWAY_SPATIAL * 1.7 + 1.3) * LOOM.TOP_SWAY_AMP_2
          );
        } else {
          return (
            Math.sin(timeClock * LOOM.BOT_SWAY_FREQ_1 + normalisedY * LOOM.BOT_SWAY_SPATIAL + 0.9) * LOOM.BOT_SWAY_AMP_1 +
            Math.sin(timeClock * LOOM.BOT_SWAY_FREQ_2 + normalisedY * LOOM.BOT_SWAY_SPATIAL * 2.1 + 2.4) * LOOM.BOT_SWAY_AMP_2
          );
        }
      }

      function computeThreadWave(threadIndex, normalisedY, isBottomHalf, timeClock) {
        const phase = threadIndex * ((Math.PI * 2) / LOOM.THREAD_COUNT);
        if (!isBottomHalf) {
          return Math.sin(timeClock * LOOM.TOP_TIME_SCALE * (1 + threadIndex * LOOM.TOP_FREQ_SPREAD) + normalisedY * Math.PI * 4 + phase);
        } else {
          return Math.sin(timeClock * LOOM.BOT_TIME_SCALE * (1 + threadIndex * LOOM.BOT_FREQ_SPREAD) + normalisedY * Math.PI * 2 + phase);
        }
      }

      function computeModulatedTickRate(referenceClock, baseSpeed, modAmp, modFreq, modPhase) {
        return baseSpeed * (1 + modAmp * Math.sin(modFreq * referenceClock + modPhase));
      }

      // CELL GRID CONSTRUCTION

      function buildEmptyCellGrid() {
        const grid = [];
        for (let row = 0; row < gridRows; row++) {
          grid[row] = [];
          for (let col = 0; col < gridCols; col++) {
            grid[row][col] = { char: LOOM.CHAR_OUTSIDE, particle: null, particleAlpha: 0 };
          }
        }
        return grid;
      }

      function fillLoomShapeIntoGrid(grid) {
        const THREAD_MARKER = "\x00";

        for (let row = 0; row < gridRows; row++) {
          const normY = (row / gridRows) * 2 - 1;
          const isBottom = normY > 0;
          const timeClock = isBottom ? botTimeClock : topTimeClock;
          const envelope = Math.pow(Math.abs(normY), LOOM.ENVELOPE_POWER);
          const sway = computeRowSway(normY, isBottom, timeClock) * Math.abs(normY);
          const leftEdge = -envelope + sway;
          const rightEdge = envelope + sway;

          for (let col = 0; col < gridCols; col++) {
            const normX = (col / gridCols) * 2 - 1;
            grid[row][col].char = normX < leftEdge || normX > rightEdge ? LOOM.CHAR_OUTSIDE : LOOM.CHAR_INSIDE_EMPTY;
          }

          for (let threadIdx = 0; threadIdx < LOOM.THREAD_COUNT; threadIdx++) {
            const wave = computeThreadWave(threadIdx, normY, isBottom, timeClock);
            const threadCol = Math.floor(((wave * envelope + sway + 1) / 2) * gridCols);
            if (threadCol >= 0 && threadCol < gridCols) {
              const normX = (threadCol / gridCols) * 2 - 1;
              if (normX >= leftEdge && normX <= rightEdge) {
                grid[row][threadCol].char = THREAD_MARKER;
              }
            }
          }

          if (!isBottom) {
            for (let col = 0; col < gridCols; col++) {
              if (grid[row][col].char === THREAD_MARKER) {
                grid[row][col].char = topThreadCursor.next();
              }
            }
          } else {
            for (let col = 0; col < gridCols; col++) {
              if (grid[row][col].char === THREAD_MARKER) {
                const symbolOffset1 = Math.floor(Math.sin(col * 0.7 + botTimeClock * 3.1) * 7 + 7);
                const symbolOffset2 = Math.floor(Math.cos(row * 1.3 + botTimeClock * 1.7) * 5 + 5);
                const symbolIndex = (botThreadCursor.position + symbolOffset1 + symbolOffset2) % LOOM.BOT_THREAD_SYMBOLS.length;
                grid[row][col].char = LOOM.BOT_THREAD_SYMBOLS[symbolIndex];
                botThreadCursor.advance(1);
              }
            }
          }
        }
      }

      // PARTICLES

      function spawnBurstParticles() {
        const originCol = gridCols / 2;
        const originRow = gridRows / 2;
        const aspectCorrection = charCellHeight / charCellWidth;

        for (let i = 0; i < PARTICLES.BURST_SIZE; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = PARTICLES.SPEED_MIN + Math.random() * (PARTICLES.SPEED_MAX - PARTICLES.SPEED_MIN);
          activeParticles.push({
            char: pickBurstChar(),
            x: originCol,
            y: originRow,
            vx: Math.cos(angle) * speed * aspectCorrection,
            vy: Math.sin(angle) * speed,
            age: 0,
          });
        }
      }

      function stepParticlePhysics() {
        for (let i = activeParticles.length - 1; i >= 0; i--) {
          const p = activeParticles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.age++;
          const escaped = p.x < -2 || p.x > gridCols + 2 || p.y < -2 || p.y > gridRows + 2;
          if (p.age >= PARTICLE_FADE_FRAMES || escaped) {
            activeParticles.splice(i, 1);
          }
        }
      }

      function compositeParticlesOntoGrid(grid) {
        for (const p of activeParticles) {
          const col = Math.round(p.x);
          const row = Math.round(p.y);
          if (col < 0 || col >= gridCols || row < 0 || row >= gridRows) continue;
          const alpha = 1 - p.age / PARTICLE_FADE_FRAMES;
          const cell = grid[row][col];
          if (!cell.particle || alpha > cell.particleAlpha) {
            cell.particle = p.char;
            cell.particleAlpha = alpha;
          }
        }
      }

      // GRID → STRING SERIALISATION

      function chooseDimChar(alpha) {
        const dimIndex = Math.floor((1 - alpha / PARTICLES.DIM_ALPHA_SCALE) * 2);
        return PARTICLES.DIM_CHARS[Math.min(dimIndex, PARTICLES.DIM_CHARS.length - 1)];
      }

      function serialiseGridToString(grid) {
        let output = "";
        for (let row = 0; row < gridRows; row++) {
          for (let col = 0; col < gridCols; col++) {
            const cell = grid[row][col];
            if (cell.particle !== null) {
              if (cell.particleAlpha > PARTICLES.DIM_THRESHOLD_HI) output += cell.particle;
              else if (cell.particleAlpha > PARTICLES.DIM_THRESHOLD_LO) output += chooseDimChar(cell.particleAlpha);
              else output += ".";
            } else {
              output += cell.char;
            }
          }
          output += "\n";
        }
        return output;
      }

      // AUDIO

      function scheduleKickDrum(beatTime) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(KICK.FREQ_START, beatTime);
        osc.frequency.exponentialRampToValueAtTime(KICK.FREQ_END, beatTime + KICK.FREQ_RAMP_SECS);
        gain.gain.setValueAtTime(KICK.GAIN_PEAK, beatTime);
        gain.gain.exponentialRampToValueAtTime(0.001, beatTime + KICK.GAIN_DECAY_SECS);
        osc.connect(gain);
        gain.connect(masterGainNode);
        osc.start(beatTime);
        osc.stop(beatTime + KICK.DURATION_SECS);
      }

      function scheduleChordDuck(beatTime) {
        chordGainNode.gain.cancelScheduledValues(beatTime);
        chordGainNode.gain.setValueAtTime(1.0 - CHORD.DUCK_DEPTH, beatTime);
        chordGainNode.gain.linearRampToValueAtTime(1.0, beatTime + DUCK_RELEASE_SECS);
      }

      function runBeatScheduler() {
        const lookAheadUntil = audioCtx.currentTime + RHYTHM.SCHEDULER_LOOKAHEAD_SECS;
        while (nextBeatTime < lookAheadUntil) {
          scheduleKickDrum(nextBeatTime);
          scheduleChordDuck(nextBeatTime);
          pendingBeatTimes.push(nextBeatTime);
          nextBeatTime += BEAT_DURATION_SECS;
        }
      }

      function buildAndStartFilterLfo() {
        const freqMid = (FILTER.FREQ_HIGH + FILTER.FREQ_LOW) / 2;
        const freqRadius = (FILTER.FREQ_HIGH - FILTER.FREQ_LOW) / 2;
        const sampleRate = audioCtx.sampleRate;
        const bufferSize = Math.round(sampleRate * FILTER.OSCILLATION_PERIOD_SECS);
        const buffer = audioCtx.createBuffer(1, bufferSize, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          const phase = (i / bufferSize) * Math.PI * 2;
          data[i] = freqMid - freqRadius * Math.sin(phase);
        }

        const lfoSource = audioCtx.createBufferSource();
        lfoSource.buffer = buffer;
        lfoSource.loop = true;
        lfoSource.connect(filterNode.frequency);
        lfoSource.start(audioCtx.currentTime + MASTER.STARTUP_OFFSET_SECS);
        return lfoSource;
      }

      function startAudio() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGainNode = audioCtx.createGain();
        masterGainNode.gain.value = MASTER.GAIN;
        masterGainNode.connect(audioCtx.destination);

        chordGainNode = audioCtx.createGain();
        chordGainNode.gain.value = 1;

        CHORD.FREQUENCIES.forEach((freq) => {
          const osc = audioCtx.createOscillator();
          const voiceGain = audioCtx.createGain();
          osc.type = CHORD.OSC_TYPE;
          osc.frequency.value = freq;
          voiceGain.gain.value = CHORD.VOICE_GAIN;
          osc.connect(voiceGain);
          voiceGain.connect(chordGainNode);
          osc.start();
        });

        filterNode = audioCtx.createBiquadFilter();
        filterNode.type = FILTER.TYPE;
        filterNode.Q.value = FILTER.Q;

        chordGainNode.connect(filterNode);
        filterNode.connect(masterGainNode);

        filterLfoNode = buildAndStartFilterLfo();

        nextBeatTime = audioCtx.currentTime + MASTER.STARTUP_OFFSET_SECS;
        beatSchedulerId = setInterval(runBeatScheduler, RHYTHM.SCHEDULER_TICK_MS);
        runBeatScheduler();
      }

      // MAIN RENDER LOOP

      function triggerPendingBursts() {
        let i = 0;
        while (i < pendingBeatTimes.length) {
          if (audioCtx.currentTime >= pendingBeatTimes[i]) {
            spawnBurstParticles();
            pendingBeatTimes.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function advanceLoomClocks() {
        const topTickRate = computeModulatedTickRate(wallClock, LOOM.TOP_SPEED_BASE, LOOM.TOP_SPEED_MOD_AMP, LOOM.TOP_SPEED_MOD_FREQ, LOOM.TOP_SPEED_MOD_PHASE);
        const botTickRate = computeModulatedTickRate(wallClock, LOOM.BOT_SPEED_BASE, LOOM.BOT_SPEED_MOD_AMP, LOOM.BOT_SPEED_MOD_FREQ, LOOM.BOT_SPEED_MOD_PHASE);
        wallClock += LOOM.WALL_TICK_RATE;
        topTimeClock += topTickRate;
        botTimeClock += botTickRate;
      }

      function renderFrame() {
        if (audioCtx) triggerPendingBursts();

        stepParticlePhysics();
        advanceLoomClocks();

        const grid = buildEmptyCellGrid();
        fillLoomShapeIntoGrid(grid);
        compositeParticlesOntoGrid(grid);

        display.textContent = serialiseGridToString(grid);
        requestAnimationFrame(renderFrame);
      }

      // BOOTSTRAP

      document.getElementById("start-btn").addEventListener("click", () => {
        document.getElementById("start-btn").remove();
        startAudio();
      });

      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(recalcGridDimensions, 100);
      });

      recalcGridDimensions();
      replaceTopThreadCursorWhenReady(fetchTopThreadSourceText());
      requestAnimationFrame(renderFrame);
    </script>
  </body>
</html>
