<!DOCTYPE html>
<html>
  <head>
    <style>
      body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
      #controls {
          position: absolute;
          top: 20px;
          left: 20px;
          background: rgba(0,0,0,0.7);
          padding: 20px;
          border-radius: 10px;
          color: white;
      }
      .slider-container {
          margin: 10px 0;
      }
      label {
          display: inline-block;
          width: 120px;
      }
      .value {
          display: inline-block;
          width: 80px;
          text-align: right;
      }
      #info {
          position: absolute;
          bottom: 20px;
          left: 20px;
          background: rgba(0,0,0,0.7);
          padding: 15px;
          border-radius: 10px;
          color: white;
          font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <h3>Face Normal Angles</h3>
      <div class="slider-container">
        <label>Total Angle:</label>
        <span class="value" id="angle-total">0.0°</span>
      </div>
      <div class="slider-container">
        <label>Rx (Pitch):</label>
        <span class="value" id="angle-x">0.0°</span>
      </div>
      <div class="slider-container">
        <label>Ry (Yaw):</label>
        <span class="value" id="angle-y">0.0°</span>
      </div>
      <div class="slider-container">
        <label>Rz (Roll):</label>
        <span class="value" id="angle-z">0.0°</span>
      </div>
    </div>

    <div id="info">
      <p>Left Mouse: Rotate | Scroll: Zoom</p>
      <p>Green face is closest to ground normal (blue arrow)</p>
      <p>Red arrow shows original top face normal</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xcccccc);
      document.body.appendChild(renderer.domElement);

      // Create icosahedron geometry
      const geometry = new THREE.IcosahedronGeometry(1);

      // Calculate face normals for each triangle
      const positions = geometry.attributes.position.array;
      const faceNormals = [];
      const faceCount = positions.length / 9;

      for (let i = 0; i < faceCount; i++) {
        const i9 = i * 9;
        const v1 = new THREE.Vector3(positions[i9], positions[i9 + 1], positions[i9 + 2]);
        const v2 = new THREE.Vector3(positions[i9 + 3], positions[i9 + 4], positions[i9 + 5]);
        const v3 = new THREE.Vector3(positions[i9 + 6], positions[i9 + 7], positions[i9 + 8]);

        const edge1 = new THREE.Vector3().subVectors(v2, v1);
        const edge2 = new THREE.Vector3().subVectors(v3, v1);
        const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

        faceNormals.push(normal);
      }

      // Find the face with normal closest to (0,1,0) in initial position
      let topFaceIndex = 0;
      let maxDot = -2;
      const upVector = new THREE.Vector3(0, 1, 0);

      for (let i = 0; i < faceCount; i++) {
        const dot = faceNormals[i].dot(upVector);
        if (dot > maxDot) {
          maxDot = dot;
          topFaceIndex = i;
        }
      }

      // Store the original top face normal
      const originalTopNormal = faceNormals[topFaceIndex].clone();

      // Create color array for each vertex
      const colors = new Float32Array(positions.length);
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      // Create mesh with vertex colors and transparency
      const material = new THREE.MeshStandardMaterial({
        vertexColors: true,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.7,
        metalness: 0.1,
        roughness: 0.6,
        depthWrite: false,
      });
      const icosahedron = new THREE.Mesh(geometry, material);
      scene.add(icosahedron);

      // Create wireframe
      const wireframeGeometry = new THREE.IcosahedronGeometry(1);
      const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000,
        wireframe: true,
        linewidth: 2,
      });
      const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
      scene.add(wireframe);

      // Add lighting
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      scene.add(ambientLight);

      // Create blue ground normal arrow (fixed, pointing up)
      const arrowLength = 1.5;
      const blueArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), arrowLength, 0x0000ff, 0.3, 0.2);
      scene.add(blueArrow);

      // Create red arrow (shows original top face normal, rotates with solid)
      const redArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), arrowLength, 0xff0000, 0.3, 0.2);
      scene.add(redArrow);

      camera.position.z = 3;

      // Trackball-style rotation using quaternions
      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };

      // Use quaternion for smooth rotation
      const rotationQuaternion = new THREE.Quaternion();

      document.addEventListener("mousedown", (e) => {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;

          const rotationSpeed = 0.005;

          // Create rotation quaternions for each axis
          // Rotate around camera's up axis (Y) for horizontal mouse movement
          const deltaRotationQuaternionY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * rotationSpeed);

          // Rotate around camera's right axis (X) for vertical mouse movement
          const deltaRotationQuaternionX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaY * rotationSpeed);

          // Combine rotations: apply Y rotation first, then X rotation
          rotationQuaternion.multiplyQuaternions(deltaRotationQuaternionY, rotationQuaternion);
          rotationQuaternion.multiplyQuaternions(deltaRotationQuaternionX, rotationQuaternion);
          rotationQuaternion.normalize();

          // Apply quaternion to both meshes
          icosahedron.quaternion.copy(rotationQuaternion);
          wireframe.quaternion.copy(rotationQuaternion);

          previousMousePosition = { x: e.clientX, y: e.clientY };

          updateDisplay();
        }
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      // Zoom with mouse wheel
      document.addEventListener("wheel", (e) => {
        e.preventDefault();
        camera.position.z += e.deltaY * 0.01;
        camera.position.z = Math.max(1.5, Math.min(10, camera.position.z));
      });

      // Function to decompose rotation into Euler angles relative to a reference vector
      function getEulerAnglesFromVectors(currentVec, referenceVec) {
        // Normalize vectors
        const current = currentVec.clone().normalize();
        const reference = referenceVec.clone().normalize();

        // Calculate the rotation quaternion from reference to current
        const quaternion = new THREE.Quaternion().setFromUnitVectors(reference, current);

        // Convert to Euler angles (XYZ order)
        const euler = new THREE.Euler().setFromQuaternion(quaternion, "XYZ");

        return {
          x: (euler.x * 180) / Math.PI,
          y: (euler.y * 180) / Math.PI,
          z: (euler.z * 180) / Math.PI,
        };
      }

      function updateDisplay() {
        // Ground normal (always pointing up)
        const groundNormal = new THREE.Vector3(0, 1, 0);

        // Get current orientation of the original top face normal
        const currentTopNormal = originalTopNormal.clone();
        currentTopNormal.applyQuaternion(rotationQuaternion);
        currentTopNormal.normalize();

        // Update red arrow to show current orientation of original top face
        redArrow.setDirection(currentTopNormal);

        // Calculate total angle between red vector and blue vector
        const dotProduct = currentTopNormal.dot(groundNormal);
        const totalAngleRad = Math.acos(Math.max(-1, Math.min(1, dotProduct)));
        const totalAngleDeg = (totalAngleRad * 180) / Math.PI;

        // Calculate Euler angles (Rx, Ry, Rz)
        const eulerAngles = getEulerAnglesFromVectors(currentTopNormal, groundNormal);

        // Update display
        document.getElementById("angle-total").textContent = totalAngleDeg.toFixed(1) + "°";
        document.getElementById("angle-x").textContent = eulerAngles.x.toFixed(1) + "°";
        document.getElementById("angle-y").textContent = eulerAngles.y.toFixed(1) + "°";
        document.getElementById("angle-z").textContent = eulerAngles.z.toFixed(1) + "°";

        // Find the face with normal closest to ground normal
        let closestFaceIndex = 0;
        let maxDotProduct = -2;

        for (let i = 0; i < faceCount; i++) {
          const faceNormal = faceNormals[i].clone();
          faceNormal.applyQuaternion(rotationQuaternion);
          faceNormal.normalize();

          const dot = faceNormal.dot(groundNormal);

          if (dot > maxDotProduct) {
            maxDotProduct = dot;
            closestFaceIndex = i;
          }
        }

        // Update colors - highlight closest face in green
        const colorAttr = geometry.attributes.color;
        for (let i = 0; i < faceCount; i++) {
          const i9 = i * 9;
          let r, g, b;

          if (i === closestFaceIndex) {
            r = 0;
            g = 1;
            b = 0;
          } else {
            r = 0.7;
            g = 0.7;
            b = 0.7;
          }

          for (let j = 0; j < 9; j += 3) {
            colorAttr.array[i9 + j] = r;
            colorAttr.array[i9 + j + 1] = g;
            colorAttr.array[i9 + j + 2] = b;
          }
        }

        colorAttr.needsUpdate = true;
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }

      // Initial display
      updateDisplay();
      animate();

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
