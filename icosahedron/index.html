<!DOCTYPE html>
<html>
  <head>
    <style>
      body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
      #controls {
          position: absolute;
          top: 20px;
          left: 20px;
          background: rgba(0,0,0,0.7);
          padding: 20px;
          border-radius: 10px;
          color: white;
          max-height: 90vh;
          overflow-y: auto;
      }
      .slider-container {
          margin: 10px 0;
      }
      label {
          display: inline-block;
          width: 120px;
      }
      .value {
          display: inline-block;
          width: 80px;
          text-align: right;
      }
      input[type="range"] {
          width: 200px;
          vertical-align: middle;
      }
      #face-number {
          font-size: 48px;
          font-weight: bold;
          color: #00ff00;
          margin-top: 15px;
          text-align: center;
      }
      #info {
          position: absolute;
          bottom: 20px;
          left: 20px;
          background: rgba(0,0,0,0.7);
          padding: 15px;
          border-radius: 10px;
          color: white;
          font-size: 14px;
      }
      h3 {
          margin-top: 0;
          margin-bottom: 15px;
          border-bottom: 2px solid #00ff00;
          padding-bottom: 5px;
      }
      .section {
          margin-bottom: 20px;
      }
      button {
          background: #00ff00;
          color: black;
          border: none;
          padding: 8px 16px;
          border-radius: 5px;
          cursor: pointer;
          font-weight: bold;
          margin-top: 10px;
      }
      button:hover {
          background: #00cc00;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <div class="section">
        <h3>Ground Calibration</h3>
        <div class="slider-container">
          <label>Azimuth (0-360°):</label>
          <input type="range" id="ground-azimuth" min="0" max="360" value="0" step="1" />
          <span class="value" id="ground-azimuth-val">0°</span>
        </div>
        <div class="slider-container">
          <label>Elevation (-90 to 90°):</label>
          <input type="range" id="ground-elevation" min="-90" max="90" value="90" step="1" />
          <span class="value" id="ground-elevation-val">90°</span>
        </div>
        <div class="slider-container">
          <label>Normal Vector:</label>
          <span class="value" id="ground-normal-display">X: 0.00 Y: 1.00 Z: 0.00</span>
        </div>
        <button id="reset-ground">Reset Ground</button>
      </div>

      <div class="section">
        <h3>Face Normal Angles</h3>
        <div class="slider-container">
          <label>Total Angle:</label>
          <span class="value" id="angle-total">0.0°</span>
        </div>
        <div class="slider-container">
          <label>Rx (Pitch):</label>
          <span class="value" id="angle-x">0.0°</span>
        </div>
        <div class="slider-container">
          <label>Ry (Yaw):</label>
          <span class="value" id="angle-y">0.0°</span>
        </div>
        <div class="slider-container">
          <label>Rz (Roll):</label>
          <span class="value" id="angle-z">0.0°</span>
        </div>
        <div id="face-number">Face: 1</div>
      </div>
    </div>

    <div id="info">
      <p>Left Mouse: Rotate | Scroll: Zoom</p>
      <p>Green face is closest to ground normal (blue arrow)</p>
      <p>Red arrow shows original top face normal</p>
      <p>Adjust ground sliders to calibrate (360° coverage)</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xcccccc);
      document.body.appendChild(renderer.domElement);

      // Create icosahedron geometry
      const geometry = new THREE.IcosahedronGeometry(1);

      // Calculate face normals for each triangle
      const positions = geometry.attributes.position.array;
      const faceNormals = [];
      const faceCount = positions.length / 9;

      for (let i = 0; i < faceCount; i++) {
        const i9 = i * 9;
        const v1 = new THREE.Vector3(positions[i9], positions[i9 + 1], positions[i9 + 2]);
        const v2 = new THREE.Vector3(positions[i9 + 3], positions[i9 + 4], positions[i9 + 5]);
        const v3 = new THREE.Vector3(positions[i9 + 6], positions[i9 + 7], positions[i9 + 8]);

        const edge1 = new THREE.Vector3().subVectors(v2, v1);
        const edge2 = new THREE.Vector3().subVectors(v3, v1);
        const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

        faceNormals.push(normal);
      }

      // Find the face with normal closest to (0,1,0) in initial position
      let topFaceIndex = 0;
      let maxDot = -2;
      const upVector = new THREE.Vector3(0, 1, 0);

      for (let i = 0; i < faceCount; i++) {
        const dot = faceNormals[i].dot(upVector);
        if (dot > maxDot) {
          maxDot = dot;
          topFaceIndex = i;
        }
      }

      // Store the original top face normal
      const originalTopNormal = faceNormals[topFaceIndex].clone();

      // Create color array for each vertex
      const colors = new Float32Array(positions.length);
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      // Create mesh with vertex colors and transparency
      const material = new THREE.MeshStandardMaterial({
        vertexColors: true,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.7,
        metalness: 0.1,
        roughness: 0.6,
        depthWrite: false,
      });
      const icosahedron = new THREE.Mesh(geometry, material);
      scene.add(icosahedron);

      // Create wireframe
      const wireframeGeometry = new THREE.IcosahedronGeometry(1);
      const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000,
        wireframe: true,
        linewidth: 2,
      });
      const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
      scene.add(wireframe);

      // Create a group to hold all text meshes
      const textGroup = new THREE.Group();
      scene.add(textGroup);

      // Function to create text canvas texture
      function createTextTexture(text) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = 256;
        canvas.height = 256;

        // Clear canvas
        context.clearRect(0, 0, canvas.width, canvas.height);

        // Draw text
        context.fillStyle = "rgba(0, 0, 0, 0.9)";
        context.font = "Bold 120px Arial";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText(text, 128, 128);

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
      }

      // Function to create a plane with text on a face
      function createTextPlane(text, v1, v2, v3, normal) {
        // Calculate center of triangle
        const center = new THREE.Vector3().add(v1).add(v2).add(v3).divideScalar(3);

        // Create a small plane
        const planeGeometry = new THREE.PlaneGeometry(0.4, 0.4);
        const texture = createTextTexture(text);
        const planeMaterial = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide,
          depthTest: true,
          depthWrite: false,
        });

        const plane = new THREE.Mesh(planeGeometry, planeMaterial);

        // Position the plane at the face center, slightly above the surface
        plane.position.copy(center);
        plane.position.add(normal.clone().multiplyScalar(0.02));

        // Orient the plane to face outward along the normal
        plane.lookAt(center.clone().add(normal));

        return plane;
      }

      // Create text planes for each face
      const textPlanes = [];
      for (let i = 0; i < faceCount; i++) {
        const i9 = i * 9;
        const v1 = new THREE.Vector3(positions[i9], positions[i9 + 1], positions[i9 + 2]);
        const v2 = new THREE.Vector3(positions[i9 + 3], positions[i9 + 4], positions[i9 + 5]);
        const v3 = new THREE.Vector3(positions[i9 + 6], positions[i9 + 7], positions[i9 + 8]);

        const textPlane = createTextPlane((i + 1).toString(), v1, v2, v3, faceNormals[i]);
        textGroup.add(textPlane);
        textPlanes.push(textPlane);
      }

      // Add lighting
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      scene.add(ambientLight);

      // Ground normal vector (adjustable)
      let groundNormal = new THREE.Vector3(0, 1, 0);

      // Create blue ground normal arrow (adjustable)
      const arrowLength = 1.5;
      const blueArrow = new THREE.ArrowHelper(groundNormal.clone().normalize(), new THREE.Vector3(0, 0, 0), arrowLength, 0x0000ff, 0.3, 0.2);
      scene.add(blueArrow);

      // Create red arrow (shows original top face normal, rotates with solid)
      const redArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), arrowLength, 0xff0000, 0.3, 0.2);
      scene.add(redArrow);

      camera.position.z = 3;

      // Trackball-style rotation using quaternions
      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };

      // Use quaternion for smooth rotation
      const rotationQuaternion = new THREE.Quaternion();

      document.addEventListener("mousedown", (e) => {
        // Check if click is on controls panel
        const controlsPanel = document.getElementById("controls");
        if (controlsPanel.contains(e.target)) {
          return; // Don't start rotation if clicking on controls
        }
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;

          const rotationSpeed = 0.005;

          // Create rotation quaternions for each axis
          const deltaRotationQuaternionY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * rotationSpeed);

          const deltaRotationQuaternionX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaY * rotationSpeed);

          // Combine rotations
          rotationQuaternion.multiplyQuaternions(deltaRotationQuaternionY, rotationQuaternion);
          rotationQuaternion.multiplyQuaternions(deltaRotationQuaternionX, rotationQuaternion);
          rotationQuaternion.normalize();

          // Apply quaternion to meshes and text group
          icosahedron.quaternion.copy(rotationQuaternion);
          wireframe.quaternion.copy(rotationQuaternion);
          textGroup.quaternion.copy(rotationQuaternion);

          previousMousePosition = { x: e.clientX, y: e.clientY };

          updateDisplay();
        }
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      // Zoom with mouse wheel
      document.addEventListener("wheel", (e) => {
        // Check if wheel is over controls
        const controlsPanel = document.getElementById("controls");
        if (controlsPanel.contains(e.target)) {
          return; // Allow normal scrolling in controls
        }
        e.preventDefault();
        camera.position.z += e.deltaY * 0.01;
        camera.position.z = Math.max(1.5, Math.min(10, camera.position.z));
      });

      // Ground vector sliders using spherical coordinates
      const groundAzimuthSlider = document.getElementById("ground-azimuth");
      const groundElevationSlider = document.getElementById("ground-elevation");
      const groundAzimuthVal = document.getElementById("ground-azimuth-val");
      const groundElevationVal = document.getElementById("ground-elevation-val");
      const groundNormalDisplay = document.getElementById("ground-normal-display");

      function updateGroundVector() {
        const azimuth = (parseFloat(groundAzimuthSlider.value) * Math.PI) / 180;
        const elevation = (parseFloat(groundElevationSlider.value) * Math.PI) / 180;

        // Convert spherical coordinates to Cartesian
        // azimuth: 0° = +X, 90° = +Z, 180° = -X, 270° = -Z
        // elevation: 90° = +Y (up), 0° = horizontal, -90° = -Y (down)
        const cosElev = Math.cos(elevation);

        groundNormal.set(Math.cos(azimuth) * cosElev, Math.sin(elevation), Math.sin(azimuth) * cosElev);

        groundNormal.normalize();

        // Update display values
        groundAzimuthVal.textContent = groundAzimuthSlider.value + "°";
        groundElevationVal.textContent = groundElevationSlider.value + "°";
        groundNormalDisplay.textContent = `X: ${groundNormal.x.toFixed(2)} Y: ${groundNormal.y.toFixed(2)} Z: ${groundNormal.z.toFixed(2)}`;

        // Update blue arrow
        blueArrow.setDirection(groundNormal);

        updateDisplay();
      }

      // Prevent event propagation for sliders
      groundAzimuthSlider.addEventListener("mousedown", (e) => {
        e.stopPropagation();
      });
      groundElevationSlider.addEventListener("mousedown", (e) => {
        e.stopPropagation();
      });

      groundAzimuthSlider.addEventListener("input", updateGroundVector);
      groundElevationSlider.addEventListener("input", updateGroundVector);

      // Reset ground button
      document.getElementById("reset-ground").addEventListener("click", (e) => {
        e.stopPropagation();
        groundAzimuthSlider.value = 0;
        groundElevationSlider.value = 90;
        updateGroundVector();
      });

      // Function to decompose rotation into Euler angles relative to a reference vector
      function getEulerAnglesFromVectors(currentVec, referenceVec) {
        const current = currentVec.clone().normalize();
        const reference = referenceVec.clone().normalize();

        const quaternion = new THREE.Quaternion().setFromUnitVectors(reference, current);
        const euler = new THREE.Euler().setFromQuaternion(quaternion, "XYZ");

        return {
          x: (euler.x * 180) / Math.PI,
          y: (euler.y * 180) / Math.PI,
          z: (euler.z * 180) / Math.PI,
        };
      }

      function updateDisplay() {
        // Get current orientation of the original top face normal
        const currentTopNormal = originalTopNormal.clone();
        currentTopNormal.applyQuaternion(rotationQuaternion);
        currentTopNormal.normalize();

        // Update red arrow to show current orientation of original top face
        redArrow.setDirection(currentTopNormal);

        // Calculate total angle between red vector and blue vector (ground normal)
        const dotProduct = currentTopNormal.dot(groundNormal);
        const totalAngleRad = Math.acos(Math.max(-1, Math.min(1, dotProduct)));
        const totalAngleDeg = (totalAngleRad * 180) / Math.PI;

        // Calculate Euler angles (Rx, Ry, Rz)
        const eulerAngles = getEulerAnglesFromVectors(currentTopNormal, groundNormal);

        // Update display
        document.getElementById("angle-total").textContent = totalAngleDeg.toFixed(1) + "°";
        document.getElementById("angle-x").textContent = eulerAngles.x.toFixed(1) + "°";
        document.getElementById("angle-y").textContent = eulerAngles.y.toFixed(1) + "°";
        document.getElementById("angle-z").textContent = eulerAngles.z.toFixed(1) + "°";

        // Find the face with normal closest to ground normal
        let closestFaceIndex = 0;
        let maxDotProduct = -2;

        for (let i = 0; i < faceCount; i++) {
          const faceNormal = faceNormals[i].clone();
          faceNormal.applyQuaternion(rotationQuaternion);
          faceNormal.normalize();

          const dot = faceNormal.dot(groundNormal);

          if (dot > maxDotProduct) {
            maxDotProduct = dot;
            closestFaceIndex = i;
          }
        }

        // Update face number display
        document.getElementById("face-number").textContent = "Face: " + (closestFaceIndex + 1);

        // Update colors - highlight closest face in green
        const colorAttr = geometry.attributes.color;
        for (let i = 0; i < faceCount; i++) {
          const i9 = i * 9;
          let r, g, b;

          if (i === closestFaceIndex) {
            r = 0;
            g = 1;
            b = 0;
          } else {
            r = 0.7;
            g = 0.7;
            b = 0.7;
          }

          for (let j = 0; j < 9; j += 3) {
            colorAttr.array[i9 + j] = r;
            colorAttr.array[i9 + j + 1] = g;
            colorAttr.array[i9 + j + 2] = b;
          }
        }

        colorAttr.needsUpdate = true;
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }

      // Initial display
      updateGroundVector();
      animate();

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
