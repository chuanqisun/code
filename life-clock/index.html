<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Life in Seconds</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Courier New', monospace;
        background: #000;
        color: #0f0;
        overflow: hidden;
      }

      #canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }

      #ui {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #0f0;
        padding: 15px;
        font-size: 12px;
        z-index: 10;
      }

      #ui input {
        background: #000;
        border: 1px solid #0f0;
        color: #0f0;
        padding: 5px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        margin: 5px 0;
        width: 200px;
      }

      #ui button {
        background: #000;
        border: 1px solid #0f0;
        color: #0f0;
        padding: 5px 10px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        cursor: pointer;
        margin: 5px 5px 5px 0;
      }

      #ui button:hover {
        background: #0f0;
        color: #000;
      }

      .info {
        margin-top: 10px;
        line-height: 1.5;
      }

      .label {
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="ui">
      <div>LIFE VISUALIZER</div>
      <div class="label">Birthday (YYYY-MM-DD):</div>
      <input type="date" id="birthday" value="2000-01-01" />
      <div style="margin-top: 10px;">
        <button id="flyTo">FLY TO CURRENT</button>
      </div>
      <div class="info">
        <div class="label">Zoom: <span id="zoomLevel">1.00x</span></div>
        <div class="label">Each pixel: <span id="pixelTime">1 second</span></div>
        <div class="label">Elapsed: <span id="elapsed">-</span></div>
        <div class="label">Remaining: <span id="remaining">-</span></div>
        <div class="label">Total: <span id="total">100 years</span></div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const gl = canvas.getContext("webgl2");

      if (!gl) {
        alert("WebGL2 not supported");
      }

      // Constants
      const LIFESPAN_YEARS = 100;
      const TOTAL_SECONDS = LIFESPAN_YEARS * 365.25 * 24 * 60 * 60;
      const PIXEL_SIZE = 8; // Constant pixel size in screen pixels
      const PIXEL_GAP = 1;
      const PIXEL_STRIDE = PIXEL_SIZE + PIXEL_GAP;

      const SECONDS_PER_MINUTE = 60;
      const SECONDS_PER_HOUR = 3600;
      const SECONDS_PER_DAY = 86400;
      const SECONDS_PER_WEEK = 604800;
      const SECONDS_PER_MONTH = 2628000; // 30.4 days average
      const SECONDS_PER_YEAR = 31557600; // 365.25 days

      // Zoom levels - each level represents a different time unit per pixel
      const ZOOM_LEVELS = [
        { level: 0, secondsPerPixel: SECONDS_PER_YEAR, label: "1 year" },
        { level: 1, secondsPerPixel: SECONDS_PER_MONTH, label: "1 month" },
        { level: 2, secondsPerPixel: SECONDS_PER_WEEK, label: "1 week" },
        { level: 3, secondsPerPixel: SECONDS_PER_DAY, label: "1 day" },
        { level: 4, secondsPerPixel: SECONDS_PER_HOUR, label: "1 hour" },
        { level: 5, secondsPerPixel: SECONDS_PER_MINUTE, label: "1 minute" },
        { level: 6, secondsPerPixel: 10, label: "10 seconds" },
        { level: 7, secondsPerPixel: 5, label: "5 seconds" },
        { level: 8, secondsPerPixel: 1, label: "1 second" },
      ];

      const MIN_ZOOM_LEVEL = 0;
      const MAX_ZOOM_LEVEL = ZOOM_LEVELS.length - 1;

      // State
      let camera = {
        x: 0, // World coordinates
        y: 0,
        zoomLevel: 3, // Start at day level
      };

      let birthday = "2000-01-01";
      let currentSecond = 0;

      // WebGL setup
      const vertexShaderSource = `#version 300 es
in vec2 a_position;
in float a_lit;

uniform vec2 u_resolution;
uniform vec2 u_camera;

out float v_lit;

void main() {
  // Apply camera transform (pan only, no zoom scaling)
  vec2 pos = a_position - u_camera;
  
  // Convert to clip space
  vec2 clipSpace = (pos / u_resolution) * 2.0 - 1.0;
  clipSpace.y *= -1.0;
  
  gl_Position = vec4(clipSpace, 0.0, 1.0);
  gl_PointSize = ${PIXEL_SIZE}.0;
  v_lit = a_lit;
}
`;

      const fragmentShaderSource = `#version 300 es
precision mediump float;

in float v_lit;
out vec4 outColor;

void main() {
  if (v_lit > 0.5) {
    outColor = vec4(0.0, 1.0, 0.0, 1.0); // Green for remaining
  } else {
    outColor = vec4(0.1, 0.1, 0.1, 1.0); // Dark for elapsed
  }
}
`;

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
      }

      gl.useProgram(program);

      // Get locations
      const a_position = gl.getAttribLocation(program, "a_position");
      const a_lit = gl.getAttribLocation(program, "a_lit");
      const u_resolution = gl.getUniformLocation(program, "u_resolution");
      const u_camera = gl.getUniformLocation(program, "u_camera");

      // Create buffers
      const positionBuffer = gl.createBuffer();
      const litBuffer = gl.createBuffer();

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      function getSecondsFromBirthday(birthday) {
        if (!birthday) return 0;
        const now = new Date();
        const birth = new Date(birthday);
        return Math.floor((now - birth) / 1000);
      }

      function formatTime(seconds) {
        const years = Math.floor(seconds / (365.25 * 24 * 60 * 60));
        const days = Math.floor((seconds % (365.25 * 24 * 60 * 60)) / (24 * 60 * 60));
        const hours = Math.floor((seconds % (24 * 60 * 60)) / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        if (years > 0) return `${years}y ${days}d`;
        if (days > 0) return `${days}d ${hours}h`;
        if (hours > 0) return `${hours}h ${minutes}m`;
        if (minutes > 0) return `${minutes}m ${secs}s`;
        return `${secs}s`;
      }

      function getSecondsPerPixel(zoomLevel) {
        return ZOOM_LEVELS[zoomLevel].secondsPerPixel;
      }

      function getPixelTimeLabel(zoomLevel) {
        return ZOOM_LEVELS[zoomLevel].label;
      }

      function render() {
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        const secondsPerPixel = getSecondsPerPixel(camera.zoomLevel);

        // Calculate how many "logical pixels" we need to show the full lifespan
        const totalLogicalPixels = Math.ceil(TOTAL_SECONDS / secondsPerPixel);
        const logicalGridWidth = Math.ceil(Math.sqrt(totalLogicalPixels));
        const logicalGridHeight = Math.ceil(totalLogicalPixels / logicalGridWidth);

        // Calculate visible range in screen space
        const visibleLeft = camera.x;
        const visibleRight = camera.x + canvas.width;
        const visibleTop = camera.y;
        const visibleBottom = camera.y + canvas.height;

        // Convert to grid coordinates with padding
        const gridLeft = Math.max(0, Math.floor(visibleLeft / PIXEL_STRIDE) - 1);
        const gridRight = Math.min(logicalGridWidth - 1, Math.ceil(visibleRight / PIXEL_STRIDE) + 1);
        const gridTop = Math.max(0, Math.floor(visibleTop / PIXEL_STRIDE) - 1);
        const gridBottom = Math.min(logicalGridHeight - 1, Math.ceil(visibleBottom / PIXEL_STRIDE) + 1);

        const positions = [];
        const litValues = [];

        for (let y = gridTop; y <= gridBottom; y++) {
          for (let x = gridLeft; x <= gridRight; x++) {
            const logicalIndex = y * logicalGridWidth + x;
            const startSecond = logicalIndex * secondsPerPixel;
            const endSecond = startSecond + secondsPerPixel;

            if (startSecond >= TOTAL_SECONDS) continue;

            const px = x * PIXEL_STRIDE + PIXEL_SIZE / 2;
            const py = y * PIXEL_STRIDE + PIXEL_SIZE / 2;

            positions.push(px, py);

            // Determine if this pixel is lit (future) or dark (past)
            // If any part of the time range is in the future, show it as lit
            const isLit = endSecond > currentSecond ? 1.0 : 0.0;
            litValues.push(isLit);
          }
        }

        if (positions.length === 0) return;

        // Upload data
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(a_position);
        gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, litBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(litValues), gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(a_lit);
        gl.vertexAttribPointer(a_lit, 1, gl.FLOAT, false, 0, 0);

        // Set uniforms
        gl.uniform2f(u_resolution, canvas.width, canvas.height);
        gl.uniform2f(u_camera, camera.x, camera.y);

        // Draw
        gl.drawArrays(gl.POINTS, 0, positions.length / 2);

        // Update UI
        const zoomPercent = (((camera.zoomLevel - MIN_ZOOM_LEVEL) / (MAX_ZOOM_LEVEL - MIN_ZOOM_LEVEL)) * 100).toFixed(0);
        document.getElementById("zoomLevel").textContent = `${zoomPercent}% (${camera.zoomLevel + 1}/${MAX_ZOOM_LEVEL + 1})`;
        document.getElementById("pixelTime").textContent = getPixelTimeLabel(camera.zoomLevel);

        if (birthday) {
          document.getElementById("elapsed").textContent = formatTime(currentSecond);
          document.getElementById("remaining").textContent = formatTime(TOTAL_SECONDS - currentSecond);
        }
      }

      // Pan and zoom
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;

      canvas.addEventListener("pointerdown", (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.setPointerCapture(e.pointerId);
      });

      canvas.addEventListener("pointermove", (e) => {
        if (!isDragging) return;

        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;

        camera.x -= dx;
        camera.y -= dy;

        lastX = e.clientX;
        lastY = e.clientY;

        render();
      });

      canvas.addEventListener("pointerup", (e) => {
        isDragging = false;
        canvas.releasePointerCapture(e.pointerId);
      });

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();

        const zoomDelta = e.deltaY > 0 ? -1 : 1;
        const newZoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, camera.zoomLevel + zoomDelta));

        if (newZoomLevel === camera.zoomLevel) return;

        // Keep the center point stable during zoom
        const centerX = camera.x + canvas.width / 2;
        const centerY = camera.y + canvas.height / 2;

        // Calculate what logical position we're looking at
        const oldSecondsPerPixel = getSecondsPerPixel(camera.zoomLevel);
        const newSecondsPerPixel = getSecondsPerPixel(newZoomLevel);

        // Find the second we're centered on
        const oldLogicalGridWidth = Math.ceil(Math.sqrt(Math.ceil(TOTAL_SECONDS / oldSecondsPerPixel)));
        const oldGridX = centerX / PIXEL_STRIDE;
        const oldGridY = centerY / PIXEL_STRIDE;
        const oldLogicalIndex = Math.floor(oldGridY) * oldLogicalGridWidth + Math.floor(oldGridX);
        const centerSecond = oldLogicalIndex * oldSecondsPerPixel;

        // Find where that second should be in the new zoom level
        const newLogicalIndex = Math.floor(centerSecond / newSecondsPerPixel);
        const newLogicalGridWidth = Math.ceil(Math.sqrt(Math.ceil(TOTAL_SECONDS / newSecondsPerPixel)));
        const newGridX = newLogicalIndex % newLogicalGridWidth;
        const newGridY = Math.floor(newLogicalIndex / newLogicalGridWidth);

        // Update camera to keep that point centered
        camera.x = newGridX * PIXEL_STRIDE - canvas.width / 2;
        camera.y = newGridY * PIXEL_STRIDE - canvas.height / 2;
        camera.zoomLevel = newZoomLevel;

        render();
      });

      // Birthday input
      document.getElementById("birthday").addEventListener("change", (e) => {
        birthday = e.target.value;
        if (birthday) {
          currentSecond = getSecondsFromBirthday(birthday);
          render();
        }
      });

      // Fly to current pixel
      document.getElementById("flyTo").addEventListener("click", () => {
        if (!birthday) {
          alert("Please enter your birthday first");
          return;
        }

        // Keep current zoom level, just pan to the current second
        const secondsPerPixel = getSecondsPerPixel(camera.zoomLevel);
        const totalLogicalPixels = Math.ceil(TOTAL_SECONDS / secondsPerPixel);
        const logicalGridWidth = Math.ceil(Math.sqrt(totalLogicalPixels));

        const logicalIndex = Math.floor(currentSecond / secondsPerPixel);
        const x = logicalIndex % logicalGridWidth;
        const y = Math.floor(logicalIndex / logicalGridWidth);

        camera.x = x * PIXEL_STRIDE - canvas.width / 2;
        camera.y = y * PIXEL_STRIDE - canvas.height / 2;

        render();
      });

      // Animation loop
      function animate() {
        if (birthday) {
          const newSecond = getSecondsFromBirthday(birthday);
          if (newSecond !== currentSecond) {
            currentSecond = newSecond;
            render();
          }
        }
        requestAnimationFrame(animate);
      }

      // Initialize
      resizeCanvas();
      window.addEventListener("resize", () => {
        resizeCanvas();
        render();
      });

      // Initialize with default birthday
      currentSecond = getSecondsFromBirthday(birthday);

      // Center view initially at day level
      const secondsPerPixel = getSecondsPerPixel(camera.zoomLevel);
      const totalLogicalPixels = Math.ceil(TOTAL_SECONDS / secondsPerPixel);
      const logicalGridWidth = Math.ceil(Math.sqrt(totalLogicalPixels));
      const logicalGridHeight = Math.ceil(totalLogicalPixels / logicalGridWidth);

      camera.x = (logicalGridWidth * PIXEL_STRIDE) / 2 - canvas.width / 2;
      camera.y = (logicalGridHeight * PIXEL_STRIDE) / 2 - canvas.height / 2;

      render();
      animate();
    </script>
  </body>
</html>
