<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>CSV Visualizer</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        margin: 16px;
      }
      header {
        margin-bottom: 12px;
      }
      .controls {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
        margin-bottom: 16px;
      }
      .chart-type label {
        margin-right: 8px;
      }
      .hint {
        color: #555;
        font-size: 0.9em;
      }
      #report {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 16px;
      }
      .card {
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 12px;
        background: #fff;
      }
      .card h3 {
        margin: 0 0 8px 0;
        font-size: 1em;
      }
      .open-ended {
        grid-column: 1 / -1;
      }
      details {
        margin-bottom: 8px;
      }
      summary {
        cursor: pointer;
      }
      .footer {
        margin-top: 16px;
        color: #666;
        font-size: 0.9em;
      }
      .small {
        font-size: 0.85em;
        color: #666;
      }
      button,
      input[type="file"] {
        cursor: pointer;
      }

      /* Fixed-height container for Chart.js to avoid endless resize loops in flex/grid layouts */
      .chartbox {
        position: relative;
        height: 260px;
        width: 100%;
      }
      .card canvas {
        display: block;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  </head>
  <body>
    <header>
      <h1>CSV Visualizer</h1>
      <div class="hint">
        Upload any CSV. The app will infer column types: choice, numeric, or open-ended. It charts distributions for choice/numeric columns and lists open-ended
        responses.
      </div>
    </header>

    <div class="controls">
      <input id="fileInput" type="file" accept=".csv,text/csv" />
      <div class="chart-type small" role="radiogroup" aria-label="Chart type">
        <span>Chart type:</span>
        <label><input type="radio" name="chartType" value="bar" checked /> Bar</label>
        <label><input type="radio" name="chartType" value="pie" /> Pie</label>
      </div>
      <span id="status" class="small"></span>
    </div>

    <div id="summary" class="small"></div>
    <div id="report"></div>

    <div class="footer">
      Notes: - Choice questions are inferred as columns with relatively few unique answers. - Numerical columns are inferred when values are mostly numbers
      (e.g., rankings). - Open-ended columns are shown as text at the end.
    </div>

    <script type="module">
      // Track charts to destroy them between analyses (prevents resize observers lingering)
      let chartInstances = [];
      let chartType = "bar"; // 'bar' | 'pie'
      let lastData = null; // { rows, headers }
      let activeFilter = null; // { header, value } | null

      // Cache of column types per analysis run
      let columnTypes = new Map(); // header -> 'choice' | 'numeric' | 'open'

      function handleFile(file) {
        const statusElement = document.getElementById("status");
        const summaryElement = document.getElementById("summary");
        statusElement.textContent = "Loading...";
        summaryElement.textContent = "";
        file
          .text()
          .then((text) => {
            const parsed = parseCSV(text);
            const reportElement = document.getElementById("report");
            if (lastData) {
              // New file: destroy existing charts and clear DOM
              for (const chart of chartInstances) {
                try {
                  chart.destroy();
                } catch {}
              }
              chartInstances = [];
              reportElement.innerHTML = "";
            }
            lastData = parsed; // save for re-render on chart type change
            const { rows, headers } = parsed;
            if (!rows.length) {
              statusElement.textContent = "No data found in CSV.";
              return;
            }
            const analysisResult = analyze(rows, headers);
            statusElement.textContent = "";
            summaryElement.textContent = `Analyzed ${rows.length} rows, charted ${analysisResult.charted} columns, and grouped ${analysisResult.openCount} open-ended columns.`;
          })
          .catch((err) => {
            console.error(err);
            statusElement.textContent = "Failed to read file.";
          });
      }

      function analyze(rows, headers) {
        // No longer destroying charts to preserve scroll position
        // chartInstances are kept and updated in place

        const reportElement = document.getElementById("report");
        // Don't clear report.innerHTML to avoid DOM remounting

        const openSections = [];
        let charted = 0;

        // Detect and cache column types for this dataset
        columnTypes = new Map();
        const nonOpenHeaders = [];

        for (const header of headers) {
          const columnValuesRaw = rows.map((row) => row[header]);
          const nonEmptyValues = columnValuesRaw.filter((value) => !isBlank(value)).map(clean);
          if (nonEmptyValues.length === 0) continue;

          const type = detectColumnType(nonEmptyValues);
          columnTypes.set(header, type);

          if (type === "numeric" || type === "choice") {
            nonOpenHeaders.push(header);
            renderChartColumn(reportElement, rows, header, type);
            charted++;
          } else {
            openSections.push({ header, values: nonEmptyValues });
          }
        }

        const existingOpenCard = document.getElementById("open-ended");
        renderOpenEnded(reportElement, openSections, existingOpenCard);
        return { charted, openCount: openSections.length };
      }

      function renderChartColumn(container, rows, header, type) {
        const labels = computeLabelsFromAllRows(rows, header, type);
        const filteredRows = activeFilter && activeFilter.header !== header ? getFilteredRows(rows) : rows;
        const data = computeCountsForLabels(filteredRows, header, type, labels);
        const colors = buildPalette(labels.length);
        const selectedValue = activeFilter && activeFilter.header === header ? activeFilter.value : null;
        const styledBackgrounds = selectedValue
          ? labels.map((label, index) => (label === selectedValue ? colors[index] : withAlpha(colors[index], 0.22)))
          : colors;
        const borderColors = chartType === "pie" ? "#fff" : styledBackgrounds.map(darkerHSL);
        const cardId = "chart-" + header.replace(/\s+/g, "-").toLowerCase();
        const existingCard = document.getElementById(cardId);
        if (existingCard) {
          const canvas = existingCard.querySelector("canvas");
          const chart = chartInstances.find((ch) => ch.canvas === canvas);
          if (chart) {
            if (chart.config.type !== (chartType === "pie" ? "pie" : "bar")) {
              chart.config.type = chartType === "pie" ? "pie" : "bar";
            }
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.data.datasets[0].backgroundColor = styledBackgrounds;
            chart.data.datasets[0].borderColor = borderColors;
            chart.update();
          }
        } else {
          createDistributionChart(container, header, labels, data, chartType, {
            onClick: (evt, elements, chart) => handleChartClick(evt, chart, header, labels),
          });
          // Apply styling after chart creation
          const lastChart = chartInstances[chartInstances.length - 1];
          lastChart.data.datasets[0].backgroundColor = styledBackgrounds;
          lastChart.data.datasets[0].borderColor = borderColors;
          lastChart.update();
        }
      }

      function handleChartClick(evt, chart, header, labels) {
        const points = chart.getElementsAtEventForMode(evt, "nearest", { intersect: true }, true);
        if (!points || !points.length) return;
        const index = points[0].index;
        const value = labels[index];
        if (activeFilter && activeFilter.header === header && activeFilter.value === value) {
          activeFilter = null; // toggle off
        } else {
          activeFilter = { header, value };
        }
        if (lastData && lastData.rows?.length) analyze(lastData.rows, lastData.headers);
      }

      function parseCSV(text) {
        const parsed = Papa.parse(text, {
          header: true,
          skipEmptyLines: "greedy",
          dynamicTyping: false,
        });
        if (parsed.errors && parsed.errors.length) {
          console.warn("CSV parse warnings/errors:", parsed.errors);
        }
        let rows = parsed.data || [];
        rows = rows.filter((row) => Object.values(row).some((value) => !isBlank(value)));
        const headers = parsed.meta.fields || Object.keys(rows[0] || {});
        return { rows, headers };
      }

      function renderOpenEnded(container, sections, existingCard = null) {
        const card = existingCard || document.createElement("div");
        if (!existingCard) {
          card.className = "card open-ended";
          card.id = "open-ended";
          container.appendChild(card);
        } else {
          card.innerHTML = ""; // clear existing content
        }
        const heading = document.createElement("h3");
        heading.textContent = "Open-ended responses";
        card.appendChild(heading);

        if (sections.length === 0) {
          const paragraph = document.createElement("p");
          paragraph.textContent = "None detected.";
          card.appendChild(paragraph);
          return;
        }

        sections.forEach((section) => {
          const details = document.createElement("details");
          details.open = false;
          const summary = document.createElement("summary");
          summary.textContent = section.header;
          details.appendChild(summary);

          const list = document.createElement("ul");
          list.style.marginTop = "6px";
          section.values.forEach((value) => {
            const listItem = document.createElement("li");
            const cleanedValue = clean(value);
            if (/^https?:\/\//i.test(cleanedValue)) {
              const link = document.createElement("a");
              link.href = cleanedValue;
              link.target = "_blank";
              link.rel = "noopener noreferrer";
              link.textContent = cleanedValue;
              listItem.appendChild(link);
            } else {
              listItem.textContent = cleanedValue;
            }
            list.appendChild(listItem);
          });
          details.appendChild(list);
          card.appendChild(details);
        });
      }

      function createDistributionChart(container, title, labels, data, type, optionsExt = {}) {
        const isPie = type === "pie";

        const card = document.createElement("div");
        card.className = "card";
        card.id = "chart-" + title.replace(/\s+/g, "-").toLowerCase();
        const heading = document.createElement("h3");
        heading.textContent = title;

        const chartbox = document.createElement("div");
        chartbox.className = "chartbox";

        const canvas = document.createElement("canvas");
        chartbox.appendChild(canvas);

        card.appendChild(heading);
        card.appendChild(chartbox);
        container.appendChild(card);

        const colors = buildPalette(labels.length);
        const borderColors = isPie ? "#fff" : colors.map(darkerHSL);

        const options = {
          responsive: true,
          maintainAspectRatio: false, // fill the .chartbox height
          resizeDelay: 200, // throttle resize observer to avoid feedback loops
          animation: { duration: 0 },
          plugins: {
            legend: { display: isPie },
            tooltip: { enabled: true },
          },
          onClick: optionsExt.onClick,
        };
        if (!isPie) {
          options.scales = {
            x: { ticks: { autoSkip: false, maxRotation: 45, minRotation: 0 } },
            y: { beginAtZero: true, ticks: { precision: 0 } },
          };
        }

        const chart = new Chart(canvas.getContext("2d"), {
          type: isPie ? "pie" : "bar",
          data: {
            labels,
            datasets: [
              {
                label: "Responses",
                data,
                backgroundColor: colors,
                borderColor: borderColors,
                borderWidth: 1,
              },
            ],
          },
          options,
        });

        chartInstances.push(chart);
      }

      function computeLabelsFromAllRows(rows, header, type) {
        const isNumeric = type === "numeric";
        const counts = new Map();
        for (const row of rows) {
          const rawValue = row[header];
          if (isBlank(rawValue)) continue;
          const key = normalizeKey(rawValue, isNumeric);
          counts.set(key, (counts.get(key) || 0) + 1);
        }
        let entries = [...counts.entries()];
        entries = sortEntriesForDisplay(entries, isNumeric);
        return entries.map((entry) => String(entry[0]));
      }

      function computeCountsForLabels(rows, header, type, labels) {
        const isNumeric = type === "numeric";
        const map = new Map();
        for (const row of rows) {
          const rawValue = row[header];
          if (isBlank(rawValue)) continue;
          const key = normalizeKey(rawValue, isNumeric);
          map.set(key, (map.get(key) || 0) + 1);
        }
        return labels.map((label) => map.get(label) || 0);
      }

      function getFilteredRows(rows) {
        if (!activeFilter) return rows;
        const type = columnTypes.get(activeFilter.header);
        const isNumeric = type === "numeric";
        return rows.filter((row) => {
          const rawValue = row[activeFilter.header];
          if (isBlank(rawValue)) return false;
          return normalizeKey(rawValue, isNumeric) === activeFilter.value;
        });
      }

      function detectColumnType(values) {
        if (values.length === 0) return "open";
        const numericCount = values.filter(isNumericStrict).length;
        const averageLength = values.reduce((sum, value) => sum + clean(value).length, 0) / values.length;
        const uniqueValues = new Set(values.map((value) => clean(value)));
        const uniqueRatio = uniqueValues.size / values.length;
        const hasURL = values.some((value) => /https?:\/\//i.test(value));
        const hasEmail = values.some((value) => /@/.test(value));
        const isLongText = averageLength > 80 || values.some((value) => clean(value).length > 200);

        if (numericCount / values.length >= 0.8) return "numeric";
        if (uniqueRatio > 0.6 || isLongText || hasURL || hasEmail) return "open";
        return "choice";
      }

      function countValues(values, isNumeric = false) {
        const counts = new Map();
        for (const value of values) {
          const key = isNumeric ? Number(value) : clean(value);
          counts.set(key, (counts.get(key) || 0) + 1);
        }
        return counts;
      }

      function sortEntriesForDisplay(entries, isNumeric = false) {
        if (isNumeric) {
          entries.sort((a, b) => Number(a[0]) - Number(b[0]));
        } else {
          entries.sort((a, b) => {
            if (b[1] !== a[1]) return b[1] - a[1];
            return String(a[0]).localeCompare(String(b[0]));
          });
        }
        return entries;
      }

      function buildPalette(count) {
        const colors = [];
        for (let i = 0; i < count; i++) {
          const hue = (i * 47) % 360;
          colors.push(`hsl(${hue} 70% 70%)`);
        }
        return colors;
      }

      function darkerHSL(hsl) {
        // Expecting hsl(H S% L%)
        return hsl.replace(/(\d+)\s+(\d+)%\s+(\d+)%/, (match, h, s, l) => `${h} ${s}% ${Math.max(0, Number(l) - 20)}%`);
      }

      function withAlpha(hsl, alpha) {
        // Convert 'hsl(H S% L%)' to 'hsl(H S% L% / a)'
        if (!hsl.startsWith("hsl(")) return hsl;
        return hsl.replace(/\)$/, ` / ${alpha})`);
      }

      function normalizeKey(value, isNumeric = false) {
        if (isNumeric) return String(Number(value));
        return String(clean(value));
      }

      // Utility functions
      const isBlank = (value) => value === null || value === undefined || String(value).trim() === "";
      const clean = (value) => String(value ?? "").trim();
      const isNumericStrict = (value) => {
        const stringValue = clean(value);
        if (stringValue === "") return false;
        return /^-?\d+(\.\d+)?$/.test(stringValue);
      };

      // Wire up UI
      document.getElementById("fileInput").addEventListener("change", (event) => {
        const file = event.target.files?.[0];
        if (file) handleFile(file);
      });

      // Radio group for chart type
      document.querySelectorAll('input[name="chartType"]').forEach((radio) => {
        radio.addEventListener("change", (event) => {
          chartType = event.target.value;
          if (lastData && lastData.rows?.length) {
            analyze(lastData.rows, lastData.headers);
          }
        });
      });
    </script>
  </body>
</html>
