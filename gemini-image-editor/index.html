<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini Multi-Image Manipulator (esm.sh)</title>
    <style>
      /* CSS Variables for easy theming/refactoring */
      :root {
        --color-text-primary: #333;
        --color-text-secondary: #555;
        --color-border-light: #eee;
        --color-border-medium: #ccc;
        --color-border-dark: #aaa;
        --color-accent: blue;
        --color-background-hover: #f0f8ff;
        --color-overlay: rgba(0, 0, 0, 0.5);
        --color-white: white;
        --color-drag-handle: #999;
        --color-drag-handle-hover: #eeeeee;
        --color-delete-button: transparent;
        --color-insert-indicator: #28a745;
        --color-action-button-hover: #eeeeee;
        --color-system-bg: #f9f9f9;
      }

      * {
        font-size: inherit;
        box-sizing: border-box;
      }

      /* Minimal CSS to ensure readability and structure */
      body {
        font-family: sans-serif;
        max-width: 40rem;
        margin: 0 auto;
        padding: 16px;
        color: var(--color-text-primary);
      }
      .input-section,
      .output-section {
        margin-bottom: 24px;
        padding: 16px;
        border: 1px solid var(--color-border-light);
        border-radius: 4px;
      }

      textarea,
      input[type="text"],
      input[type="password"] {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
        margin-top: 4px;
        margin-bottom: 8px;
      }
      textarea {
        field-sizing: content;
        resize: none;
      }
      button {
        cursor: pointer;
      }

      .action-buttons {
        margin-top: 16px;
        text-align: left;
      }

      .loading {
        display: none;
        margin-top: 8px;
        color: var(--color-text-secondary);
      }

      /* System Message Area */
      .system-message {
        margin-bottom: 0;
        padding: 16px;
        border: 2px solid var(--color-border-medium);
        border-radius: 4px;
        background-color: var(--color-system-bg);
      }

      .system-message label {
        display: block;
        font-weight: bold;
        margin-bottom: 4px;
        color: var(--color-text-secondary);
      }

      .system-message textarea {
        margin: 0;
      }

      /* Message Items Container */
      #messages-container {
        margin-top: 0;
      }

      /* Individual Message Item */
      .message-item {
        /* Dynamic Grid Layout:
           - Without image: [drag] [textarea] [buttons]
           - With image: [drag] [thumbnail] [textarea] [buttons]
        */
        display: grid;
        grid-template-columns: auto 1fr auto; /* Default: drag | content | buttons */
        align-items: start;
        margin-bottom: 8px;
        border: 1px solid var(--color-border-medium);
        border-radius: 4px;
        background-color: var(--color-white);
        position: relative;
      }

      /* When item has an image, adjust grid to include thumbnail */
      .message-item.has-image {
        grid-template-columns: auto auto 1fr auto; /* drag | thumbnail | textarea | buttons */
      }

      .message-item.dragging {
        opacity: 0.5;
      }

      .message-item.drag-over-top::before,
      .message-item.drag-over-bottom::after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        height: 3px;
        background-color: var(--color-insert-indicator);
        z-index: 10;
      }

      .message-item.drag-over-top::before {
        top: -2px;
      }

      .message-item.drag-over-bottom::after {
        bottom: -2px;
      }

      /* Drag Handle (Column 1) */
      .drag-handle {
        align-self: stretch;
        grid-column: 1 / 2;
        width: 24px;
        background-color: transparent;
        cursor: grab;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--color-drag-handle);
        font-size: 24px;
        line-height: 1;
        user-select: none;
        padding: 8px 0;
        border-right: 1px solid var(--color-border-medium);
      }

      .drag-handle:active {
        cursor: grabbing;
      }

      .drag-handle:hover {
        background-color: var(--color-drag-handle-hover);
      }

      /* Thumbnail (Column 2 - only visible when has-image class is present) */
      .message-thumbnail {
        grid-column: 2 / 3;
        width: 80px;
        height: 80px;
        object-fit: cover;
        border: 1px solid var(--color-border-medium);
        border-radius: 4px;
        margin: 8px;
        display: none; /* Hidden by default */
      }

      .message-item.has-image .message-thumbnail {
        display: block; /* Show when item has image */
      }

      /* Textarea (Column 2 without image, Column 3 with image) */
      .message-textarea {
        grid-column: 2 / 3; /* Default position without image */
        min-width: 100%;
        margin: 0;
        padding: 8px;
        border: none;
        height: 100%;
        max-height: 40vh;
      }

      .message-item.has-image .message-textarea {
        grid-column: 3 / 4; /* Shift to column 3 when image is present */
      }

      /* Buttons Container (Column 3 without image, Column 4 with image) */
      .message-buttons {
        border-left: 1px solid var(--color-border-medium);
        grid-column: 3 / 4; /* Default position without image */
        display: flex;
        flex-direction: column;
        align-items: center;
        align-self: stretch;
      }

      .message-item.has-image .message-buttons {
        grid-column: 4 / 5; /* Shift to column 4 when image is present */
      }

      .message-button {
        background-color: transparent;
        border: none;
        cursor: pointer;
        font-size: 20px;
        padding: 0;
        line-height: 1;
        padding: 8px;
      }

      .message-button:hover {
        background-color: var(--color-action-button-hover);
      }

      /* Output Image */
      #output-image {
        max-width: 100%;
        height: auto;
        border: 1px solid var(--color-border-medium);
        margin-top: 8px;
      }

      /* Hidden file input */
      .hidden-file-input {
        display: none;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Gemini Editor</h1>
    </header>

    <div class="input-section">
      <h2>Connect</h2>
      <label for="api-key">Gemini API Key:</label>
      <input type="password" id="api-key" placeholder="Enter your Gemini API Key here" />
    </div>

    <div class="input-section">
      <h2>Input</h2>

      <!-- System Message (Fixed at top) -->
      <div class="system-message">
        <label for="system-message">System Message:</label>
        <textarea id="system-message" rows="3" placeholder="Enter system instructions here..."></textarea>
      </div>

      <div id="messages-container">
        <!-- Message items will be inserted here -->
      </div>

      <div class="action-buttons">
        <button id="add-item-button">Add Item</button>
        <button id="delete-all-button">Delete All</button>
        <button id="generate-button">Generate Image</button>
        <div id="loading" class="loading">Processing... Please wait.</div>
      </div>
    </div>

    <div class="output-section">
      <h2>Output</h2>
      <p id="output-text"></p>
      <img id="output-image" style="display: none" alt="Generated Image" />
    </div>

    <script type="module">
      import { GoogleGenAI } from "https://esm.sh/@google/genai";
      import { get, set, createStore } from "https://esm.sh/idb-keyval";

      class GeminiImageManipulator {
        // --- 1. CONSTANTS ---
        static MODEL = "gemini-2.5-flash-image-preview";
        static DB_NAME = "gemini-image-sandbox";
        static STORE_NAME = "keyval";

        // --- 2. MAIN CLASS & CONSTRUCTOR ---

        constructor() {
          // State: Array of message items
          // Each item: { id: string, text: string, image: {blob, mimeType, dataUrl} | null }
          this.messages = [];
          this.nextId = 1;

          // Drag state
          this.draggedElement = null;
          this.draggedId = null;

          // Persistence Store
          this.store = createStore(GeminiImageManipulator.DB_NAME, GeminiImageManipulator.STORE_NAME);

          // DOM Elements
          this.elements = {
            apiKeyInput: document.getElementById("api-key"),
            systemMessage: document.getElementById("system-message"),
            generateButton: document.getElementById("generate-button"),
            messagesContainer: document.getElementById("messages-container"),
            addItemButton: document.getElementById("add-item-button"),
            deleteAllButton: document.getElementById("delete-all-button"),
            outputImage: document.getElementById("output-image"),
            outputText: document.getElementById("output-text"),
            loadingIndicator: document.getElementById("loading"),
          };

          this.loadState().then(() => {
            this.bindEvents();
            this.renderMessages();
          });
        }

        // --- Persistence Methods ---

        async loadState() {
          try {
            const { apiKeyInput, systemMessage, outputImage } = this.elements;

            // Load API Key
            const apiKey = await get("apiKey", this.store);
            if (apiKey) apiKeyInput.value = apiKey;

            // Load System Message
            const systemMsg = await get("systemMessage", this.store);
            if (systemMsg) systemMessage.value = systemMsg;

            // Load Messages
            const messages = await get("messages", this.store);
            if (messages && Array.isArray(messages)) {
              // Reconstruct messages, converting Blobs back to data URLs for images
              this.messages = await Promise.all(
                messages.map(async (msg) => {
                  if (msg.image) {
                    const dataUrl = await GeminiImageManipulator.blobToDataUrl(msg.image.blob);
                    return {
                      ...msg,
                      image: {
                        ...msg.image,
                        dataUrl: dataUrl,
                      },
                    };
                  }
                  return msg;
                })
              );
              // Update nextId to avoid collisions
              const maxId = Math.max(...this.messages.map((m) => parseInt(m.id)), 0);
              this.nextId = maxId + 1;
            }

            // Load Output Image
            const outputDataUrl = await get("outputImage", this.store);
            if (outputDataUrl) {
              outputImage.src = outputDataUrl;
              outputImage.style.display = "block";
            }
          } catch (error) {
            console.error("Error loading state from IndexedDB:", error);
          }
        }

        async saveApiKey(key) {
          await set("apiKey", key, this.store);
        }

        async saveSystemMessage(message) {
          await set("systemMessage", message, this.store);
        }

        async saveMessages() {
          // Store messages, keeping Blobs for images but removing dataUrl
          const serializableMessages = this.messages.map((msg) => {
            if (msg.image) {
              return {
                ...msg,
                image: {
                  blob: msg.image.blob,
                  mimeType: msg.image.mimeType,
                  // dataUrl is omitted for storage efficiency
                },
              };
            }
            return msg;
          });
          await set("messages", serializableMessages, this.store);
        }

        async saveOutput(dataUrl) {
          await set("outputImage", dataUrl, this.store);
        }

        // --- Event Binding ---

        bindEvents() {
          this.elements.generateButton.addEventListener("click", () => this.handleGenerate());
          this.elements.addItemButton.addEventListener("click", () => this.addItem());
          this.elements.deleteAllButton.addEventListener("click", () => this.deleteAllMessages());

          // Persistence listeners
          this.elements.apiKeyInput.addEventListener("input", (e) => this.saveApiKey(e.target.value.trim()));
          this.elements.systemMessage.addEventListener("input", (e) => this.saveSystemMessage(e.target.value.trim()));
        }

        // --- Message Management ---

        addItem() {
          const id = String(this.nextId++);
          this.messages.push({
            id,
            text: "",
            image: null,
          });
          this.renderMessages();
          this.saveMessages();
        }

        deleteMessage(id) {
          this.messages = this.messages.filter((msg) => msg.id !== id);
          this.renderMessages();
          this.saveMessages();
        }

        deleteAllMessages() {
          this.messages = [];
          this.renderMessages();
          this.saveMessages();
        }

        updateMessageText(id, text) {
          const message = this.messages.find((msg) => msg.id === id);
          if (message) {
            message.text = text;
            this.saveMessages();
          }
        }

        async updateMessageImage(id, file) {
          if (!file.type.startsWith("image/")) return;

          const message = this.messages.find((msg) => msg.id === id);
          if (message) {
            const blob = file;
            const mimeType = file.type;
            const dataUrl = await GeminiImageManipulator.blobToDataUrl(blob);

            message.image = {
              blob,
              mimeType,
              dataUrl,
            };

            this.renderMessages();
            this.saveMessages();
          }
        }

        // --- Rendering ---

        renderMessages() {
          const container = this.elements.messagesContainer;
          container.innerHTML = "";

          this.messages.forEach((message) => {
            const itemElement = this.createMessageElement(message);
            container.appendChild(itemElement);
          });
        }

        createMessageElement(message) {
          const item = document.createElement("div");
          item.className = "message-item";
          if (message.image) {
            item.classList.add("has-image");
          }
          item.dataset.id = message.id;
          item.draggable = true;

          // Drag Handle
          const dragHandle = document.createElement("div");
          dragHandle.className = "drag-handle";
          dragHandle.innerHTML = "â‹®";
          item.appendChild(dragHandle);

          // Thumbnail (only visible when has-image class is present)
          const thumbnail = document.createElement("img");
          thumbnail.className = "message-thumbnail";
          if (message.image) {
            thumbnail.src = message.image.dataUrl;
            thumbnail.alt = "Image";
          }
          item.appendChild(thumbnail);

          // Textarea
          const textarea = document.createElement("textarea");
          textarea.className = "message-textarea";
          textarea.value = message.text;
          textarea.placeholder = "Enter text or paste an image...";
          textarea.addEventListener("input", (e) => {
            this.updateMessageText(message.id, e.target.value);
          });

          // Handle paste event for images
          textarea.addEventListener("paste", async (e) => {
            const items = e.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
              if (items[i].type.indexOf("image") !== -1) {
                e.preventDefault();
                const file = items[i].getAsFile();
                await this.updateMessageImage(message.id, file);
                break; // Only handle first image for now
              }
            }
          });

          item.appendChild(textarea);

          // Buttons Container
          const buttonsContainer = document.createElement("div");
          buttonsContainer.className = "message-buttons";

          // Delete Button
          const deleteButton = document.createElement("button");
          deleteButton.className = "message-button";
          deleteButton.innerHTML = "ðŸ—‘ï¸";
          deleteButton.title = "Delete";
          deleteButton.addEventListener("click", () => this.deleteMessage(message.id));
          buttonsContainer.appendChild(deleteButton);

          // Upload Image Button
          const uploadButton = document.createElement("button");
          uploadButton.className = "message-button";
          uploadButton.innerHTML = "ðŸ“·";
          uploadButton.title = "Upload Image";
          uploadButton.addEventListener("click", () => {
            const fileInput = document.createElement("input");
            fileInput.type = "file";
            fileInput.accept = "image/*";
            fileInput.style.display = "none";
            fileInput.addEventListener("change", async (e) => {
              const file = e.target.files[0];
              if (file) {
                await this.updateMessageImage(message.id, file);
              }
            });
            document.body.appendChild(fileInput);
            fileInput.click();
            document.body.removeChild(fileInput);
          });
          buttonsContainer.appendChild(uploadButton);

          item.appendChild(buttonsContainer);

          // Drag Events
          item.addEventListener("dragstart", (e) => this.handleDragStart(e, message.id));
          item.addEventListener("dragend", (e) => this.handleDragEnd(e));
          item.addEventListener("dragover", (e) => this.handleDragOver(e));
          item.addEventListener("dragleave", (e) => this.handleDragLeave(e));
          item.addEventListener("drop", (e) => this.handleDrop(e, message.id));

          return item;
        }

        // --- Drag and Drop for Reordering ---

        handleDragStart(e, id) {
          this.draggedElement = e.currentTarget;
          this.draggedId = id;
          e.currentTarget.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/html", e.currentTarget.innerHTML);
        }

        handleDragEnd(e) {
          e.currentTarget.classList.remove("dragging");
          // Remove all drag-over classes
          document.querySelectorAll(".message-item").forEach((item) => {
            item.classList.remove("drag-over-top", "drag-over-bottom");
          });
          this.draggedElement = null;
          this.draggedId = null;
        }

        handleDragOver(e) {
          if (e.preventDefault) {
            e.preventDefault();
          }
          e.dataTransfer.dropEffect = "move";

          const targetElement = e.currentTarget;
          if (targetElement === this.draggedElement) {
            return;
          }

          // Determine if we should insert above or below
          const rect = targetElement.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const isTop = e.clientY < midpoint;

          // Remove previous indicators
          targetElement.classList.remove("drag-over-top", "drag-over-bottom");

          // Add appropriate indicator
          if (isTop) {
            targetElement.classList.add("drag-over-top");
          } else {
            targetElement.classList.add("drag-over-bottom");
          }

          return false;
        }

        handleDragLeave(e) {
          e.currentTarget.classList.remove("drag-over-top", "drag-over-bottom");
        }

        handleDrop(e, targetId) {
          if (e.stopPropagation) {
            e.stopPropagation();
          }
          e.preventDefault();

          const targetElement = e.currentTarget;
          targetElement.classList.remove("drag-over-top", "drag-over-bottom");

          if (this.draggedId === targetId) {
            return;
          }

          // Determine insertion position
          const rect = targetElement.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const isTop = e.clientY < midpoint;

          // Reorder messages array
          const draggedIndex = this.messages.findIndex((msg) => msg.id === this.draggedId);
          const targetIndex = this.messages.findIndex((msg) => msg.id === targetId);

          if (draggedIndex === -1 || targetIndex === -1) return;

          const [draggedMessage] = this.messages.splice(draggedIndex, 1);

          let insertIndex = targetIndex;
          if (draggedIndex < targetIndex) {
            // If dragging down, adjust index
            insertIndex = isTop ? targetIndex - 1 : targetIndex;
          } else {
            // If dragging up
            insertIndex = isTop ? targetIndex : targetIndex + 1;
          }

          this.messages.splice(insertIndex, 0, draggedMessage);

          this.renderMessages();
          this.saveMessages();

          return false;
        }

        // --- 3. CORE LOGIC METHODS ---

        async handleGenerate() {
          const { apiKeyInput, systemMessage, generateButton, loadingIndicator, outputImage, outputText } = this.elements;
          const apiKey = apiKeyInput.value.trim();
          const systemMsg = systemMessage.value.trim();

          if (!apiKey) {
            alert("Please provide an API Key.");
            return;
          }

          if (!systemMsg && this.messages.length === 0) {
            alert("Please provide either a system message or at least one message item.");
            return;
          }

          // UI State: Start Loading
          outputImage.style.display = "none";
          outputImage.src = "";
          outputText.textContent = "";
          loadingIndicator.style.display = "block";
          generateButton.disabled = true;

          try {
            const ai = new GoogleGenAI({ apiKey });
            await this.generateContent(ai, systemMsg);
          } catch (error) {
            console.error("Gemini API Error:", error);
            outputText.textContent = `Error: ${error.message || "An unknown error occurred."}`;
            outputImage.style.display = "none";
          } finally {
            // UI State: Stop Loading
            loadingIndicator.style.display = "none";
            generateButton.disabled = false;
          }
        }

        /**
         * Calls the Gemini API and handles the streaming response.
         * @param {GoogleGenAI} ai
         * @param {string} systemMsg
         */
        async generateContent(ai, systemMsg) {
          const { outputImage, outputText } = this.elements;

          // Build parts array from messages
          const parts = [];

          // Add system message first if present
          if (systemMsg) {
            parts.push({ text: systemMsg });
          }

          // Add user messages
          for (const message of this.messages) {
            // Add image if present
            if (message.image) {
              const base64Data = await GeminiImageManipulator.blobToBase64(message.image.blob);
              const imagePart = {
                inlineData: {
                  data: base64Data,
                  mimeType: message.image.mimeType,
                },
              };
              parts.push(imagePart);
            }

            // Add text if present
            if (message.text.trim()) {
              parts.push({ text: message.text.trim() });
            }
          }

          const contents = [
            {
              role: "user",
              parts,
            },
          ];

          const config = {
            responseModalities: ["IMAGE"],
          };

          const response = await ai.models.generateContentStream({
            model: GeminiImageManipulator.MODEL,
            config,
            contents,
          });

          let generatedImageUrls = [];
          let textContent = "";

          for await (const chunk of response) {
            const parts = chunk.candidates?.[0]?.content?.parts || [];
            for (const part of parts) {
              if (part.inlineData) {
                const { mimeType: imgMimeType, data } = part.inlineData;
                const imageUrl = `data:${imgMimeType};base64,${data}`;
                generatedImageUrls.push(imageUrl);
              } else if (part.text) {
                textContent += part.text;
              }
            }
          }

          // Display results
          if (generatedImageUrls.length > 0) {
            const finalImageUrl = generatedImageUrls[0];
            outputImage.src = finalImageUrl;
            outputImage.style.display = "block";
            outputText.textContent = "Image successfully generated.";
            this.saveOutput(finalImageUrl); // Persist output
          } else {
            outputText.textContent = "Generation complete, but no image was returned. Check the text response below.";
            this.saveOutput(null);
          }

          if (textContent) {
            outputText.textContent = `Model Response: ${textContent}`;
          }
        }

        // --- 5. UTILITY PURE FUNCTIONS (Static) ---

        /**
         * Converts a Blob object into a base64 string (for API transmission).
         * @param {Blob} blob
         * @returns {Promise<string>} Base64 string without the data URL prefix.
         */
        static blobToBase64(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
              const dataUrl = reader.result;
              const base64 = dataUrl.split(",")[1];
              resolve(base64);
            };
            reader.onerror = (error) => reject(error);
            reader.readAsDataURL(blob);
          });
        }

        /**
         * Converts a Blob object into a data URL (for UI display).
         * @param {Blob} blob
         * @returns {Promise<string>} Data URL string.
         */
        static blobToDataUrl(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = (error) => reject(error);
            reader.readAsDataURL(blob);
          });
        }
      }

      // Initialize the application
      document.addEventListener("DOMContentLoaded", () => {
        new GeminiImageManipulator();
      });
    </script>
  </body>
</html>
