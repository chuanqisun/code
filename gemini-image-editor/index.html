<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini Workbench</title>
    <style>
      /* CSS Variables for easy theming/refactoring */
      :root {
        --color-text-primary: #333;
        --color-text-secondary: #555;
        --color-border-light: #eee;
        --color-border-medium: #ccc;
        --color-border-dark: #aaa;
        --color-accent: blue;
        --color-background-hover: #f0f8ff;
        --color-overlay: rgba(0, 0, 0, 0.5);
        --color-white: white;
        --color-drag-handle: #999;
        --color-drag-handle-hover: #eeeeee;
        --color-delete-button: transparent;
        --color-insert-indicator: #28a745;
        --color-action-button-hover: #eeeeee;
        --color-system-bg: #f9f9f9;
      }

      * {
        font-size: inherit;
        box-sizing: border-box;
      }

      html {
        scrollbar-gutter: stable;
      }

      /* Minimal CSS to ensure readability and structure */
      body {
        font-family: sans-serif;
        max-width: 40rem;
        margin: 0 auto;
        padding: 16px;
        color: var(--color-text-primary);
        line-height: 1.4;
      }
      .input-section,
      .output-section {
        margin-bottom: 24px;
      }

      textarea,
      input[type="text"],
      input[type="password"] {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
        margin-top: 4px;
        margin-bottom: 8px;
      }
      textarea {
        field-sizing: content;
        resize: none;
      }
      button {
        cursor: pointer;
        background-color: transparent;
        border: 1px solid var(--color-border-medium);
        padding: 8px 16px;
        border-radius: 4px;
        color: var(--color-text-secondary);

        &:hover,
        &:focus {
          color: var(--color-text-primary);
          background-color: var(--color-action-button-hover);
        }
      }
      label {
        color: var(--color-text-secondary);
        font-size: 14px;
      }

      .action-buttons {
        display: flex;
        gap: 4px;
        flex-wrap: wrap;
        margin-top: 16px;
        text-align: left;
      }

      .loading {
        display: none;
        margin-top: 8px;
        color: var(--color-text-secondary);
      }

      /* System Message Area */
      .system-message {
        margin-bottom: 4px;
      }

      .system-message label {
        display: block;
        margin-bottom: 4px;
        color: var(--color-text-secondary);
      }

      input,
      textarea {
        font-family: monospace;
        margin: 0;
        border-radius: 4px;
        border: 1px solid var(--color-border-medium);
      }

      /* Message Items Container */
      #messages-container {
        margin-top: 0;
      }

      /* Individual Message Item */
      .message-item {
        /* Dynamic Grid Layout:
           - Without image: [drag] [textarea] [buttons]
           - With image: [drag] [thumbnail] [textarea] [buttons]
        */
        display: grid;
        grid-template-columns: auto 1fr auto; /* Default: drag | content | buttons */
        align-items: start;
        margin-bottom: 8px;
        border: 1px solid var(--color-border-medium);
        border-radius: 4px;
        background-color: var(--color-white);
        position: relative;
      }

      /* When item has an image, adjust grid to include thumbnail */
      .message-item.has-image {
        grid-template-columns: auto auto 1fr auto; /* drag | thumbnail | textarea | buttons */
      }

      .message-item.dragging {
        opacity: 0.5;
      }

      .message-item.drag-over-top::before,
      .message-item.drag-over-bottom::after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        height: 3px;
        background-color: var(--color-insert-indicator);
        z-index: 10;
      }

      .message-item.drag-over-top::before {
        top: -2px;
      }

      .message-item.drag-over-bottom::after {
        bottom: -2px;
      }

      /* Drag Handle (Column 1) */
      .drag-handle {
        align-self: stretch;
        grid-column: 1 / 2;
        width: 24px;
        background-color: transparent;
        cursor: grab;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--color-drag-handle);
        font-size: 24px;
        line-height: 1;
        user-select: none;
        padding: 8px 0;
        border-right: 1px solid var(--color-border-medium);
      }

      .drag-handle:active {
        cursor: grabbing;
      }

      .drag-handle:hover {
        color: var(--color-text-primary);
        background-color: var(--color-drag-handle-hover);
      }

      /* Thumbnail (Column 2 - only visible when has-image class is present) */
      .message-thumbnail {
        grid-column: 2 / 3;
        width: 80px;
        height: 80px;
        object-fit: cover;
        border: 1px solid var(--color-border-medium);
        border-radius: 4px;
        margin: 8px;
        display: none; /* Hidden by default */
      }

      .message-item.has-image .message-thumbnail {
        display: block; /* Show when item has image */
      }

      /* Textarea (Column 2 without image, Column 3 with image) */
      .message-textarea {
        grid-column: 2 / 3; /* Default position without image */
        min-width: 100%;
        margin: 0;
        padding: 8px;
        border: none;
        height: 100%;
        max-height: 40vh;
      }

      .message-item.has-image .message-textarea {
        grid-column: 3 / 4; /* Shift to column 3 when image is present */
      }

      /* Buttons Container (Column 3 without image, Column 4 with image) */
      .message-buttons {
        border-left: 1px solid var(--color-border-medium);
        grid-column: 3 / 4; /* Default position without image */
        display: flex;
        flex-direction: column;
        align-items: center;
        align-self: stretch;
      }

      .message-item.has-image .message-buttons {
        grid-column: 4 / 5; /* Shift to column 4 when image is present */
      }

      .message-button {
        background-color: transparent;
        border: none;
        cursor: pointer;
        font-size: 20px;
        padding: 0;
        line-height: 1;
        padding: 8px;
      }

      .message-button:hover {
        background-color: var(--color-action-button-hover);
      }

      /* Output Items */
      #output-container {
        margin-top: 8px;
      }

      .output-item {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: start;
        margin-bottom: 16px;
        border: 1px solid var(--color-border-medium);
        border-radius: 4px;
        background-color: var(--color-white);
      }

      .output-item-content {
        padding: 8px;
        min-width: 0;
      }

      .output-item-image {
        max-width: 100%;
        height: auto;
        border: 1px solid var(--color-border-medium);
        border-radius: 4px;
        margin-bottom: 8px;
      }

      .output-item-image.loading {
        opacity: 0.5;
      }

      .output-item-text {
        color: var(--color-text-secondary);
        font-size: 14px;
      }

      .output-item-buttons {
        border-left: 1px solid var(--color-border-medium);
        grid-column: 2 / 3;
        display: flex;
        flex-direction: column;
        align-items: center;
        align-self: stretch;
      }

      /* Hidden file input */
      .hidden-file-input {
        display: none;
      }

      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Setup</h1>
    </header>

    <div class="input-section">
      <label for="api-key">Gemini API Key</label>
      <input type="password" id="api-key" placeholder="Enter your Gemini API Key here" />
    </div>

    <div class="input-section">
      <h2>Input</h2>

      <!-- System Message (Fixed at top) -->
      <div class="system-message">
        <label for="system-message">System message</label>
        <textarea id="system-message" rows="3" placeholder="Optional system instructions prompt..."></textarea>
      </div>

      <div id="messages-container">
        <!-- Message items will be inserted here -->
      </div>

      <div class="action-buttons">
        <button id="add-item-button">Add Item</button>
        <button id="delete-all-button">Delete All</button>
      </div>
    </div>

    <div class="output-section">
      <h2>Output</h2>
      <div class="action-buttons">
        <button id="generate-button">Generate image</button>
        <button id="generate-text-button">Generate text</button>
        <button id="delete-all-outputs-button">Delete all</button>
      </div>
      <div id="output-container">
        <!-- Output items will be inserted here -->
      </div>
    </div>

    <script type="module">
      import { GoogleGenAI } from "https://esm.sh/@google/genai";
      import { get, set, createStore } from "https://esm.sh/idb-keyval";

      class GeminiImageManipulator {
        // --- 1. CONSTANTS ---
        static MODEL = "gemini-2.5-flash-image-preview";
        static TEXT_MODEL = "gemini-2.5-flash";
        static DB_NAME = "gemini-image-sandbox";
        static STORE_NAME = "keyval";
        static PLACEHOLDER_IMAGE = "https://placehold.co/800";

        // --- 2. MAIN CLASS & CONSTRUCTOR ---

        constructor() {
          // State: Array of message items
          // Each item: { id: string, text: string, image: {blob, mimeType, dataUrl} | null }
          this.messages = [];
          this.nextId = 1;

          // Output items state
          // Each item: { id: string, imageUrl: string, text: string, loading: boolean }
          this.outputs = [];
          this.nextOutputId = 1;

          // Drag state
          this.draggedElement = null;
          this.draggedId = null;

          // Persistence Store
          this.store = createStore(GeminiImageManipulator.DB_NAME, GeminiImageManipulator.STORE_NAME);

          // DOM Elements
          this.elements = {
            apiKeyInput: document.getElementById("api-key"),
            systemMessage: document.getElementById("system-message"),
            generateImageButton: document.getElementById("generate-button"),
            generateTextButton: document.getElementById("generate-text-button"),
            messagesContainer: document.getElementById("messages-container"),
            addItemButton: document.getElementById("add-item-button"),
            deleteAllButton: document.getElementById("delete-all-button"),
            outputContainer: document.getElementById("output-container"),
            deleteAllOutputsButton: document.getElementById("delete-all-outputs-button"),
          };

          this.loadState().then(() => {
            this.bindEvents();
            this.renderMessages();
            this.renderOutputs();
          });
        }

        // --- Persistence Methods ---

        async loadState() {
          try {
            const { apiKeyInput, systemMessage } = this.elements;

            // Load API Key
            const apiKey = await get("apiKey", this.store);
            if (apiKey) apiKeyInput.value = apiKey;

            // Load System Message
            const systemMsg = await get("systemMessage", this.store);
            if (systemMsg) systemMessage.value = systemMsg;

            // Load Messages
            const messages = await get("messages", this.store);
            if (messages && Array.isArray(messages)) {
              // Reconstruct messages, converting Blobs back to data URLs for images
              this.messages = await Promise.all(
                messages.map(async (msg) => {
                  if (msg.image) {
                    const dataUrl = await GeminiImageManipulator.blobToDataUrl(msg.image.blob);
                    return {
                      ...msg,
                      image: {
                        ...msg.image,
                        dataUrl: dataUrl,
                      },
                    };
                  }
                  return msg;
                })
              );
              // Update nextId to avoid collisions
              const maxId = Math.max(...this.messages.map((m) => parseInt(m.id)), 0);
              this.nextId = maxId + 1;
            }

            // Load Outputs
            const outputs = await get("outputs", this.store);
            if (outputs && Array.isArray(outputs)) {
              this.outputs = outputs.filter((output) => !output.loading); // Remove any loading states
              const maxOutputId = Math.max(...this.outputs.map((o) => parseInt(o.id)), 0);
              this.nextOutputId = maxOutputId + 1;
            }
          } catch (error) {
            console.error("Error loading state from IndexedDB:", error);
          }
        }

        async saveApiKey(key) {
          await set("apiKey", key, this.store);
        }

        async saveSystemMessage(message) {
          await set("systemMessage", message, this.store);
        }

        async saveMessages() {
          // Store messages, keeping Blobs for images but removing dataUrl
          const serializableMessages = this.messages.map((msg) => {
            if (msg.image) {
              return {
                ...msg,
                image: {
                  blob: msg.image.blob,
                  mimeType: msg.image.mimeType,
                  // dataUrl is omitted for storage efficiency
                },
              };
            }
            return msg;
          });
          await set("messages", serializableMessages, this.store);
        }

        async saveOutputs() {
          // Only save non-loading outputs
          const serializableOutputs = this.outputs.filter((output) => !output.loading);
          await set("outputs", serializableOutputs, this.store);
        }

        // --- Event Binding ---

        bindEvents() {
          this.elements.generateImageButton.addEventListener("click", () => this.handleGenerateImage());
          this.elements.generateTextButton.addEventListener("click", () => this.handleGenerateText());
          this.elements.addItemButton.addEventListener("click", () => this.addItem());
          this.elements.deleteAllButton.addEventListener("click", () => this.deleteAllMessages());
          this.elements.deleteAllOutputsButton.addEventListener("click", () => this.deleteAllOutputs());

          // Persistence listeners
          this.elements.apiKeyInput.addEventListener("input", (e) => this.saveApiKey(e.target.value.trim()));
          this.elements.systemMessage.addEventListener("input", (e) => this.saveSystemMessage(e.target.value.trim()));
        }

        // --- Message Management ---

        addItem() {
          const id = String(this.nextId++);
          this.messages.push({
            id,
            text: "",
            image: null,
          });
          this.renderMessages();
          this.saveMessages();
        }

        deleteMessage(id) {
          this.messages = this.messages.filter((msg) => msg.id !== id);
          this.renderMessages();
          this.saveMessages();
        }

        deleteAllMessages() {
          this.messages = [];
          this.renderMessages();
          this.saveMessages();
        }

        updateMessageText(id, text) {
          const message = this.messages.find((msg) => msg.id === id);
          if (message) {
            message.text = text;
            this.saveMessages();
          }
        }

        async updateMessageImage(id, file) {
          if (!file.type.startsWith("image/")) return;

          const message = this.messages.find((msg) => msg.id === id);
          if (message) {
            const blob = file;
            const mimeType = file.type;
            const dataUrl = await GeminiImageManipulator.blobToDataUrl(blob);

            message.image = {
              blob,
              mimeType,
              dataUrl,
            };

            this.renderMessages();
            this.saveMessages();
          }
        }

        // --- Output Management ---

        addOutput(showImage = true) {
          const id = String(this.nextOutputId++);
          const output = {
            id,
            imageUrl: showImage ? GeminiImageManipulator.PLACEHOLDER_IMAGE : null,
            text: "Generating...",
            loading: true,
          };
          this.outputs.unshift(output); // Add to top
          this.renderOutputs();
          return id;
        }

        updateOutput(id, imageUrl, text) {
          const output = this.outputs.find((o) => o.id === id);
          if (output) {
            output.imageUrl = imageUrl;
            output.text = text;
            output.loading = false;
            this.renderOutputs();
            this.saveOutputs();
          }
        }

        deleteOutput(id) {
          this.outputs = this.outputs.filter((o) => o.id !== id);
          this.renderOutputs();
          this.saveOutputs();
        }

        deleteAllOutputs() {
          this.outputs = [];
          this.renderOutputs();
          this.saveOutputs();
        }

        // --- Rendering ---

        renderMessages() {
          const container = this.elements.messagesContainer;
          container.innerHTML = "";

          this.messages.forEach((message) => {
            const itemElement = this.createMessageElement(message);
            container.appendChild(itemElement);
          });
        }

        createMessageElement(message) {
          const item = document.createElement("div");
          item.className = "message-item";
          if (message.image) {
            item.classList.add("has-image");
          }
          item.dataset.id = message.id;
          item.draggable = true;

          // Drag Handle
          const dragHandle = document.createElement("div");
          dragHandle.className = "drag-handle";
          dragHandle.innerHTML = "â‹®";
          item.appendChild(dragHandle);

          // Thumbnail (only visible when has-image class is present)
          const thumbnail = document.createElement("img");
          thumbnail.className = "message-thumbnail";
          if (message.image) {
            thumbnail.src = message.image.dataUrl;
            thumbnail.alt = "Image";
          }
          item.appendChild(thumbnail);

          // Textarea
          const textarea = document.createElement("textarea");
          textarea.className = "message-textarea";
          textarea.value = message.text;
          textarea.placeholder = "Enter text or paste an image...";
          textarea.addEventListener("input", (e) => {
            this.updateMessageText(message.id, e.target.value);
          });

          // Handle paste event for images
          textarea.addEventListener("paste", async (e) => {
            const items = e.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
              if (items[i].type.indexOf("image") !== -1) {
                e.preventDefault();
                const file = items[i].getAsFile();
                await this.updateMessageImage(message.id, file);
                break; // Only handle first image for now
              }
            }
          });

          item.appendChild(textarea);

          // Buttons Container
          const buttonsContainer = document.createElement("div");
          buttonsContainer.className = "message-buttons";

          // Delete Button
          const deleteButton = document.createElement("button");
          deleteButton.className = "message-button";
          deleteButton.innerHTML = "ðŸ—‘ï¸";
          deleteButton.title = "Delete";
          deleteButton.addEventListener("click", () => this.deleteMessage(message.id));
          buttonsContainer.appendChild(deleteButton);

          // Upload Image Button
          const uploadButton = document.createElement("button");
          uploadButton.className = "message-button";
          uploadButton.innerHTML = "ðŸ“·";
          uploadButton.title = "Upload Image";
          uploadButton.addEventListener("click", () => {
            const fileInput = document.createElement("input");
            fileInput.type = "file";
            fileInput.accept = "image/*";
            fileInput.style.display = "none";
            fileInput.addEventListener("change", async (e) => {
              const file = e.target.files[0];
              if (file) {
                await this.updateMessageImage(message.id, file);
              }
            });
            document.body.appendChild(fileInput);
            fileInput.click();
            document.body.removeChild(fileInput);
          });
          buttonsContainer.appendChild(uploadButton);

          item.appendChild(buttonsContainer);

          // Drag Events
          item.addEventListener("dragstart", (e) => this.handleDragStart(e, message.id));
          item.addEventListener("dragend", (e) => this.handleDragEnd(e));
          item.addEventListener("dragover", (e) => this.handleDragOver(e));
          item.addEventListener("dragleave", (e) => this.handleDragLeave(e));
          item.addEventListener("drop", (e) => this.handleDrop(e, message.id));

          return item;
        }

        renderOutputs() {
          const container = this.elements.outputContainer;
          container.innerHTML = "";

          if (this.outputs.length === 0) {
            container.innerHTML = "<p>No outputs yet</p>";
            return;
          }

          this.outputs.forEach((output) => {
            const itemElement = this.createOutputElement(output);
            container.appendChild(itemElement);
          });
        }

        createOutputElement(output) {
          const item = document.createElement("div");
          item.className = "output-item";
          item.dataset.id = output.id;

          // Content container
          const content = document.createElement("div");
          content.className = "output-item-content";

          // Image (only show if imageUrl is not null)
          if (output.imageUrl) {
            const image = document.createElement("img");
            image.className = "output-item-image";
            if (output.loading) {
              image.classList.add("loading");
            }
            image.src = output.imageUrl;
            image.alt = "Generated Image";
            content.appendChild(image);
          }

          // Text
          const text = document.createElement("div");
          text.className = "output-item-text";
          text.textContent = output.text;
          content.appendChild(text);

          item.appendChild(content);

          // Buttons Container (matching message-buttons style)
          const buttonsContainer = document.createElement("div");
          buttonsContainer.className = "output-item-buttons";

          // Delete button
          const deleteButton = document.createElement("button");
          deleteButton.className = "message-button";
          deleteButton.innerHTML = "ðŸ—‘ï¸";
          deleteButton.title = "Delete";
          deleteButton.addEventListener("click", () => this.deleteOutput(output.id));
          buttonsContainer.appendChild(deleteButton);

          item.appendChild(buttonsContainer);

          return item;
        }

        // --- Drag and Drop for Reordering ---

        handleDragStart(e, id) {
          this.draggedElement = e.currentTarget;
          this.draggedId = id;
          e.currentTarget.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/html", e.currentTarget.innerHTML);
        }

        handleDragEnd(e) {
          e.currentTarget.classList.remove("dragging");
          // Remove all drag-over classes
          document.querySelectorAll(".message-item").forEach((item) => {
            item.classList.remove("drag-over-top", "drag-over-bottom");
          });
          this.draggedElement = null;
          this.draggedId = null;
        }

        handleDragOver(e) {
          if (e.preventDefault) {
            e.preventDefault();
          }
          e.dataTransfer.dropEffect = "move";

          const targetElement = e.currentTarget;
          if (targetElement === this.draggedElement) {
            return;
          }

          // Determine if we should insert above or below
          const rect = targetElement.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const isTop = e.clientY < midpoint;

          // Remove previous indicators
          targetElement.classList.remove("drag-over-top", "drag-over-bottom");

          // Add appropriate indicator
          if (isTop) {
            targetElement.classList.add("drag-over-top");
          } else {
            targetElement.classList.add("drag-over-bottom");
          }

          return false;
        }

        handleDragLeave(e) {
          e.currentTarget.classList.remove("drag-over-top", "drag-over-bottom");
        }

        handleDrop(e, targetId) {
          if (e.stopPropagation) {
            e.stopPropagation();
          }
          e.preventDefault();

          const targetElement = e.currentTarget;
          targetElement.classList.remove("drag-over-top", "drag-over-bottom");

          if (this.draggedId === targetId) {
            return;
          }

          // Determine insertion position
          const rect = targetElement.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const isTop = e.clientY < midpoint;

          // Reorder messages array
          const draggedIndex = this.messages.findIndex((msg) => msg.id === this.draggedId);
          const targetIndex = this.messages.findIndex((msg) => msg.id === targetId);

          if (draggedIndex === -1 || targetIndex === -1) return;

          const [draggedMessage] = this.messages.splice(draggedIndex, 1);

          let insertIndex = targetIndex;
          if (draggedIndex < targetIndex) {
            // If dragging down, adjust index
            insertIndex = isTop ? targetIndex - 1 : targetIndex;
          } else {
            // If dragging up
            insertIndex = isTop ? targetIndex : targetIndex + 1;
          }

          this.messages.splice(insertIndex, 0, draggedMessage);

          this.renderMessages();
          this.saveMessages();

          return false;
        }

        // --- 3. CORE LOGIC METHODS ---

        async handleGenerateImage() {
          const { apiKeyInput, systemMessage } = this.elements;
          const apiKey = apiKeyInput.value.trim();
          const systemMsg = systemMessage.value.trim();

          if (!apiKey) {
            alert("Please provide an API Key.");
            return;
          }

          if (!systemMsg && this.messages.length === 0) {
            alert("Please provide either a system message or at least one message item.");
            return;
          }

          // Create output item immediately with placeholder
          const outputId = this.addOutput();

          try {
            const ai = new GoogleGenAI({ apiKey });
            await this.generateImageContent(ai, systemMsg, outputId);
          } catch (error) {
            console.error("Gemini API Error:", error);
            this.updateOutput(outputId, GeminiImageManipulator.PLACEHOLDER_IMAGE, `Error: ${error.message || "An unknown error occurred."}`);
          }
        }

        async handleGenerateText() {
          const { apiKeyInput, systemMessage } = this.elements;
          const apiKey = apiKeyInput.value.trim();
          const systemMsg = systemMessage.value.trim();

          if (!apiKey) {
            alert("Please provide an API Key.");
            return;
          }

          if (!systemMsg && this.messages.length === 0) {
            alert("Please provide either a system message or at least one message item.");
            return;
          }

          // Create output item without image for text generation
          const outputId = this.addOutput(false);

          try {
            const ai = new GoogleGenAI({ apiKey });
            await this.generateTextContent(ai, systemMsg, outputId);
          } catch (error) {
            console.error("Gemini API Error:", error);
            this.updateOutput(outputId, null, `Error: ${error.message || "An unknown error occurred."}`);
          }
        }

        /**
         * Calls the Gemini API and handles the streaming response.
         * @param {GoogleGenAI} ai
         * @param {string} systemMsg
         * @param {string} outputId
         */
        async generateImageContent(ai, systemMgs, outputId) {
          // Build parts array from messages
          const parts = [];

          // Add system message as a user message
          // This appears to be a but. Image model ignores real system message
          if (systemMgs) {
            parts.push({ text: systemMgs.trim() });
          }

          // Add user messages
          for (const message of this.messages) {
            // If message has an image, add text first (with "See image:" suffix), then the image
            if (message.image) {
              // Add text if present, or just "See image:"
              const textContent = message.text.trim();
              const textWithPrompt = textContent ? `${textContent}\nSee image:` : "See image:";
              parts.push({ text: textWithPrompt });

              // Then add the image
              const base64Data = await GeminiImageManipulator.blobToBase64(message.image.blob);
              const imagePart = {
                inlineData: {
                  data: base64Data,
                  mimeType: message.image.mimeType,
                },
              };
              parts.push(imagePart);
            } else {
              // If no image, just add text if present
              if (message.text.trim()) {
                parts.push({ text: message.text.trim() });
              }
            }
          }

          const contents = [
            {
              role: "user",
              parts,
            },
          ];

          const config = {
            responseModalities: ["IMAGE"],
          };

          const response = await ai.models.generateContentStream({
            model: GeminiImageManipulator.MODEL,
            config,
            contents,
          });

          let generatedImageUrls = [];
          let textContent = "";

          for await (const chunk of response) {
            const parts = chunk.candidates?.[0]?.content?.parts || [];
            for (const part of parts) {
              if (part.inlineData) {
                const { mimeType: imgMimeType, data } = part.inlineData;
                const imageUrl = `data:${imgMimeType};base64,${data}`;
                generatedImageUrls.push(imageUrl);
              } else if (part.text) {
                textContent += part.text;
              }
            }
          }

          // Update output with results
          if (generatedImageUrls.length > 0) {
            const finalImageUrl = generatedImageUrls[0];
            this.updateOutput(outputId, finalImageUrl, textContent || "Image successfully generated.");
          } else {
            this.updateOutput(outputId, GeminiImageManipulator.PLACEHOLDER_IMAGE, textContent || "Generation complete, but no image was returned.");
          }
        }

        /**
         * Calls the Gemini API for text generation and handles the streaming response.
         * @param {GoogleGenAI} ai
         * @param {string} systemMsg
         * @param {string} outputId
         */
        async generateTextContent(ai, systemMsg, outputId) {
          // Build parts array from messages
          const parts = [];

          // Add user messages
          for (const message of this.messages) {
            // If message has an image, add text first (with "See image:" suffix), then the image
            if (message.image) {
              // Add text if present, or just "See image:"
              const textContent = message.text.trim();
              const textWithPrompt = textContent ? `${textContent} See image:` : "See image:";
              parts.push({ text: textWithPrompt });

              // Then add the image
              const base64Data = await GeminiImageManipulator.blobToBase64(message.image.blob);
              const imagePart = {
                inlineData: {
                  data: base64Data,
                  mimeType: message.image.mimeType,
                },
              };
              parts.push(imagePart);
            } else {
              // If no image, just add text if present
              if (message.text.trim()) {
                parts.push({ text: message.text.trim() });
              }
            }
          }

          const contents = [
            {
              role: "user",
              parts,
            },
          ];

          const config = {};

          // Set system instruction in config if present
          if (systemMsg) {
            config.systemInstruction = systemMsg;
          }

          const response = await ai.models.generateContentStream({
            model: GeminiImageManipulator.TEXT_MODEL,
            config,
            contents,
          });

          let textContent = "";

          for await (const chunk of response) {
            const chunkText = chunk.text || "";
            textContent += chunkText;

            // Update output with streaming text (no image)
            this.updateOutput(outputId, null, textContent);
          }

          // Final update to mark as complete
          if (!textContent) {
            textContent = "Text generation complete, but no text was returned.";
          }
          this.updateOutput(outputId, null, textContent);
        }

        // --- 5. UTILITY PURE FUNCTIONS (Static) ---

        /**
         * Converts a Blob object into a base64 string (for API transmission).
         * @param {Blob} blob
         * @returns {Promise<string>} Base64 string without the data URL prefix.
         */
        static blobToBase64(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
              const dataUrl = reader.result;
              const base64 = dataUrl.split(",")[1];
              resolve(base64);
            };
            reader.onerror = (error) => reject(error);
            reader.readAsDataURL(blob);
          });
        }

        /**
         * Converts a Blob object into a data URL (for UI display).
         * @param {Blob} blob
         * @returns {Promise<string>} Data URL string.
         */
        static blobToDataUrl(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = (error) => reject(error);
            reader.readAsDataURL(blob);
          });
        }
      }

      // Initialize the application
      document.addEventListener("DOMContentLoaded", () => {
        new GeminiImageManipulator();
      });
    </script>
  </body>
</html>
