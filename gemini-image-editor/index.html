<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini Multi-Image Manipulator (esm.sh)</title>
    <style>
      /* CSS Variables for easy theming/refactoring */
      :root {
        --color-text-primary: #333;
        --color-text-secondary: #555;
        --color-border-light: #eee;
        --color-border-medium: #ccc;
        --color-border-dark: #aaa;
        --color-accent: blue;
        --color-background-hover: #f0f8ff;
        --color-overlay: rgba(0, 0, 0, 0.5);
        --color-white: white;
        --color-drag-handle: #999;
        --color-delete-button: transparent; /* Changed for emoji button */
        --color-insert-indicator: #28a745;
      }

      /* Minimal CSS to ensure readability and structure */
      body {
        font-family: sans-serif;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        color: var(--color-text-primary);
      }
      header h1 {
        border-bottom: 1px solid var(--color-border-medium);
        padding-bottom: 10px;
      }
      .input-section,
      .output-section {
        margin-bottom: 20px;
        padding: 15px;
        border: 1px solid var(--color-border-light);
        border-radius: 4px;
      }

      textarea,
      input[type="text"],
      input[type="password"] {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
        margin-top: 5px;
        margin-bottom: 10px;
      }
      textarea {
        field-sizing: content;
        resize: none;
      }
      button {
        cursor: pointer;
      }

      .action-buttons {
        margin-top: 10px;
        text-align: left;
      }

      .loading {
        display: none;
        margin-top: 10px;
        color: var(--color-text-secondary);
      }

      /* Message Items Container */
      #messages-container {
        margin-top: 15px;
      }

      /* Individual Message Item */
      .message-item {
        /* Using Grid Layout for flexible column organization */
        display: grid;
        grid-template-columns: auto auto 1fr auto; /* Handle | Thumbnail | Content | Delete */
        align-items: start; /* Vertically align items */
        margin-bottom: 10px;
        border: 1px solid var(--color-border-medium);
        border-radius: 4px;
        background-color: var(--color-white);
        position: relative;
      }

      .message-item.dragging {
        opacity: 0.5;
      }

      .message-item.drag-over-top::before,
      .message-item.drag-over-bottom::after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        height: 3px;
        background-color: var(--color-insert-indicator);
        z-index: 10;
      }

      .message-item.drag-over-top::before {
        top: -2px;
      }

      .message-item.drag-over-bottom::after {
        bottom: -2px;
      }

      /* Drag Handle (Column 1) */
      .drag-handle {
        grid-column: 1 / 2;
        width: 30px;
        /* height is removed to allow vertical centering based on content */
        background-color: transparent; /* Made transparent */
        cursor: grab;
        display: flex;
        align-items: center; /* Vertically center the content (â‹®â‹®) */
        justify-content: center;
        color: var(--color-drag-handle);
        font-size: 24px; /* Larger size for 'â‹®â‹®' */
        line-height: 1;
        user-select: none;
        padding: 8px 0; /* Add padding to give it vertical space */
      }

      .drag-handle:active {
        cursor: grabbing;
      }

      /* Content Area (Thumbnail/Textarea Wrapper) */
      /* Note: For text-only items, the thumbnail column collapses, and the content spans two columns */

      .message-content {
        grid-column: 3 / 4; /* Default placement for image or text */
        display: flex;
        gap: 10px;
        width: 100%;
        /* Remove align-items: center so textarea bleeds top/bottom */
      }

      .message-item[data-type="text"] .message-content {
        grid-column: 2 / 4; /* Text items span the thumbnail and content columns */
        gap: 0; /* No gap needed if only textarea is present */
      }

      /* Thumbnail (Column 2) */
      .message-thumbnail {
        grid-column: 2 / 3;
        width: 80px;
        height: 80px;
        object-fit: cover;
        border: 1px solid var(--color-border-medium);
        border-radius: 4px;
        padding: 10px;
      }
      .message-item[data-type="text"] .message-thumbnail {
        display: none; /* Hide thumbnail column for text items */
      }

      /* Textarea for text items and image names (takes the available space) */
      .message-textarea {
        flex: 1;
        min-width: 100%; /* Ensure it fills the grid column space */
        margin: 0; /* Remove default margin */
        padding: 10px; /* Add padding inside the textarea */
        border: none; /* --- REMOVE BORDER --- */
        /* Ensure it bleeds top to bottom */
        height: 100%;
      }

      /* Delete Button (Column 4) */
      .delete-button {
        grid-column: 4 / 5;
        justify-self: center;
        align-self: flex-start; /* Align to the top of the row */
        background-color: var(--color-delete-button);
        border: none;
        cursor: pointer;
        font-size: 24px; /* Larger size for the emoji */
        padding: 0;
        line-height: 1;
        margin: 10px; /* Add margin for spacing */
      }

      .delete-button:hover {
        opacity: 0.8;
      }

      /* Output Image */
      #output-image {
        max-width: 100%;
        height: auto;
        border: 1px solid var(--color-border-medium);
        margin-top: 10px;
      }

      /* Hidden file input */
      .hidden-file-input {
        display: none;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Gemini Multi-Image Manipulator</h1>
      <p>Add text and images, then use a prompt to manipulate them.</p>
    </header>

    <div class="input-section">
      <h2>1. API Key</h2>
      <label for="api-key">Gemini API Key:</label>
      <input type="password" id="api-key" placeholder="Enter your Gemini API Key here" />
    </div>

    <div class="input-section">
      <h2>2. Messages (Text & Images)</h2>
      <div class="action-buttons">
        <button id="add-text-button">Add Text</button>
        <button id="add-image-button">Add Image</button>
        <button id="delete-all-button">Delete All</button>
      </div>
      <div id="messages-container">
        <!-- Message items will be inserted here -->
      </div>
      <input type="file" id="hidden-file-input" class="hidden-file-input" accept="image/*" />
    </div>

    <div class="input-section">
      <h2>3. Prompt</h2>
      <label for="prompt-input">Manipulation Prompt:</label>
      <textarea id="prompt-input" rows="4" placeholder="e.g., 'Blend the two images into a single surreal landscape.'"></textarea>
      <button id="generate-button">Generate Image</button>
      <div id="loading" class="loading">Processing... Please wait.</div>
    </div>

    <div class="output-section">
      <h2>4. Output</h2>
      <p id="output-text"></p>
      <img id="output-image" style="display: none" alt="Generated Image" />
    </div>

    <script type="module">
      import { GoogleGenAI } from "https://esm.sh/@google/genai";
      import { get, set, createStore } from "https://esm.sh/idb-keyval";

      class GeminiImageManipulator {
        // --- 1. CONSTANTS ---
        static MODEL = "gemini-2.5-flash-image-preview";
        static DB_NAME = "gemini-image-sandbox";
        static STORE_NAME = "keyval";
        static MESSAGE_TYPE_TEXT = "text";
        static MESSAGE_TYPE_IMAGE = "image";

        // --- 2. MAIN CLASS & CONSTRUCTOR ---

        constructor() {
          // State: Array of message items
          // Each item: { id: string, type: "text" | "image", content: string (for text) or {blob, mimeType, dataUrl, name} (for image) }
          this.messages = [];
          this.nextId = 1;

          // Drag state
          this.draggedElement = null;
          this.draggedId = null;

          // Persistence Store
          this.store = createStore(GeminiImageManipulator.DB_NAME, GeminiImageManipulator.STORE_NAME);

          // DOM Elements
          this.elements = {
            apiKeyInput: document.getElementById("api-key"),
            promptInput: document.getElementById("prompt-input"),
            generateButton: document.getElementById("generate-button"),
            messagesContainer: document.getElementById("messages-container"),
            addTextButton: document.getElementById("add-text-button"),
            addImageButton: document.getElementById("add-image-button"),
            deleteAllButton: document.getElementById("delete-all-button"),
            hiddenFileInput: document.getElementById("hidden-file-input"),
            outputImage: document.getElementById("output-image"),
            outputText: document.getElementById("output-text"),
            loadingIndicator: document.getElementById("loading"),
          };

          this.loadState().then(() => {
            this.bindEvents();
            this.renderMessages();
          });
        }

        // --- Persistence Methods ---

        async loadState() {
          try {
            const { apiKeyInput, promptInput, outputImage } = this.elements;

            // Load API Key
            const apiKey = await get("apiKey", this.store);
            if (apiKey) apiKeyInput.value = apiKey;

            // Load Prompt
            const prompt = await get("prompt", this.store);
            if (prompt) promptInput.value = prompt;

            // Load Messages
            const messages = await get("messages", this.store);
            if (messages && Array.isArray(messages)) {
              // Reconstruct messages, converting Blobs back to data URLs for images
              this.messages = await Promise.all(
                messages.map(async (msg) => {
                  if (msg.type === GeminiImageManipulator.MESSAGE_TYPE_IMAGE) {
                    const dataUrl = await GeminiImageManipulator.blobToDataUrl(msg.content.blob);
                    return {
                      ...msg,
                      content: {
                        ...msg.content,
                        dataUrl: dataUrl,
                      },
                    };
                  }
                  return msg;
                })
              );
              // Update nextId to avoid collisions
              const maxId = Math.max(...this.messages.map((m) => parseInt(m.id)), 0);
              this.nextId = maxId + 1;
            }

            // Load Output Image
            const outputDataUrl = await get("outputImage", this.store);
            if (outputDataUrl) {
              outputImage.src = outputDataUrl;
              outputImage.style.display = "block";
            }
          } catch (error) {
            console.error("Error loading state from IndexedDB:", error);
          }
        }

        async saveApiKey(key) {
          await set("apiKey", key, this.store);
        }

        async savePrompt(prompt) {
          await set("prompt", prompt, this.store);
        }

        async saveMessages() {
          // Store messages, keeping Blobs for images but removing dataUrl
          const serializableMessages = this.messages.map((msg) => {
            if (msg.type === GeminiImageManipulator.MESSAGE_TYPE_IMAGE) {
              return {
                ...msg,
                content: {
                  blob: msg.content.blob,
                  mimeType: msg.content.mimeType,
                  name: msg.content.name,
                  // dataUrl is omitted for storage efficiency
                },
              };
            }
            return msg;
          });
          await set("messages", serializableMessages, this.store);
        }

        async saveOutput(dataUrl) {
          await set("outputImage", dataUrl, this.store);
        }

        // --- Event Binding ---

        bindEvents() {
          this.elements.generateButton.addEventListener("click", () => this.handleGenerate());
          this.elements.addTextButton.addEventListener("click", () => this.addTextMessage());
          this.elements.addImageButton.addEventListener("click", () => this.elements.hiddenFileInput.click());
          this.elements.deleteAllButton.addEventListener("click", () => this.deleteAllMessages());
          this.elements.hiddenFileInput.addEventListener("change", (e) => this.handleImageFileInput(e));

          // Persistence listeners
          this.elements.apiKeyInput.addEventListener("input", (e) => this.saveApiKey(e.target.value.trim()));
          this.elements.promptInput.addEventListener("input", (e) => this.savePrompt(e.target.value.trim()));
        }

        // --- Message Management ---

        addTextMessage() {
          const id = String(this.nextId++);
          this.messages.push({
            id,
            type: GeminiImageManipulator.MESSAGE_TYPE_TEXT,
            content: "",
          });
          this.renderMessages();
          this.saveMessages();
        }

        async addImageMessage(file) {
          if (!file.type.startsWith("image/")) return;

          const id = String(this.nextId++);
          const blob = file;
          const mimeType = file.type;
          const dataUrl = await GeminiImageManipulator.blobToDataUrl(blob);

          this.messages.push({
            id,
            type: GeminiImageManipulator.MESSAGE_TYPE_IMAGE,
            content: {
              blob,
              mimeType,
              dataUrl,
              name: "",
            },
          });
          this.renderMessages();
          this.saveMessages();
        }

        deleteMessage(id) {
          this.messages = this.messages.filter((msg) => msg.id !== id);
          this.renderMessages();
          this.saveMessages();
        }

        deleteAllMessages() {
          this.messages = [];
          this.renderMessages();
          this.saveMessages();
        }

        updateMessageContent(id, content) {
          const message = this.messages.find((msg) => msg.id === id);
          if (message) {
            if (message.type === GeminiImageManipulator.MESSAGE_TYPE_TEXT) {
              message.content = content;
            } else if (message.type === GeminiImageManipulator.MESSAGE_TYPE_IMAGE) {
              message.content.name = content;
            }
            this.saveMessages();
          }
        }

        async handleImageFileInput(event) {
          const file = event.target.files[0];
          if (file) {
            await this.addImageMessage(file);
          }
          event.target.value = ""; // Clear input for next selection
        }

        // --- Rendering ---

        renderMessages() {
          const container = this.elements.messagesContainer;
          container.innerHTML = "";

          this.messages.forEach((message) => {
            const itemElement = this.createMessageElement(message);
            container.appendChild(itemElement);
          });
        }

        createMessageElement(message) {
          const item = document.createElement("div");
          item.className = "message-item";
          item.dataset.id = message.id;
          item.dataset.type = message.type; /* Added data-type for CSS grid adjustment */
          item.draggable = true;

          // Drag Handle (Column 1)
          const dragHandle = document.createElement("div");
          dragHandle.className = "drag-handle";
          dragHandle.innerHTML = "â‹®"; // Vertical three dots
          item.appendChild(dragHandle);

          // Thumbnail (Column 2 - only visible for image type)
          const thumbnail = document.createElement("img");
          thumbnail.className = "message-thumbnail";
          if (message.type === GeminiImageManipulator.MESSAGE_TYPE_IMAGE) {
            thumbnail.src = message.content.dataUrl;
            thumbnail.alt = "Image";
          }
          item.appendChild(thumbnail);

          // Content Area (Column 3)
          const contentArea = document.createElement("div");
          contentArea.className = "message-content";

          const textarea = document.createElement("textarea");
          textarea.className = "message-textarea";

          if (message.type === GeminiImageManipulator.MESSAGE_TYPE_TEXT) {
            textarea.value = message.content;
            textarea.placeholder = "Enter text...";
            textarea.addEventListener("input", (e) => {
              this.updateMessageContent(message.id, e.target.value);
            });
            contentArea.appendChild(textarea);
          } else if (message.type === GeminiImageManipulator.MESSAGE_TYPE_IMAGE) {
            textarea.value = message.content.name;
            textarea.placeholder = "Optional name/caption for the image...";
            textarea.addEventListener("input", (e) => {
              this.updateMessageContent(message.id, e.target.value);
            });
            contentArea.appendChild(textarea);
          }

          item.appendChild(contentArea);

          // Delete Button (Column 4)
          const deleteButton = document.createElement("button");
          deleteButton.className = "delete-button";
          deleteButton.innerHTML = "ðŸ—‘ï¸"; /* Using trash emoji button */
          deleteButton.addEventListener("click", () => this.deleteMessage(message.id));
          item.appendChild(deleteButton);

          // Drag Events
          item.addEventListener("dragstart", (e) => this.handleDragStart(e, message.id));
          item.addEventListener("dragend", (e) => this.handleDragEnd(e));
          item.addEventListener("dragover", (e) => this.handleDragOver(e));
          item.addEventListener("dragleave", (e) => this.handleDragLeave(e));
          item.addEventListener("drop", (e) => this.handleDrop(e, message.id));

          return item;
        }

        // --- Drag and Drop for Reordering ---

        handleDragStart(e, id) {
          this.draggedElement = e.currentTarget;
          this.draggedId = id;
          e.currentTarget.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/html", e.currentTarget.innerHTML);
        }

        handleDragEnd(e) {
          e.currentTarget.classList.remove("dragging");
          // Remove all drag-over classes
          document.querySelectorAll(".message-item").forEach((item) => {
            item.classList.remove("drag-over-top", "drag-over-bottom");
          });
          this.draggedElement = null;
          this.draggedId = null;
        }

        handleDragOver(e) {
          if (e.preventDefault) {
            e.preventDefault();
          }
          e.dataTransfer.dropEffect = "move";

          const targetElement = e.currentTarget;
          if (targetElement === this.draggedElement) {
            return;
          }

          // Determine if we should insert above or below
          const rect = targetElement.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const isTop = e.clientY < midpoint;

          // Remove previous indicators
          targetElement.classList.remove("drag-over-top", "drag-over-bottom");

          // Add appropriate indicator
          if (isTop) {
            targetElement.classList.add("drag-over-top");
          } else {
            targetElement.classList.add("drag-over-bottom");
          }

          return false;
        }

        handleDragLeave(e) {
          e.currentTarget.classList.remove("drag-over-top", "drag-over-bottom");
        }

        handleDrop(e, targetId) {
          if (e.stopPropagation) {
            e.stopPropagation();
          }
          e.preventDefault();

          const targetElement = e.currentTarget;
          targetElement.classList.remove("drag-over-top", "drag-over-bottom");

          if (this.draggedId === targetId) {
            return;
          }

          // Determine insertion position
          const rect = targetElement.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const isTop = e.clientY < midpoint;

          // Reorder messages array
          const draggedIndex = this.messages.findIndex((msg) => msg.id === this.draggedId);
          const targetIndex = this.messages.findIndex((msg) => msg.id === targetId);

          if (draggedIndex === -1 || targetIndex === -1) return;

          const [draggedMessage] = this.messages.splice(draggedIndex, 1);

          let insertIndex = targetIndex;
          if (draggedIndex < targetIndex) {
            // If dragging down, adjust index
            insertIndex = isTop ? targetIndex - 1 : targetIndex;
          } else {
            // If dragging up
            insertIndex = isTop ? targetIndex : targetIndex + 1;
          }

          this.messages.splice(insertIndex, 0, draggedMessage);

          this.renderMessages();
          this.saveMessages();

          return false;
        }

        // --- 3. CORE LOGIC METHODS ---

        async handleGenerate() {
          const { apiKeyInput, promptInput, generateButton, loadingIndicator, outputImage, outputText } = this.elements;
          const apiKey = apiKeyInput.value.trim();
          const prompt = promptInput.value.trim();

          if (!apiKey || this.messages.length === 0 || !prompt) {
            alert("Please ensure API Key, at least one message, and prompt are provided.");
            return;
          }

          // UI State: Start Loading
          outputImage.style.display = "none";
          outputImage.src = "";
          outputText.textContent = "";
          loadingIndicator.style.display = "block";
          generateButton.disabled = true;

          try {
            const ai = new GoogleGenAI({ apiKey });
            await this.generateContent(ai, prompt);
          } catch (error) {
            console.error("Gemini API Error:", error);
            outputText.textContent = `Error: ${error.message || "An unknown error occurred."}`;
            outputImage.style.display = "none";
          } finally {
            // UI State: Stop Loading
            loadingIndicator.style.display = "none";
            generateButton.disabled = false;
          }
        }

        /**
         * Calls the Gemini API and handles the streaming response.
         * @param {GoogleGenAI} ai
         * @param {string} prompt
         */
        async generateContent(ai, prompt) {
          const { outputImage, outputText } = this.elements;

          // Build parts array from messages
          const parts = [];
          for (const message of this.messages) {
            if (message.type === GeminiImageManipulator.MESSAGE_TYPE_TEXT) {
              parts.push({ text: message.content });
            } else if (message.type === GeminiImageManipulator.MESSAGE_TYPE_IMAGE) {
              const base64Data = await GeminiImageManipulator.blobToBase64(message.content.blob);
              const imagePart = {
                inlineData: {
                  data: base64Data,
                  mimeType: message.content.mimeType,
                },
              };
              parts.push(imagePart);
              // If there's a name, add it as text after the image
              if (message.content.name.trim()) {
                parts.push({ text: message.content.name.trim() });
              }
            }
          }

          // Add the final prompt
          parts.push({ text: prompt });

          const contents = [
            {
              role: "user",
              parts,
            },
          ];

          const config = {
            responseModalities: ["IMAGE"],
          };

          const response = await ai.models.generateContentStream({
            model: GeminiImageManipulator.MODEL,
            config,
            contents,
          });

          let generatedImageUrls = [];
          let textContent = "";

          for await (const chunk of response) {
            const parts = chunk.candidates?.[0]?.content?.parts || [];
            for (const part of parts) {
              if (part.inlineData) {
                const { mimeType: imgMimeType, data } = part.inlineData;
                const imageUrl = `data:${imgMimeType};base64,${data}`;
                generatedImageUrls.push(imageUrl);
              } else if (part.text) {
                textContent += part.text;
              }
            }
          }

          // Display results
          if (generatedImageUrls.length > 0) {
            const finalImageUrl = generatedImageUrls[0];
            outputImage.src = finalImageUrl;
            outputImage.style.display = "block";
            outputText.textContent = "Image successfully generated.";
            this.saveOutput(finalImageUrl); // Persist output
          } else {
            outputText.textContent = "Generation complete, but no image was returned. Check the text response below.";
            this.saveOutput(null);
          }

          if (textContent) {
            outputText.textContent = `Model Response: ${textContent}`;
          }
        }

        // --- 5. UTILITY PURE FUNCTIONS (Static) ---

        /**
         * Converts a Blob object into a base64 string (for API transmission).
         * @param {Blob} blob
         * @returns {Promise<string>} Base64 string without the data URL prefix.
         */
        static blobToBase64(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
              const dataUrl = reader.result;
              const base64 = dataUrl.split(",")[1];
              resolve(base64);
            };
            reader.onerror = (error) => reject(error);
            reader.readAsDataURL(blob);
          });
        }

        /**
         * Converts a Blob object into a data URL (for UI display).
         * @param {Blob} blob
         * @returns {Promise<string>} Data URL string.
         */
        static blobToDataUrl(blob) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = (error) => reject(error);
            reader.readAsDataURL(blob);
          });
        }
      }

      // Initialize the application
      document.addEventListener("DOMContentLoaded", () => {
        new GeminiImageManipulator();
      });
    </script>
  </body>
</html>
